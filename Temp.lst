                  2   $LIST
0000              4   
0000              5   CLK  EQU 22118400
0000              6   BAUD equ 115200
0000              7   BRG_VAL equ (0x100-(CLK/(16*BAUD)))
0000              8   
0000              9   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             10   TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
0000             11   TIMER1_RATE    EQU 22050     ; 22050Hz is the sampling rate of the wav file we are playing
0000             12   TIMER1_RELOAD  EQU 0x10000-(CLK/TIMER1_RATE)
0000             13   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             14   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             15   
0000             16   ; The pins used for SPI
0000             17   FLASH_CE  EQU  P2.5
0000             18   PIN_TWO_FOUR   EQU  P2.4 
0000             19   PIN_TWO_ONE   EQU  P2.1
0000             20   PIN_TWO_ZERO   EQU  P2.0 
0000             21   
0000             22   BOOT_BUTTON   equ P4.5
0000             23   SPEAKER  EQU P2.6 ; Used with a MOSFET to turn off speaker when not in use
0000             24   UP            equ P0.7
0000             25   DOWN               equ P0.5
0000             26   ; Input 3 bit binary state from TIME/FSM MCU
0000             27   STATE_bit0      equ P1.2
0000             28   STATE_bit1      equ P1.3
0000             29   STATE_bit2      equ P1.4
0000             30   STATE_STABLE    equ P1.5
0000             31   ; Outputs to Time/FSM MCU
0000             32   TEMP_OK        equ P1.0
0000             33   TEMP_50        equ P1.1
0000             34   OVEN_CTL_PIN   equ P1.6
0000             35   
0000             36    ; Commands supported by the SPI flash memory according to the datasheet
0000             37   WRITE_ENABLE     EQU 0x06  ; Address:0 Dummy:0 Num:0
0000             38   WRITE_DISABLE    EQU 0x04  ; Address:0 Dummy:0 Num:0
0000             39   READ_STATUS      EQU 0x05  ; Address:0 Dummy:0 Num:1 to infinite
0000             40   READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
0000             41   READ_SILICON_ID  EQU 0xab  ; Address:0 Dummy:3 Num:1 to infinite
0000             42   FAST_READ        EQU 0x0b  ; Address:3 Dummy:1 Num:1 to infinite
0000             43   WRITE_STATUS     EQU 0x01  ; Address:0 Dummy:0 Num:1
0000             44   WRITE_BYTES      EQU 0x02  ; Address:3 Dummy:0 Num:1 to 256
0000             45   ERASE_ALL        EQU 0xc7  ; Address:0 Dummy:0 Num:0
0000             46   ERASE_BLOCK      EQU 0xd8  ; Address:3 Dummy:0 Num:0
0000             47   READ_DEVICE_ID   EQU 0x9f  ; Address:0 Dummy:2 Num:1 to infinite
0000             48   
0000             49   org 0000H
0000 020AC7      50      ljmp MainProgram
0003             51   
0003             52   ; External interrupt 0 vector (not used in this code)
0003             53   org 0x0003
0003 32          54            reti
0004             55   
0004             56   ; Timer/Counter 0 overflow interrupt vector (not used in this code)
000B             57   org 0x000B
000B 32          58            reti
000C             59   
000C             60   ; External interrupt 1 vector (not used in this code)
0013             61   org 0x0013
0013 32          62            reti
0014             63   
0014             64   ; Timer/Counter 1 overflow interrupt vector
001B             65   org 0x001B
001B 020A58      66            ljmp Timer1_ISR
001E             67   
001E             68   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             69   org 0x0023 
0023 32          70            reti
0024             71            
0024             72   ; Timer/Counter 2 overflow interrupt vector
002B             73   org 0x002B
002B 020A97      74            ljmp Timer2_ISR
002E             75   
0030             76   DSEG at 30H
0030             77   Count1ms:           ds 2
0032             78   Count5s:            ds 1 
0033             79   x:                  ds 4 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file
0037             80   y:                  ds 4 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file
003B             81   bcd:                ds 5 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file 
0040             82   soaktemp:           ds 1
0041             83   reflowtemp:         ds 1
0042             84   volt_reading:       ds 2 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file
0044             85   temp_reading:       ds 1
0045             86   fsm_state:          ds 1 
0046             87   w:                               ds 3 ; 24-bit play counter.  Decremented in Timer 1 ISR.
0049             88   
0049             89   
0000             90   BSEG
0000             91   seconds_flag:       dbit 1
0001             92   five_seconds_flag:  dbit 1
0002             93   mf:                 dbit 1 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file
0003             94   hold_button:        dbit 1
0004             95   sound_flag:         dbit 1
0005             96   play_done:          dbit 1
0006             97   
002E             98   CSEG
002E             99   ; These ’EQU’ must match the wiring between the microcontroller and ADC (used in the INC file)
002E            100   CE_ADC  EQU P0.4
002E            101   MY_MOSI EQU P0.3
002E            102   MY_MISO EQU P0.2
002E            103   MY_SCLK EQU P0.1
002E            104   ; These 'equ' must match the hardware wiring
002E            105   ; They are used by 'LCD_4bit.inc'
002E            106   LCD_RS equ P3.2
002E            107   ; LCD_RW equ Px.x ; Always grounded
002E            108   LCD_E  equ P3.3
002E            109   LCD_D4 equ P3.4
002E            110   LCD_D5 equ P3.5
002E            111   LCD_D6 equ P3.6
002E            112   LCD_D7 equ P3.7
002E            113   
                553   $LIST
                118      $LIST
08B7            120   
08B7            121   ;                   1234567890123456
08B7 536F616B   122   SOAK_TEMP:      db 'Soak:   xxx', 0xDF, 'C   ', 0
     3A202020
     787878DF
     43202020
     00
08C8 5265666C   123   REFLOW_TEMP:    db 'Reflow: xxx', 0xDF, 'C   ', 0
     6F773A20
     787878DF
     43202020
     00
08D9 54656D70   124   CURRENT_TEMP:   db 'Temp:   xxx', 0xDF, 'C   ', 0
     3A202020
     787878DF
     43202020
     00
08EA 54617267   125   TARGET_TEMP:    db 'Target: xxx', 0xDF, 'C   ', 0
     65743A20
     787878DF
     43202020
     00
08FB 4F56454E   126   OVEN_OFF:       db 'OVEN OFF        ', 0
     204F4646
     20202020
     20202020
     00
090C            127   
090C            128   
090C            129   ; Approximate index of sounds in file 'nsound.wav'
090C            130   sound_index:       ; index | number
090C 003937     131       db 0x00, 0x39, 0x37 ; 0 1
090F 00E45D     132       db 0x00, 0xe4, 0x5d ; 1 2
0912 019444     133       db 0x01, 0x94, 0x44 ; 2 3
0915 024B4A     134       db 0x02, 0x4b, 0x4a ; 3 4
0918 02F671     135       db 0x02, 0xf6, 0x71 ; 4 5
091B 039CD6     136       db 0x03, 0x9c, 0xd6 ; 5 6
091E 04433C     137       db 0x04, 0x43, 0x3c ; 6 7
0921 04FCA1     138       db 0x04, 0xfc, 0xa1 ; 7 8
0924 05A7C8     139       db 0x05, 0xa7, 0xc8 ; 8 9
0927 066132     140       db 0x06, 0x61, 0x32 ; 9 10
092A 0702D5     141       db 0x07, 0x02, 0xd5 ; 10 11
092D 07ADF9     142       db 0x07, 0xad, 0xf9 ; 11 12
0930 085DE1     143       db 0x08, 0x5d, 0xe1 ; 12 13
0933 09174A     144       db 0x09, 0x17, 0x4a ; 13 14
0936 09B68A     145       db 0x09, 0xb6, 0x8a ; 14 15
0939 0A5F50     146       db 0x0a, 0x5f, 0x50 ; 15 16
093C 0B0CD6     147       db 0x0b, 0x0c, 0xd6 ; 16 17
093F 0BBA5C     148       db 0x0b, 0xba, 0x5c ; 17 18
0942 0C6CA5     149       db 0x0c, 0x6c, 0xa5 ; 18 19
0945 0CFDA3     150       db 0x0c, 0xfd, 0xa3 ; 19 20
0948 0DBBCC     151       db 0x0d, 0xbb, 0xcc ; 20 30
094B 0E6953     152       db 0x0e, 0x69, 0x53 ; 21 40
094E 0F03D2     153       db 0x0f, 0x03, 0xd2 ; 22 50
0951 0FC1FB     154       db 0x0f, 0xc1, 0xfb ; 23 60
0954 106AC2     155       db 0x10, 0x6a, 0xc2 ; 24 70
0957 1115E8     156       db 0x11, 0x15, 0xe8 ; 25 80
095A 11CA8E     157       db 0x11, 0xca, 0x8e ; 26 90
095D 127812     158       db 0x12, 0x78, 0x12 ; 27 100
0960 1327FB     159       db 0x13, 0x27, 0xfb ; 28 200
0963 13D0C0     160       db 0x13, 0xd0, 0xc0 ; 29 idle
0966 147725     161       db 0x14, 0x77, 0x25 ; 30 heating to soak
0969 153551     162       db 0x15, 0x35, 0x51 ; 31 soaking
096C 15CD72     163       db 0x15, 0xcd, 0x72 ; 32 heating to reflow
096F 168B8B     164       db 0x16, 0x8b, 0x8b ; 33 reflowing
0972 172ADE     165       db 0x17, 0x2a, 0xde ; 34 cooling 
0975 17D605     166       db 0x17, 0xd6, 0x05 ; 35 error
0978 187ECC     167       db 0x18, 0x7e, 0xcc 
097B            168   
097B            169   ; Size of each sound in 'sound_index'
097B            170   Size_sound:
097B 00AB26     171       db 0x00, 0xab, 0x26 ; 0 
097E 00AFE7     172       db 0x00, 0xaf, 0xe7 ; 1 
0981 00B706     173       db 0x00, 0xb7, 0x06 ; 2 
0984 00AB27     174       db 0x00, 0xab, 0x27 ; 3 
0987 00A665     175       db 0x00, 0xa6, 0x65 ; 4 
098A 00A666     176       db 0x00, 0xa6, 0x66 ; 5 
098D 00B965     177       db 0x00, 0xb9, 0x65 ; 6 
0990 00AB27     178       db 0x00, 0xab, 0x27 ; 7 
0993 00B96A     179       db 0x00, 0xb9, 0x6a ; 8 
0996 00A1A3     180       db 0x00, 0xa1, 0xa3 ; 9 
0999 00AB24     181       db 0x00, 0xab, 0x24 ; 10 
099C 00AFE8     182       db 0x00, 0xaf, 0xe8 ; 11 
099F 00B969     183       db 0x00, 0xb9, 0x69 ; 12 
09A2 009F40     184       db 0x00, 0x9f, 0x40 ; 13 
09A5 00A8C6     185       db 0x00, 0xa8, 0xc6 ; 14 
09A8 00AD86     186       db 0x00, 0xad, 0x86 ; 15 
09AB 00AD86     187       db 0x00, 0xad, 0x86 ; 16 
09AE 00B249     188       db 0x00, 0xb2, 0x49 ; 17 
09B1 0090FE     189       db 0x00, 0x90, 0xfe ; 18 
09B4 00BE29     190       db 0x00, 0xbe, 0x29 ; 19 
09B7 00AD87     191       db 0x00, 0xad, 0x87 ; 20 
09BA 009A7F     192       db 0x00, 0x9a, 0x7f ; 21 
09BD 00BE29     193       db 0x00, 0xbe, 0x29 ; 22 
09C0 00A8C7     194       db 0x00, 0xa8, 0xc7 ; 23 
09C3 00AB26     195       db 0x00, 0xab, 0x26 ; 24 
09C6 00B4A6     196       db 0x00, 0xb4, 0xa6 ; 25 
09C9 00AD84     197       db 0x00, 0xad, 0x84 ; 26 
09CC 00AFE9     198       db 0x00, 0xaf, 0xe9 ; 27 
09CF 00A8C5     199       db 0x00, 0xa8, 0xc5 ; 28 
09D2 00A665     200       db 0x00, 0xa6, 0x65 ; 29 
09D5 00BE2C     201       db 0x00, 0xbe, 0x2c ; 30 
09D8 009821     202       db 0x00, 0x98, 0x21 ; 31 
09DB 00BE19     203       db 0x00, 0xbe, 0x19 ; 32 
09DE 009F53     204       db 0x00, 0x9f, 0x53 ; 33 
09E1 00AB27     205       db 0x00, 0xab, 0x27 ; 34 
09E4 00A8C7     206       db 0x00, 0xa8, 0xc7 ; 35 
09E7            207   
09E7            208   Timer1_Init:
09E7            209            ; Configure P2.0, P2.4, P2.5 as open drain outputs
09E7 43CE31     210            orl P2M0, #0b_0011_0001
09EA 43CF31     211            orl P2M1, #0b_0011_0001
09ED D2A1       212            setb PIN_TWO_ONE  ; Configured as input
09EF D2A5       213            setb FLASH_CE ; CS=1 for SPI flash memory
09F1 C2A0       214            clr PIN_TWO_ZERO   ; Rest state of SCLK=0
09F3 C2A6       215            clr SPEAKER   ; Turn off speaker.
09F5            216            
09F5            217            ; Configure timer 1
09F5 53890F     218            anl     TMOD, #0x0F ; Clear the bits of timer 1 in TMOD
09F8 438910     219            orl     TMOD, #0x10 ; Set timer 1 in 16-bit timer mode.  Don't change the bits of timer 0
09FB 758DFC     220            mov TH1, #high(TIMER1_RELOAD)
09FE 758B15     221            mov TL1, #low(TIMER1_RELOAD)
0A01            222            ; Set autoreload value
0A01 75F5FC     223            mov RH1, #high(TIMER1_RELOAD)
0A04 75F315     224            mov RL1, #low(TIMER1_RELOAD)
0A07            225   
0A07            226            ; Enable the timer and interrupts
0A07 D2AB       227       setb ET1  ; Enable timer 1 interrupt
0A09            228            ; setb TR1 ; Timer 1 is only enabled to play stored sound
0A09            229   
0A09            230            ; Configure the DAC.  The DAC output we are using is P2.3, but P2.2 is also reserved.
0A09 75A5A0     231            mov DADI, #0b_1010_0000 ; ACON=1
0A0C 75A43A     232            mov DADC, #0b_0011_1010 ; Enabled, DAC mode, Left adjusted, CLK/4
0A0F 75AD80     233            mov DADH, #0x80 ; Middle of scale
0A12 75AC00     234            mov DADL, #0
0A15 43A440     235            orl DADC, #0b_0100_0000 ; Start DAC by GO/BSY=1
0A18            236   
0A18            237   check_DAC_init:
0A18 E5A4       238            mov a, DADC
0A1A 20E6FB     239            jb acc.6, check_DAC_init ; Wait for DAC to finish
0A1D D2AF       240            setb EA ; Enable interrupts
0A1F 22         241       ret
0A20            242   
0A20            243   ;---------------------------------;
0A20            244   ; Routine to initialize the ISR   ;
0A20            245   ; for timer 2                     ;
0A20            246   ;---------------------------------;
0A20            247   Timer2_Init:
0A20 75C800     248            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
0A23 75CDA9     249            mov TH2, #high(TIMER2_RELOAD)
0A26 75CC9A     250            mov TL2, #low(TIMER2_RELOAD)
0A29            251            ; Set the reload value
0A29 75CBA9     252            mov RCAP2H, #high(TIMER2_RELOAD)
0A2C 75CA9A     253            mov RCAP2L, #low(TIMER2_RELOAD)
0A2F            254            ; Init one millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
0A2F E4         255            clr a
0A30 F530       256            mov Count1ms+0, a
0A32 F531       257            mov Count1ms+1, a
0A34            258       ; Init five second interrupt counter
0A34 F532       259       mov Count5s, a
0A36            260            ; Enable the timer and interrupts
0A36 D2AD       261       setb ET2  ; Enable timer 2 interrupt
0A38 D2CA       262       setb TR2  ; Enable timer 2
0A3A 22         263            ret
0A3B            264   
0A3B            265   ; Configure the serial port and baud rate
0A3B            266   InitSerialPort:
0A3B            267       ; Since the reset button bounces, we need to wait a bit before
0A3B            268       ; sending messages, otherwise we risk displaying gibberish!
0A3B 79DE       269       mov R1, #222
0A3D 78A6       270       mov R0, #166
0A3F D8FE       271       djnz R0, $   ; 3 cycles->3*45.21123ns*166=22.51519us
0A41 D9FA       272       djnz R1, $-4 ; 22.51519us*222=4.998ms
0A43            273       ; Now we can proceed with the configuration
0A43 438780     274            orl     PCON,#0x80
0A46 759852     275            mov     SCON,#0x52
0A49 759B00     276            mov     BDRCON,#0x00
0A4C 759AF4     277            mov     BRL,#BRG_VAL
0A4F 759B1E     278            mov     BDRCON,#0x1E ; BDRCON=BRR|TBCK|RBCK|SPD;
0A52 22         279       ret
0A53            280   
0A53            281   INIT_SPI:
0A53 D282       282       setb MY_MISO    ; Make MISO an input pin
0A55 C281       283       clr MY_SCLK     ; For mode (0,0) SCLK is zero
0A57 22         284       ret
0A58            285   
0A58            286   ;-------------------------------------;
0A58            287   ; ISR for Timer 1.  Used to playback  ;
0A58            288   ; the WAV file stored in the SPI      ;
0A58            289   ; flash memory.                       ;
0A58            290   ;-------------------------------------;
0A58            291   Timer1_ISR:
0A58            292            ; The registers used in the ISR must be saved in the stack
0A58 C0E0       293            push acc
0A5A C0D0       294            push psw
0A5C            295   
0A5C            296       ; Timer 1 is playing a sound. Set a flag so the main program knows
0A5C C205       297            clr play_done
0A5E            298   
0A5E            299            ; Check if the play counter is zero.  If so, stop playing sound.
0A5E E546       300            mov a, w+0
0A60 4547       301            orl a, w+1
0A62 4548       302            orl a, w+2
0A64 601E       303            jz stop_playing
0A66            304            
0A66            305            ; Decrement play counter 'w'.  In this implementation 'w' is a 24-bit counter.
0A66 74FF       306            mov a, #0xff
0A68 1546       307            dec w+0
0A6A B54607     308            cjne a, w+0, keep_playing
0A6D 1547       309            dec w+1
0A6F B54702     310            cjne a, w+1, keep_playing
0A72 1548       311            dec w+2
0A74            312            
0A74            313   keep_playing:
0A74 D2A6       314            setb SPEAKER
0A76 120433     315            lcall Send_SPI ; Read the next byte from the SPI Flash...
0A79 F580       316            mov P0, a ; WARNING: Remove this if not using an external DAC to use the pins of P0 as GPIO
0A7B 2480       317            add a, #0x80
0A7D F5AD       318            mov DADH, a ; Output to DAC. DAC output is pin P2.3
0A7F 43A440     319            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
0A82 800E       320            sjmp Timer1_ISR_Done
0A84            321   
0A84            322   stop_playing:
0A84 C28E       323            clr TR1 ; Stop timer 1
0A86 D2A5       324            setb FLASH_CE  ; Disable SPI Flash
0A88 C2A6       325            clr SPEAKER ; Turn off speaker.  Removes hissing noise when not playing sound.
0A8A 75AD80     326            mov DADH, #0x80 ; middle of range
0A8D 43A440     327            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
0A90            328   
0A90            329       ; Timer 1 has finished playing a sound. Set a flag so the main program knows         
0A90 D205       330       setb play_done
0A92            331   
0A92            332   Timer1_ISR_Done:
0A92 D0D0       333            pop psw
0A94 D0E0       334            pop acc
0A96 32         335            reti
0A97            336   
0A97            337   ;---------------------------------;
0A97            338   ; ISR for timer 2                 ;
0A97            339   ;---------------------------------;
0A97            340   Timer2_ISR:
0A97 C2CF       341            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
0A99            342            ;cpl P1.0 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
0A99            343            
0A99            344            ; The two registers used in the ISR must be saved in the stack
0A99 C0E0       345            push acc
0A9B C0D0       346            push psw
0A9D            347            
0A9D            348            ; Increment the 16-bit one mili second counter
0A9D 0530       349            inc Count1ms+0    ; Increment the low 8-bits first
0A9F E530       350            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0AA1 7002       351            jnz Inc_Done
0AA3 0531       352            inc Count1ms+1
0AA5            353   
0AA5            354   Inc_Done:
0AA5            355            ; Check if 1 second has passed
0AA5 E530       356            mov a, Count1ms+0
0AA7 B4FA18     357            cjne a, #low(250), Timer2_ISR_done ; Warning: this instruction high_low_flags the carry flag!
0AAA E531       358            mov a, Count1ms+1
0AAC B40013     359            cjne a, #high(250), Timer2_ISR_done
0AAF            360            
0AAF            361            ; 1 second has passed. Set a flag so the main program knows
0AAF D200       362            setb seconds_flag ; Let the main program know 1 second has passed
0AB1 E4         363            clr a
0AB2 F530       364            mov Count1ms+0, a
0AB4 F531       365            mov Count1ms+1, a
0AB6 0532       366       inc Count5s
0AB8            367   
0AB8            368   Inc_Done_a:
0AB8            369       ; Check if 5 seconds has passed
0AB8 E532       370       mov a, Count5s
0ABA B40505     371       cjne a, #5, Timer2_ISR_done
0ABD            372       
0ABD            373       ; 5 seconds have passed. Set a flag so the main program knows
0ABD D201       374       setb five_seconds_flag
0ABF 753200     375       mov Count5s, #0
0AC2            376   
0AC2            377   Timer2_ISR_done:
0AC2 D0D0       378            pop psw
0AC4 D0E0       379            pop acc
0AC6 32         380            reti
0AC7            381   
0AC7            382   ;---------------------------------;
0AC7            383   ; Main Program                    ;
0AC7            384   ;---------------------------------;
0AC7            385   MainProgram:
0AC7 75817F     386       mov SP, #7FH ; Set the stack pointer to the begining of idata
0ACA D2AF       387       setb EA   ; Enable Global interrupts
0ACC 75E600     388       mov P0M0, #0
0ACF 75E700     389       mov P0M1, #0
0AD2 75D600     390       mov P1M0, #0
0AD5 75D700     391       mov P1M1, #0
0AD8 75CE00     392       mov P2M0, #0
0ADB 75CF00     393       mov P2M1, #0
0ADE            394       
0ADE 120A3B     395       lcall InitSerialPort
0AE1 120A53     396       lcall INIT_SPI
0AE4 120088     397       lcall LCD_4BIT
0AE7 1209E7     398       lcall Timer1_Init
0AEA 120A20     399       lcall Timer2_Init
0AED            400   
0AED D292       401       setb STATE_bit0
0AEF D293       402       setb STATE_bit1
0AF1 D294       403       setb STATE_bit2
0AF3 D295       404       setb STATE_STABLE
0AF5            405   
0AF5 C290       406       clr TEMP_OK
0AF7 C291       407       clr TEMP_50
0AF9 C296       408       clr OVEN_CTL_PIN
0AFB            409   
0AFB C200       410       clr seconds_flag
0AFD C201       411       clr five_seconds_flag
0AFF C203       412       clr hold_button
0B01 D205       413       setb play_done
0B03            414   
0B03 753000     415       mov count1ms+0, #0
0B06 753000     416       mov count1ms+0, #0
0B09            417       ; defualt soaktemp = 150
0B09 754096     418       mov soaktemp, #0x96
0B0C            419       ; default reflowtemp = 240
0B0C 7541F0     420       mov reflowtemp, #0xF0
0B0F            421   
0B0F 020E15     422       ljmp setup ; jump to setup after reset
0B12            423   
0B12            424   ;-------------------------------------------------- STATE 0 --------------------------------------------------
0B12            425   ; idle state, reflow oven is off
0B12            426   State_0:
0B12            427       ; check state
0B12 3095FD     428       jnb STATE_STABLE, $ ; wait for state to be stable
0B15 120497     429       lcall read_state 
0B18 B40051     430       cjne a, #0, State_1
0B1B            431   
0B1B            432       ; turn off the oven
0B1B C296       433       clr OVEN_CTL_PIN
0B1D            434   
0B1D            435       ; temperature is set, TEMP_OK = 1
0B1D D290       436       setb TEMP_OK
0B1F            437   
0B1F            438       ; display "OVEN OFF" message
0B1F C0E0       439            push acc
0B21 7401       439            mov a, #1
0B23 14         439            dec a
0B24 1200BD     439            lcall ?Set_Cursor_2 ; Select column and row
0B27 D0E0       439            pop acc
0B29 C083       440            push dph
0B2B C082       440            push dpl
0B2D C0E0       440            push acc
0B2F 9008FB     440            mov dptr, #OVEN_OFF
0B32 1200B2     440            lcall ?Send_Constant_String
0B35 D0E0       440            pop acc
0B37 D082       440            pop dpl
0B39 D083       440            pop dph
0B3B            441   
0B3B            442       ;lcall Sound_Idle; [sound saying the current state "Idle"]
0B3B 781D       443       mov r0,#29
0B3D 12050A     444       lcall Play_Sound_Using_Index
0B40            445       ; if BOOT_BUTTON is being pressed, wait for release
0B40 30C5FD     446       jnb BOOT_BUTTON, $
0B43            447       
0B43            448   Idle:
0B43            449       ; check state
0B43 3095FD     450       jnb STATE_STABLE, $ ; wait for state to be stable
0B46 120497     451       lcall read_state
0B49 B40020     452       cjne a, #0, State_1
0B4C            453       ; Read tempurature every second
0B4C 30000B     454       jnb seconds_flag, Idle_a
0B4F C200       455       clr seconds_flag
0B51 1203F7     456       lcall Read_ADC
0B54 1204A3     457       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0B57 120396     458       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
0B5A            459   Idle_a:
0B5A            460       ; if BOOT_BUTTON is pressed, jump to setup
0B5A 20C5E6     461       jb BOOT_BUTTON, Idle
0B5D C002       462            push AR2
0B5F 7A32       462            mov R2, #50
0B61 120039     462            lcall ?Wait_Milli_Seconds
0B64 D002       462            pop AR2 ; debounce time
0B66 20C5DA     463       jb BOOT_BUTTON, Idle
0B69 020E15     464       ljmp setup
0B6C            465   
0B6C            466   ;-------------------------------------------------- STATE 1 --------------------------------------------------
0B6C            467   ; heating to soak temperature
0B6C            468   State_1:
0B6C            469       ; check state
0B6C 3095FD     470       jnb STATE_STABLE, $ ; wait for state to be stable
0B6F 120497     471       lcall read_state
0B72 B40160     472       cjne a, #1, Jump_State_2 ; offset was too large for cjne to jump to State_2, branching to a ljmp
0B75            473   
0B75            474       ; turn on the oven
0B75 D296       475       setb OVEN_CTL_PIN
0B77            476   
0B77            477       ; display target temperature
0B77 C0E0       478            push acc
0B79 7401       478            mov a, #1
0B7B 14         478            dec a
0B7C 1200BD     478            lcall ?Set_Cursor_2 ; Select column and row
0B7F D0E0       478            pop acc
0B81 C083       479            push dph
0B83 C082       479            push dpl
0B85 C0E0       479            push acc
0B87 9008EA     479            mov dptr, #TARGET_TEMP
0B8A 1200B2     479            lcall ?Send_Constant_String
0B8D D0E0       479            pop acc
0B8F D082       479            pop dpl
0B91 D083       479            pop dph
0B93 753300     480            mov x+0, #low (0 % 0x10000) 
0B96 753400     480            mov x+1, #high(0 % 0x10000) 
0B99 753500     480            mov x+2, #low (0 / 0x10000) 
0B9C 753600     480            mov x+3, #high(0 / 0x10000) 
0B9F 854033     481       mov x+0, soaktemp
0BA2 1200DA     482       lcall hex2bcd
0BA5 C0E0       483            push acc
0BA7 7408       483            mov a, #8
0BA9 14         483            dec a
0BAA 1200BD     483            lcall ?Set_Cursor_2 ; Select column and row
0BAD D0E0       483            pop acc
0BAF C000       483            push ar0
0BB1 A83C       483            mov r0, bcd+1
0BB3 1200C4     483            lcall ?Display_BCD
0BB6 D000       483            pop ar0
0BB8 C000       483            push ar0
0BBA A83B       483            mov r0, bcd+0
0BBC 1200C4     483            lcall ?Display_BCD
0BBF D000       483            pop ar0
0BC1            483            ; Replace all the zeros to the left with blanks
0BC1 C0E0       483            push acc
0BC3 7408       483            mov a, #8
0BC5 14         483            dec a
0BC6 1200BD     483            lcall ?Set_Cursor_2 ; Select column and row
0BC9 D0E0       483            pop acc
0BCB 12034A     483            lcall replace_zeros
0BCE            484   
0BCE            485       ; [Sound for saying the current state "Heating to soak"]
0BCE 781E       486       mov r0,#30
0BD0 12050A     487       lcall Play_Sound_Using_Index
0BD3 8003       488       sjmp Heating_To_Soak
0BD5            489   
0BD5            490   Jump_State_2:   ; ljmp to state 2
0BD5 020C2A     491       ljmp State_2
0BD8            492   
0BD8            493   Heating_To_Soak:
0BD8            494       ; read temperature every second
0BD8 30000B     495       jnb seconds_flag, Heating_To_Soak_a
0BDB C200       496       clr seconds_flag
0BDD 1203F7     497       lcall Read_ADC
0BE0 1204A3     498       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0BE3 120396     499       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
0BE6            500   Heating_To_Soak_a:
0BE6            501       ; play sound every five seconds
0BE6 30010C     502       jnb five_seconds_flag, Heating_To_Soak_b
0BE9 C201       503       clr five_seconds_flag
0BEB 7813       504       mov r0, #19; load sound index for 20 in r0
0BED 12050A     505       lcall Play_Sound_Using_Index; play the sound for 20
0BF0 7801       506       mov r0, #1; load sound index for 2 in r0
0BF2 12050A     507       lcall Play_Sound_Using_Index; play the sound for 2
0BF5            508   Heating_To_Soak_b:
0BF5            509       ; if temperature >= reflow temperature, TEMP_OK = 0
0BF5            510       ; else 1
0BF5 753300     511            mov x+0, #low (0 % 0x10000) 
0BF8 753400     511            mov x+1, #high(0 % 0x10000) 
0BFB 753500     511            mov x+2, #low (0 / 0x10000) 
0BFE 753600     511            mov x+3, #high(0 / 0x10000) 
0C01 753700     512            mov y+0, #low (0 % 0x10000) 
0C04 753800     512            mov y+1, #high(0 % 0x10000) 
0C07 753900     512            mov y+2, #low (0 / 0x10000) 
0C0A 753A00     512            mov y+3, #high(0 / 0x10000) 
0C0D 854433     513       mov x+0, temp_reading
0C10 854037     514       mov y+0, soaktemp
0C13 120240     515       lcall x_gteq_y
0C16 300202     516       jnb mf, Heating_To_Soak_c
0C19 C290       517       clr TEMP_OK
0C1B            518   Heating_To_Soak_c:
0C1B            519       ; if temperature >= 50, TEMP_50 = 1
0C1B            520       ; else, TEMP_50 = 0
0C1B 1204E3     521       lcall Check_50
0C1E            522       ; check state
0C1E 3095FD     523       jnb STATE_STABLE, $ ; wait for state to be stable
0C21 120497     524       lcall read_state
0C24 B40103     525       cjne a, #1, State_2
0C27 020BD8     526       ljmp Heating_To_Soak
0C2A            527   
0C2A            528   ;-------------------------------------------------- STATE 2 --------------------------------------------------
0C2A            529   ; soak temperature has been reached, temperature is held for [soaktime]
0C2A            530   State_2:
0C2A            531       ; check state
0C2A 3095FD     532       jnb STATE_STABLE, $ ; wait for state to be stable
0C2D 120497     533       lcall read_state
0C30 B4024D     534       cjne a, #2, State_3
0C33            535   
0C33            536       ; [sound saying the current state "Soaking"]
0C33 781F       537       mov r0,#31
0C35 12050A     538       lcall Play_Sound_Using_Index
0C38            539   
0C38            540   Soaking:
0C38            541       ; read temperature every second
0C38 30000B     542       jnb seconds_flag, Soaking_a
0C3B C200       543       clr seconds_flag
0C3D 1203F7     544       lcall Read_ADC
0C40 1204A3     545       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0C43 120396     546       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
0C46            547   Soaking_a:
0C46            548       ; play sound every five seconds
0C46 300102     549       jnb five_seconds_flag, Soaking_b
0C49 C201       550       clr five_seconds_flag
0C4B            551       ;lcall Play_Temp_Sound; [function to play sound here]
0C4B            552   Soaking_b:
0C4B            553       ; compare temperature to soaktemp
0C4B 753300     554            mov x+0, #low (0 % 0x10000) 
0C4E 753400     554            mov x+1, #high(0 % 0x10000) 
0C51 753500     554            mov x+2, #low (0 / 0x10000) 
0C54 753600     554            mov x+3, #high(0 / 0x10000) 
0C57 753700     555            mov y+0, #low (0 % 0x10000) 
0C5A 753800     555            mov y+1, #high(0 % 0x10000) 
0C5D 753900     555            mov y+2, #low (0 / 0x10000) 
0C60 753A00     555            mov y+3, #high(0 / 0x10000) 
0C63 854433     556       mov x+0, temp_reading
0C66 854037     557       mov y+0, soaktemp
0C69 120240     558       lcall x_gteq_y
0C6C            559       ; if temperature >= soaktemp, turn off the oven
0C6C 20020D     560       jb mf, Soaking_too_high
0C6F            561       ; else, turn on the oven
0C6F D296       562       setb OVEN_CTL_PIN
0C71            563   Soaking_d:
0C71            564       ; check state
0C71 3095FD     565       jnb STATE_STABLE, $ ; wait for state to be stable
0C74 120497     566       lcall read_state
0C77 B40206     567       cjne a, #2, State_3
0C7A 80BC       568       sjmp Soaking
0C7C            569   
0C7C            570   Soaking_too_high:
0C7C C296       571       clr OVEN_CTL_PIN ; turn off the oven
0C7E 80F1       572       sjmp Soaking_d
0C80            573   
0C80            574   ;-------------------------------------------------- STATE 3 --------------------------------------------------
0C80            575   ; heating to reflow temperature
0C80            576   State_3:
0C80            577       ; check state
0C80 3095FD     578       jnb STATE_STABLE, $ ; wait for state to be stable
0C83 120497     579       lcall read_state
0C86 B40344     580       cjne a, #3, Jump_State_4
0C89            581   
0C89            582       ; turn on the oven
0C89 D296       583       setb OVEN_CTL_PIN
0C8B            584   
0C8B            585       ; display target temperature
0C8B 753300     586            mov x+0, #low (0 % 0x10000) 
0C8E 753400     586            mov x+1, #high(0 % 0x10000) 
0C91 753500     586            mov x+2, #low (0 / 0x10000) 
0C94 753600     586            mov x+3, #high(0 / 0x10000) 
0C97 854133     587       mov x+0, reflowtemp
0C9A 1200DA     588       lcall hex2bcd
0C9D C0E0       589            push acc
0C9F 7408       589            mov a, #8
0CA1 14         589            dec a
0CA2 1200BD     589            lcall ?Set_Cursor_2 ; Select column and row
0CA5 D0E0       589            pop acc
0CA7 C000       589            push ar0
0CA9 A83C       589            mov r0, bcd+1
0CAB 1200C4     589            lcall ?Display_BCD
0CAE D000       589            pop ar0
0CB0 C000       589            push ar0
0CB2 A83B       589            mov r0, bcd+0
0CB4 1200C4     589            lcall ?Display_BCD
0CB7 D000       589            pop ar0
0CB9            589            ; Replace all the zeros to the left with blanks
0CB9 C0E0       589            push acc
0CBB 7408       589            mov a, #8
0CBD 14         589            dec a
0CBE 1200BD     589            lcall ?Set_Cursor_2 ; Select column and row
0CC1 D0E0       589            pop acc
0CC3 12034A     589            lcall replace_zeros
0CC6            590   
0CC6            591       ; [sound saying the current state "Heating to reflow"]
0CC6 7820       592       mov r0,#32
0CC8 12050A     593       lcall Play_Sound_Using_Index
0CCB 8003       594       sjmp Heating_To_Reflow
0CCD            595   
0CCD            596   Jump_State_4:   ; ljmp to state 4
0CCD 020D14     597       ljmp State_4
0CD0            598   
0CD0            599   Heating_To_Reflow:
0CD0            600       ; read temperature every second
0CD0 30000B     601       jnb seconds_flag, Heating_To_Reflow_a
0CD3 C200       602       clr seconds_flag
0CD5 1203F7     603       lcall Read_ADC
0CD8 1204A3     604       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0CDB 120396     605       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
0CDE            606   Heating_To_Reflow_a:
0CDE            607       ; play sound every five seconds
0CDE 300102     608       jnb five_seconds_flag, Heating_To_Reflow_b
0CE1 C201       609       clr five_seconds_flag
0CE3            610       ;lcall Play_Temp_Sound ; [function to play sound here]
0CE3            611   Heating_To_Reflow_b:
0CE3 753300     612            mov x+0, #low (0 % 0x10000) 
0CE6 753400     612            mov x+1, #high(0 % 0x10000) 
0CE9 753500     612            mov x+2, #low (0 / 0x10000) 
0CEC 753600     612            mov x+3, #high(0 / 0x10000) 
0CEF 753700     613            mov y+0, #low (0 % 0x10000) 
0CF2 753800     613            mov y+1, #high(0 % 0x10000) 
0CF5 753900     613            mov y+2, #low (0 / 0x10000) 
0CF8 753A00     613            mov y+3, #high(0 / 0x10000) 
0CFB 854433     614       mov x+0, temp_reading
0CFE 854137     615       mov y+0, reflowtemp
0D01 120240     616       lcall x_gteq_y
0D04 300202     617       jnb mf, Heating_To_Reflow_c
0D07 D290       618       setb TEMP_OK
0D09            619   Heating_To_Reflow_c:
0D09            620       ; check state
0D09 3095FD     621       jnb STATE_STABLE, $ ; wait for state to be stable
0D0C 120497     622       lcall read_state
0D0F B40302     623       cjne a, #3, State_4
0D12 80BC       624       sjmp Heating_To_Reflow
0D14            625   
0D14            626   ;-------------------------------------------------- STATE 4 --------------------------------------------------
0D14            627   ; reflow temperature has been reached, temperature is held for [reflowtime]
0D14            628   State_4:
0D14            629       ; check state
0D14 3095FD     630       jnb STATE_STABLE, $ ; wait for state to be stable
0D17 120497     631       lcall read_state
0D1A B40450     632       cjne a, #4, State_5
0D1D            633   
0D1D            634       ;[Sound saying the current state "Reflowing"]
0D1D 7821       635       mov r0, #33
0D1F 02050A     636       ljmp Play_Sound_Using_Index 
0D22            637   
0D22            638   Reflowing:
0D22            639       ; read temperature every second
0D22 30000B     640       jnb seconds_flag, Reflowing_a
0D25 C200       641       clr seconds_flag
0D27 1203F7     642       lcall Read_ADC
0D2A 1204A3     643       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0D2D 120396     644       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
0D30            645   Reflowing_a:
0D30            646       ; play sound every five seconds
0D30 300102     647       jnb five_seconds_flag, Reflowing_b
0D33 C201       648       clr five_seconds_flag
0D35            649       ;lcall Play_Temp_Sound ; [function to play sound here]
0D35            650   Reflowing_b:
0D35 753300     651            mov x+0, #low (0 % 0x10000) 
0D38 753400     651            mov x+1, #high(0 % 0x10000) 
0D3B 753500     651            mov x+2, #low (0 / 0x10000) 
0D3E 753600     651            mov x+3, #high(0 / 0x10000) 
0D41 753700     652            mov y+0, #low (0 % 0x10000) 
0D44 753800     652            mov y+1, #high(0 % 0x10000) 
0D47 753900     652            mov y+2, #low (0 / 0x10000) 
0D4A 753A00     652            mov y+3, #high(0 / 0x10000) 
0D4D 854433     653       mov x+0, temp_reading
0D50 854137     654       mov y+0, reflowtemp
0D53 120240     655       lcall x_gteq_y
0D56 200210     656       jb mf, Reflowing_too_high
0D59            657       ; if temperature >= soaktemp, turn off the oven
0D59 20020D     658       jb mf, Reflowing_too_high
0D5C            659       ; else, turn on the oven
0D5C D296       660       setb OVEN_CTL_PIN
0D5E            661   Reflowing_d:
0D5E            662       ; check state
0D5E 3095FD     663       jnb STATE_STABLE, $ ; wait for state to be stable
0D61 120497     664       lcall read_state
0D64 B40406     665       cjne a, #4, State_5
0D67 80B9       666       sjmp Reflowing
0D69            667   
0D69            668   Reflowing_too_high:
0D69 C296       669       clr OVEN_CTL_PIN ; turn off the oven
0D6B 80F1       670       sjmp Reflowing_d
0D6D            671   
0D6D            672   ;------------------------------------------------- STATE 5/6 -------------------------------------------------
0D6D            673   ; cooldown/error
0D6D            674   State_5:
0D6D            675       ; check state
0D6D 3095FD     676       jnb STATE_STABLE, $ ; wait for state to be stable
0D70 120497     677       lcall read_state
0D73 B40525     678       cjne a, #5, State_6
0D76            679   
0D76            680       ; turn off the oven
0D76 C296       681       clr OVEN_CTL_PIN
0D78            682   
0D78            683       ; display "OVEN OFF" message
0D78 C0E0       684            push acc
0D7A 7401       684            mov a, #1
0D7C 14         684            dec a
0D7D 1200BD     684            lcall ?Set_Cursor_2 ; Select column and row
0D80 D0E0       684            pop acc
0D82 C083       685            push dph
0D84 C082       685            push dpl
0D86 C0E0       685            push acc
0D88 9008FB     685            mov dptr, #OVEN_OFF
0D8B 1200B2     685            lcall ?Send_Constant_String
0D8E D0E0       685            pop acc
0D90 D082       685            pop dpl
0D92 D083       685            pop dph
0D94            686   
0D94 7822       687       mov r0, #34 ; moves the index for cooling into r0
0D96 12050A     688       lcall Play_Sound_Using_Index; [Sound saying current state "Cooldown"]
0D99 8031       689       sjmp Cooldown
0D9B            690   
0D9B            691   State_6:
0D9B            692       ; check state
0D9B 3095FD     693       jnb STATE_STABLE, $ ; wait for state to be stable
0D9E 120497     694       lcall read_state
0DA1 B40625     695       cjne a, #6, Jump_State_0
0DA4            696   
0DA4            697       ; turn off the oven
0DA4 C296       698       clr OVEN_CTL_PIN
0DA6            699   
0DA6            700       ; display "OVEN OFF" message
0DA6 C0E0       701            push acc
0DA8 7401       701            mov a, #1
0DAA 14         701            dec a
0DAB 1200BD     701            lcall ?Set_Cursor_2 ; Select column and row
0DAE D0E0       701            pop acc
0DB0 C083       702            push dph
0DB2 C082       702            push dpl
0DB4 C0E0       702            push acc
0DB6 9008FB     702            mov dptr, #OVEN_OFF
0DB9 1200B2     702            lcall ?Send_Constant_String
0DBC D0E0       702            pop acc
0DBE D082       702            pop dpl
0DC0 D083       702            pop dph
0DC2            703   
0DC2            704   
0DC2 7823       705       mov r0, #35 ; moves the index for error into r0
0DC4 12050A     706       lcall Play_Sound_Using_Index; [Sound saying current state "Error"]
0DC7 8003       707       sjmp Cooldown
0DC9            708   
0DC9            709   Jump_State_0:
0DC9 020B12     710       ljmp State_0
0DCC            711   
0DCC            712   Cooldown:
0DCC            713       ; read temperature every second
0DCC 30000B     714       jnb seconds_flag, Cooldown_a
0DCF C200       715       clr seconds_flag
0DD1 1203F7     716       lcall Read_ADC
0DD4 1204A3     717       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0DD7 120396     718       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
0DDA            719   Cooldown_a:
0DDA            720       ; play sound every five seconds
0DDA 300102     721       jnb five_seconds_flag, Cooldown_b
0DDD C201       722       clr five_seconds_flag
0DDF            723       ;lcall Play_Temp_Sound ; [function to play sound here] NOT FUNCTIONAL
0DDF            724   Cooldown_b:
0DDF 753300     725            mov x+0, #low (0 % 0x10000) 
0DE2 753400     725            mov x+1, #high(0 % 0x10000) 
0DE5 753500     725            mov x+2, #low (0 / 0x10000) 
0DE8 753600     725            mov x+3, #high(0 / 0x10000) 
0DEB 753732     726            mov y+0, #low (50 % 0x10000) 
0DEE 753800     726            mov y+1, #high(50 % 0x10000) 
0DF1 753900     726            mov y+2, #low (50 / 0x10000) 
0DF4 753A00     726            mov y+3, #high(50 / 0x10000) 
0DF7 854433     727       mov x+0, temp_reading
0DFA 120240     728       lcall x_gteq_y
0DFD 200202     729       jb mf, Cooldown_c
0E00 C291       730       clr TEMP_50
0E02            731   Cooldown_c:
0E02            732       ; if temperature >= 50, TEMP_50 = 1
0E02            733       ; else, TEMP_50 = 0
0E02 1204E3     734       lcall Check_50
0E05            735       ; check state
0E05 3095FD     736       jnb STATE_STABLE, $ ; wait for state to be stable
0E08 120497     737       lcall read_state
0E0B B40502     738       cjne a, #5, Cooldown_d
0E0E 80BC       739       sjmp Cooldown
0E10            740   Cooldown_d:
0E10 B406B6     741       cjne a, #6, Jump_State_0
0E13 80B7       742       sjmp Cooldown
0E15            743   
0E15            744   ;-------------------------------------------------- SETUP ----------------------------------------------------
0E15            745   setup:
0E15            746       ; temperature not set, TEMP_OK = 0
0E15 C290       747       clr TEMP_OK
0E17            748       ; prints "SOAK" left aligned in the top row
0E17 C0E0       749            push acc
0E19 7401       749            mov a, #1
0E1B 14         749            dec a
0E1C 1200BF     749            lcall ?Set_Cursor_1 ; Select column and row
0E1F D0E0       749            pop acc
0E21 C083       750            push dph
0E23 C082       750            push dpl
0E25 C0E0       750            push acc
0E27 9008B7     750            mov dptr, #SOAK_TEMP
0E2A 1200B2     750            lcall ?Send_Constant_String
0E2D D0E0       750            pop acc
0E2F D082       750            pop dpl
0E31 D083       750            pop dph
0E33            751       ; prints "REFLOW" left aligned in the bottom row
0E33 C0E0       752            push acc
0E35 7401       752            mov a, #1
0E37 14         752            dec a
0E38 1200BD     752            lcall ?Set_Cursor_2 ; Select column and row
0E3B D0E0       752            pop acc
0E3D C083       753            push dph
0E3F C082       753            push dpl
0E41 C0E0       753            push acc
0E43 9008C8     753            mov dptr, #REFLOW_TEMP
0E46 1200B2     753            lcall ?Send_Constant_String
0E49 D0E0       753            pop acc
0E4B D082       753            pop dpl
0E4D D083       753            pop dph
0E4F            754       ; display soak temperature
0E4F 753300     755            mov x+0, #low (0 % 0x10000) 
0E52 753400     755            mov x+1, #high(0 % 0x10000) 
0E55 753500     755            mov x+2, #low (0 / 0x10000) 
0E58 753600     755            mov x+3, #high(0 / 0x10000) 
0E5B 854033     756       mov x+0, soaktemp
0E5E 1200DA     757       lcall hex2bcd
0E61 C0E0       758            push acc
0E63 7408       758            mov a, #8
0E65 14         758            dec a
0E66 1200BF     758            lcall ?Set_Cursor_1 ; Select column and row
0E69 D0E0       758            pop acc
0E6B C000       758            push ar0
0E6D A83C       758            mov r0, bcd+1
0E6F 1200C4     758            lcall ?Display_BCD
0E72 D000       758            pop ar0
0E74 C000       758            push ar0
0E76 A83B       758            mov r0, bcd+0
0E78 1200C4     758            lcall ?Display_BCD
0E7B D000       758            pop ar0
0E7D            758            ; Replace all the zeros to the left with blanks
0E7D C0E0       758            push acc
0E7F 7408       758            mov a, #8
0E81 14         758            dec a
0E82 1200BF     758            lcall ?Set_Cursor_1 ; Select column and row
0E85 D0E0       758            pop acc
0E87 12034A     758            lcall replace_zeros
0E8A            759       ; display reflow temperature
0E8A 854133     760       mov x+0, reflowtemp+0
0E8D 1200DA     761       lcall hex2bcd
0E90 C0E0       762            push acc
0E92 7408       762            mov a, #8
0E94 14         762            dec a
0E95 1200BD     762            lcall ?Set_Cursor_2 ; Select column and row
0E98 D0E0       762            pop acc
0E9A C000       762            push ar0
0E9C A83C       762            mov r0, bcd+1
0E9E 1200C4     762            lcall ?Display_BCD
0EA1 D000       762            pop ar0
0EA3 C000       762            push ar0
0EA5 A83B       762            mov r0, bcd+0
0EA7 1200C4     762            lcall ?Display_BCD
0EAA D000       762            pop ar0
0EAC            762            ; Replace all the zeros to the left with blanks
0EAC C0E0       762            push acc
0EAE 7408       762            mov a, #8
0EB0 14         762            dec a
0EB1 1200BD     762            lcall ?Set_Cursor_2 ; Select column and row
0EB4 D0E0       762            pop acc
0EB6 12034A     762            lcall replace_zeros
0EB9            763   
0EB9            764   ; set soak temperature
0EB9            765   ; MAX: 240
0EB9            766   ; MIN: 120
0EB9            767   set_soak_temp:
0EB9 854033     768       mov x+0, soaktemp
0EBC C0E0       769            push acc
0EBE 740B       769            mov a, #11
0EC0 14         769            dec a
0EC1 1200BF     769            lcall ?Set_Cursor_1 ; Select column and row
0EC4 D0E0       769            pop acc
0EC6 C0E0       770            push acc
0EC8 740E       770            mov a, #0xE
0ECA 120083     770            lcall ?WriteCommand
0ECD D0E0       770            pop acc
0ECF            771       ; if BOOT_BUTTON is being pressed, wait for release
0ECF 30C5FD     772       jnb BOOT_BUTTON, $
0ED2            773   set_soak_temp_a:
0ED2            774       ; if UP is pressed, increment temperature
0ED2 208705     775       jb UP, set_soak_temp_b
0ED5 E533       776       mov a, x+0
0ED7            777       ; if temperature < 240, increment temperature
0ED7 B4F032     778       cjne a, #0xF0, set_soak_temp_d
0EDA            779   set_soak_temp_b:
0EDA            780       ; if DOWN button is pressed, increment temperature  
0EDA 208505     781       jb DOWN, set_soak_temp_c
0EDD E533       782       mov a, x+0
0EDF            783       ; if temperature > 120, decrement temperature
0EDF B4783A     784       cjne a, #0x78, set_soak_temp_e
0EE2            785   set_soak_temp_c:  
0EE2 C203       786       clr hold_button
0EE4 C0E0       787            push acc
0EE6 740B       787            mov a, #11
0EE8 14         787            dec a
0EE9 1200BF     787            lcall ?Set_Cursor_1 ; Select column and row
0EEC D0E0       787            pop acc
0EEE C0E0       788            push acc
0EF0 740E       788            mov a, #0xE
0EF2 120083     788            lcall ?WriteCommand
0EF5 D0E0       788            pop acc
0EF7            789       ; if BOOT_BUTTON is pressed, set reflow time
0EF7 20C5D8     790       jb BOOT_BUTTON, set_soak_temp_a
0EFA C002       791            push AR2
0EFC 7A32       791            mov R2, #50
0EFE 120039     791            lcall ?Wait_Milli_Seconds
0F01 D002       791            pop AR2 ; debounce time
0F03 20C5CC     792       jb BOOT_BUTTON, set_soak_temp_a
0F06 853340     793       mov soaktemp, x+0
0F09 020FC4     794       ljmp set_reflow_temp
0F0C            795   set_soak_temp_d:
0F0C            796       ; increment soak temperature
0F0C C0E0       797            push acc
0F0E 740C       797            mov a, #0xC
0F10 120083     797            lcall ?WriteCommand
0F13 D0E0       797            pop acc
0F15 0533       798       inc x+0
0F17            799       ; if UP is held, increment temperature rapidly
0F17 200312     800       jb hold_button, set_soak_temp_f
0F1A 804D       801       sjmp set_soak_temp_g
0F1C            802   set_soak_temp_e:
0F1C            803       ; decrement soak temperature
0F1C C0E0       804            push acc
0F1E 740C       804            mov a, #0xC
0F20 120083     804            lcall ?WriteCommand
0F23 D0E0       804            pop acc
0F25 1533       805       dec x+0
0F27            806       ; if DOWN button is held, decrement temperature rapidly
0F27 200302     807       jb hold_button, set_soak_temp_f
0F2A 803D       808       sjmp set_soak_temp_g
0F2C            809   set_soak_temp_f:
0F2C            810       ; update display and wait 25 ms
0F2C 1200DA     811       lcall hex2bcd
0F2F C0E0       812            push acc
0F31 7408       812            mov a, #8
0F33 14         812            dec a
0F34 1200BF     812            lcall ?Set_Cursor_1 ; Select column and row
0F37 D0E0       812            pop acc
0F39 C000       812            push ar0
0F3B A83C       812            mov r0, bcd+1
0F3D 1200C4     812            lcall ?Display_BCD
0F40 D000       812            pop ar0
0F42 C000       812            push ar0
0F44 A83B       812            mov r0, bcd+0
0F46 1200C4     812            lcall ?Display_BCD
0F49 D000       812            pop ar0
0F4B            812            ; Replace all the zeros to the left with blanks
0F4B C0E0       812            push acc
0F4D 7408       812            mov a, #8
0F4F 14         812            dec a
0F50 1200BF     812            lcall ?Set_Cursor_1 ; Select column and row
0F53 D0E0       812            pop acc
0F55 12034A     812            lcall replace_zeros
0F58 C002       813            push AR2
0F5A 7A19       813            mov R2, #25
0F5C 120039     813            lcall ?Wait_Milli_Seconds
0F5F D002       813            pop AR2
0F61            814       ; if UP is held, increment temperature
0F61 308756     815       jnb UP, set_soak_temp_h
0F64            816       ; if DOWN button is held, decrement temperature
0F64 308558     817       jnb DOWN, set_soak_temp_i
0F67 C203       818       clr hold_button
0F69            819   set_soak_temp_g:
0F69            820       ; update display and wait 250 ms
0F69 1200DA     821       lcall hex2bcd
0F6C C0E0       822            push acc
0F6E 7408       822            mov a, #8
0F70 14         822            dec a
0F71 1200BF     822            lcall ?Set_Cursor_1 ; Select column and row
0F74 D0E0       822            pop acc
0F76 C000       822            push ar0
0F78 A83C       822            mov r0, bcd+1
0F7A 1200C4     822            lcall ?Display_BCD
0F7D D000       822            pop ar0
0F7F C000       822            push ar0
0F81 A83B       822            mov r0, bcd+0
0F83 1200C4     822            lcall ?Display_BCD
0F86 D000       822            pop ar0
0F88            822            ; Replace all the zeros to the left with blanks
0F88 C0E0       822            push acc
0F8A 7408       822            mov a, #8
0F8C 14         822            dec a
0F8D 1200BF     822            lcall ?Set_Cursor_1 ; Select column and row
0F90 D0E0       822            pop acc
0F92 12034A     822            lcall replace_zeros
0F95 C0E0       823            push acc
0F97 740B       823            mov a, #11
0F99 14         823            dec a
0F9A 1200BF     823            lcall ?Set_Cursor_1 ; Select column and row
0F9D D0E0       823            pop acc
0F9F C0E0       824            push acc
0FA1 740E       824            mov a, #0xE
0FA3 120083     824            lcall ?WriteCommand
0FA6 D0E0       824            pop acc
0FA8 C002       825            push AR2
0FAA 7AFA       825            mov R2, #250
0FAC 120039     825            lcall ?Wait_Milli_Seconds
0FAF D002       825            pop AR2
0FB1            826       ; if UP is held, set a flag so the program knows
0FB1 308706     827       jnb UP, set_soak_temp_h
0FB4            828       ; if DOWN button is held, set a flag so the program knows 
0FB4 308508     829       jnb DOWN, set_soak_temp_i
0FB7 020ED2     830       ljmp set_soak_temp_a
0FBA            831   set_soak_temp_h:
0FBA D203       832       setb hold_button
0FBC 020ED2     833       ljmp set_soak_temp_a
0FBF            834   set_soak_temp_i:
0FBF D203       835       setb hold_button
0FC1 020EDA     836       ljmp set_soak_temp_b
0FC4            837   
0FC4            838   ; set reflow temp
0FC4            839   ; MAX: 240
0FC4            840   ; MIN: 120
0FC4            841   set_reflow_temp:
0FC4 854133     842       mov x+0, reflowtemp
0FC7 C0E0       843            push acc
0FC9 740B       843            mov a, #11
0FCB 14         843            dec a
0FCC 1200BD     843            lcall ?Set_Cursor_2 ; Select column and row
0FCF D0E0       843            pop acc
0FD1 C0E0       844            push acc
0FD3 740E       844            mov a, #0xE
0FD5 120083     844            lcall ?WriteCommand
0FD8 D0E0       844            pop acc
0FDA            845       ; if BOOT_BUTTON is being pressed, wait for release
0FDA 30C5FD     846       jnb BOOT_BUTTON, $
0FDD            847   set_reflow_temp_a:
0FDD            848       ; if UP is pressed, increment temperature
0FDD 208705     849       jb UP, set_reflow_temp_b
0FE0 E533       850       mov a, x+0
0FE2            851       ; if temperature < 240, increment temperature
0FE2 B4F032     852       cjne a, #0xF0, set_reflow_temp_d
0FE5            853   set_reflow_temp_b:
0FE5            854       ; if DOWN button is pressed, increment temperature  
0FE5 208505     855       jb DOWN, set_reflow_temp_c
0FE8 E533       856       mov a, x+0
0FEA            857       ; if temperature > 0, decrement temperature
0FEA B4783A     858       cjne a, #0x78, set_reflow_temp_e
0FED            859   set_reflow_temp_c:  
0FED C203       860       clr hold_button
0FEF C0E0       861            push acc
0FF1 740B       861            mov a, #11
0FF3 14         861            dec a
0FF4 1200BD     861            lcall ?Set_Cursor_2 ; Select column and row
0FF7 D0E0       861            pop acc
0FF9 C0E0       862            push acc
0FFB 740E       862            mov a, #0xE
0FFD 120083     862            lcall ?WriteCommand
1000 D0E0       862            pop acc
1002            863       ; if BOOT_BUTTON is pressed, set reflow time
1002 20C5D8     864       jb BOOT_BUTTON, set_reflow_temp_a
1005 C002       865            push AR2
1007 7A32       865            mov R2, #50
1009 120039     865            lcall ?Wait_Milli_Seconds
100C D002       865            pop AR2 ; debounce time
100E 20C5CC     866       jb BOOT_BUTTON, set_reflow_temp_a
1011 853341     867       mov reflowtemp, x+0
1014 0210CF     868       ljmp setup_done
1017            869   set_reflow_temp_d:
1017            870       ; increment reflow temperature
1017 C0E0       871            push acc
1019 740C       871            mov a, #0xC
101B 120083     871            lcall ?WriteCommand
101E D0E0       871            pop acc
1020 0533       872       inc x+0
1022            873       ; if UP is held, increment temperature rapidly
1022 200312     874       jb hold_button, set_reflow_temp_f
1025 804D       875       sjmp set_reflow_temp_g
1027            876   set_reflow_temp_e:
1027            877       ; decrement reflow temperature
1027 C0E0       878            push acc
1029 740C       878            mov a, #0xC
102B 120083     878            lcall ?WriteCommand
102E D0E0       878            pop acc
1030 1533       879       dec x+0
1032            880       ; if DOWN button is held, decrement temperature rapidly
1032 200302     881       jb hold_button, set_reflow_temp_f
1035 803D       882       sjmp set_reflow_temp_g
1037            883   set_reflow_temp_f:
1037            884       ; update display and wait 25 ms
1037 1200DA     885       lcall hex2bcd
103A C0E0       886            push acc
103C 7408       886            mov a, #8
103E 14         886            dec a
103F 1200BD     886            lcall ?Set_Cursor_2 ; Select column and row
1042 D0E0       886            pop acc
1044 C000       886            push ar0
1046 A83C       886            mov r0, bcd+1
1048 1200C4     886            lcall ?Display_BCD
104B D000       886            pop ar0
104D C000       886            push ar0
104F A83B       886            mov r0, bcd+0
1051 1200C4     886            lcall ?Display_BCD
1054 D000       886            pop ar0
1056            886            ; Replace all the zeros to the left with blanks
1056 C0E0       886            push acc
1058 7408       886            mov a, #8
105A 14         886            dec a
105B 1200BD     886            lcall ?Set_Cursor_2 ; Select column and row
105E D0E0       886            pop acc
1060 12034A     886            lcall replace_zeros
1063 C002       887            push AR2
1065 7A19       887            mov R2, #25
1067 120039     887            lcall ?Wait_Milli_Seconds
106A D002       887            pop AR2
106C            888       ; if UP is held, increment temperature
106C 308756     889       jnb UP, set_reflow_temp_h
106F            890       ; if DOWN button is held, decrement temperature
106F 308558     891       jnb DOWN, set_reflow_temp_i
1072 C203       892       clr hold_button
1074            893   set_reflow_temp_g:
1074            894       ; update display and wait 250 ms
1074 1200DA     895       lcall hex2bcd
1077 C0E0       896            push acc
1079 7408       896            mov a, #8
107B 14         896            dec a
107C 1200BD     896            lcall ?Set_Cursor_2 ; Select column and row
107F D0E0       896            pop acc
1081 C000       896            push ar0
1083 A83C       896            mov r0, bcd+1
1085 1200C4     896            lcall ?Display_BCD
1088 D000       896            pop ar0
108A C000       896            push ar0
108C A83B       896            mov r0, bcd+0
108E 1200C4     896            lcall ?Display_BCD
1091 D000       896            pop ar0
1093            896            ; Replace all the zeros to the left with blanks
1093 C0E0       896            push acc
1095 7408       896            mov a, #8
1097 14         896            dec a
1098 1200BD     896            lcall ?Set_Cursor_2 ; Select column and row
109B D0E0       896            pop acc
109D 12034A     896            lcall replace_zeros
10A0 C0E0       897            push acc
10A2 740B       897            mov a, #11
10A4 14         897            dec a
10A5 1200BD     897            lcall ?Set_Cursor_2 ; Select column and row
10A8 D0E0       897            pop acc
10AA C0E0       898            push acc
10AC 740E       898            mov a, #0xE
10AE 120083     898            lcall ?WriteCommand
10B1 D0E0       898            pop acc
10B3 C002       899            push AR2
10B5 7AFA       899            mov R2, #250
10B7 120039     899            lcall ?Wait_Milli_Seconds
10BA D002       899            pop AR2
10BC            900       ; if UP is held, set a flag so the program knows
10BC 308706     901       jnb UP, set_reflow_temp_h
10BF            902       ; if DOWN button is held, set a flag so the program knows 
10BF 308508     903       jnb DOWN, set_reflow_temp_i
10C2 020FDD     904       ljmp set_reflow_temp_a
10C5            905   set_reflow_temp_h:
10C5 D203       906       setb hold_button
10C7 020FDD     907       ljmp set_reflow_temp_a
10CA            908   set_reflow_temp_i:
10CA D203       909       setb hold_button
10CC 020FE5     910       ljmp set_reflow_temp_b
10CF            911   
10CF            912   setup_done:
10CF C0E0       913            push acc
10D1 740C       913            mov a, #0xC
10D3 120083     913            lcall ?WriteCommand
10D6 D0E0       913            pop acc
10D8            914       ; display current temperature
10D8 C0E0       915            push acc
10DA 7401       915            mov a, #1
10DC 14         915            dec a
10DD 1200BF     915            lcall ?Set_Cursor_1 ; Select column and row
10E0 D0E0       915            pop acc
10E2 C083       916            push dph
10E4 C082       916            push dpl
10E6 C0E0       916            push acc
10E8 9008D9     916            mov dptr, #CURRENT_TEMP
10EB 1200B2     916            lcall ?Send_Constant_String
10EE D0E0       916            pop acc
10F0 D082       916            pop dpl
10F2 D083       916            pop dph
10F4 1203F7     917       lcall Read_ADC
10F7 C0E0       918            push acc
10F9 7408       918            mov a, #8
10FB 14         918            dec a
10FC 1200BF     918            lcall ?Set_Cursor_1 ; Select column and row
10FF D0E0       918            pop acc
1101 C000       918            push ar0
1103 A83C       918            mov r0, bcd+1
1105 1200C4     918            lcall ?Display_BCD
1108 D000       918            pop ar0
110A C000       918            push ar0
110C A83B       918            mov r0, bcd+0
110E 1200C4     918            lcall ?Display_BCD
1111 D000       918            pop ar0
1113            918            ; Replace all the zeros to the left with blanks
1113 C0E0       918            push acc
1115 7408       918            mov a, #8
1117 14         918            dec a
1118 1200BF     918            lcall ?Set_Cursor_1 ; Select column and row
111B D0E0       918            pop acc
111D 12034A     918            lcall replace_zeros
1120 020B12     919       ljmp State_0
