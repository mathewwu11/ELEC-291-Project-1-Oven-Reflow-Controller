                  2   $LIST
0000              4   
0000              5   CLK  EQU 22118400
0000              6   BAUD equ 115200
0000              7   BRG_VAL equ (0x100-(CLK/(16*BAUD)))
0000              8   
0000              9   TIMER1_RATE    EQU 22050     ; 22050Hz is the sampling rate of the wav file we are playing
0000             10   TIMER1_RELOAD  EQU 0x10000-(CLK/TIMER1_RATE)
0000             11   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             12   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             13   
0000             14   ; The pins used for SPI
0000             15   FLASH_CE  EQU  P2.5
0000             16   PIN_TWO_FOUR   EQU  P2.4 
0000             17   PIN_TWO_ONE   EQU  P2.1
0000             18   PIN_TWO_ZERO   EQU  P2.0 
0000             19   
0000             20   BOOT_BUTTON   equ P4.5
0000             21   SPEAKER  EQU P2.6 ; Used with a MOSFET to turn off speaker when not in use
0000             22   UP            equ P0.7
0000             23   DOWN               equ P0.5
0000             24   ; Input 3 bit binary state from TIME/FSM MCU
0000             25   STATE_bit0      equ P1.2
0000             26   STATE_bit1      equ P1.3
0000             27   STATE_bit2      equ P1.4
0000             28   STATE_STABLE    equ P1.5
0000             29   ; Outputs to Time/FSM MCU
0000             30   TEMP_OK        equ P1.0
0000             31   TEMP_50        equ P1.1
0000             32   OVEN_CTL_PIN   equ P1.6
0000             33   
0000             34    ; Commands supported by the SPI flash memory according to the datasheet
0000             35   WRITE_ENABLE     EQU 0x06  ; Address:0 Dummy:0 Num:0
0000             36   WRITE_DISABLE    EQU 0x04  ; Address:0 Dummy:0 Num:0
0000             37   READ_STATUS      EQU 0x05  ; Address:0 Dummy:0 Num:1 to infinite
0000             38   READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
0000             39   READ_SILICON_ID  EQU 0xab  ; Address:0 Dummy:3 Num:1 to infinite
0000             40   FAST_READ        EQU 0x0b  ; Address:3 Dummy:1 Num:1 to infinite
0000             41   WRITE_STATUS     EQU 0x01  ; Address:0 Dummy:0 Num:1
0000             42   WRITE_BYTES      EQU 0x02  ; Address:3 Dummy:0 Num:1 to 256
0000             43   ERASE_ALL        EQU 0xc7  ; Address:0 Dummy:0 Num:0
0000             44   ERASE_BLOCK      EQU 0xd8  ; Address:3 Dummy:0 Num:0
0000             45   READ_DEVICE_ID   EQU 0x9f  ; Address:0 Dummy:2 Num:1 to infinite
0000             46   
0000             47   org 0000H
0000 020AC7      48      ljmp MainProgram
0003             49   
0003             50   ; External interrupt 0 vector (not used in this code)
0003             51   org 0x0003
0003 32          52            reti
0004             53   
0004             54   ; Timer/Counter 0 overflow interrupt vector (not used in this code)
000B             55   org 0x000B
000B 32          56            reti
000C             57   
000C             58   ; External interrupt 1 vector (not used in this code)
0013             59   org 0x0013
0013 32          60            reti
0014             61   
0014             62   ; Timer/Counter 1 overflow interrupt vector
001B             63   org 0x001B
001B 020A5A      64            ljmp Timer1_ISR
001E             65   
001E             66   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             67   org 0x0023 
0023 32          68            reti
0024             69            
0024             70   ; Timer/Counter 2 overflow interrupt vector
002B             71   org 0x002B
002B 020A97      72            ljmp Timer2_ISR
002E             73   
0030             74   DSEG at 30H
0030             75   Count1ms:           ds 2
0032             76   Count5s:            ds 1 
0033             77   x:                  ds 4 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file
0037             78   y:                  ds 4 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file
003B             79   bcd:                ds 5 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file 
0040             80   soaktemp:           ds 1
0041             81   reflowtemp:         ds 1
0042             82   volt_reading:       ds 2 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file
0044             83   temp_reading:       ds 1
0045             84   w:                               ds 3 ; 24-bit play counter.  Decremented in Timer 1 ISR.
0048             85   
0000             86   BSEG
0000             87   seconds_flag:       dbit 1
0001             88   five_seconds_flag:  dbit 1
0002             89   mf:                 dbit 1 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file
0003             90   hold_button:        dbit 1
0004             91   play_done:          dbit 1
0005             92   
002E             93   CSEG
002E             94   ; These ’EQU’ must match the wiring between the microcontroller and ADC (used in the INC file)
002E             95   CE_ADC  EQU P0.4
002E             96   MY_MOSI EQU P0.3
002E             97   MY_MISO EQU P0.2
002E             98   MY_SCLK EQU P0.1
002E             99   ; These 'equ' must match the hardware wiring
002E            100   ; They are used by 'LCD_4bit.inc'
002E            101   LCD_RS equ P3.2
002E            102   ; LCD_RW equ Px.x ; Always grounded
002E            103   LCD_E  equ P3.3
002E            104   LCD_D4 equ P3.4
002E            105   LCD_D5 equ P3.5
002E            106   LCD_D6 equ P3.6
002E            107   LCD_D7 equ P3.7
002E            108   
                553   $LIST
                113      $LIST
08B7            115   
08B7            116   ;                   1234567890123456
08B7 536F616B   117   SOAK_TEMP:      db 'Soak:   xxx', 0xDF, 'C   ', 0
     3A202020
     787878DF
     43202020
     00
08C8 5265666C   118   REFLOW_TEMP:    db 'Reflow: xxx', 0xDF, 'C   ', 0
     6F773A20
     787878DF
     43202020
     00
08D9 54656D70   119   CURRENT_TEMP:   db 'Temp:   xxx', 0xDF, 'C   ', 0
     3A202020
     787878DF
     43202020
     00
08EA 54617267   120   TARGET_TEMP:    db 'Target: xxx', 0xDF, 'C   ', 0
     65743A20
     787878DF
     43202020
     00
08FB 4F56454E   121   OVEN_OFF:       db 'OVEN OFF        ', 0
     204F4646
     20202020
     20202020
     00
090C            122   
090C            123   
090C            124   ; Approximate index of sounds in file 'nsound.wav'
090C            125   sound_index:       ; index | number
090C 003937     126       db 0x00, 0x39, 0x37 ; 0 1
090F 00E45D     127       db 0x00, 0xe4, 0x5d ; 1 2
0912 019444     128       db 0x01, 0x94, 0x44 ; 2 3
0915 024B4A     129       db 0x02, 0x4b, 0x4a ; 3 4
0918 02F671     130       db 0x02, 0xf6, 0x71 ; 4 5
091B 039CD6     131       db 0x03, 0x9c, 0xd6 ; 5 6
091E 04433C     132       db 0x04, 0x43, 0x3c ; 6 7
0921 04FCA1     133       db 0x04, 0xfc, 0xa1 ; 7 8
0924 05A7C8     134       db 0x05, 0xa7, 0xc8 ; 8 9
0927 066132     135       db 0x06, 0x61, 0x32 ; 9 10
092A 0702D5     136       db 0x07, 0x02, 0xd5 ; 10 11
092D 07ADF9     137       db 0x07, 0xad, 0xf9 ; 11 12
0930 085DE1     138       db 0x08, 0x5d, 0xe1 ; 12 13
0933 09174A     139       db 0x09, 0x17, 0x4a ; 13 14
0936 09B68A     140       db 0x09, 0xb6, 0x8a ; 14 15
0939 0A5F50     141       db 0x0a, 0x5f, 0x50 ; 15 16
093C 0B0CD6     142       db 0x0b, 0x0c, 0xd6 ; 16 17
093F 0BBA5C     143       db 0x0b, 0xba, 0x5c ; 17 18
0942 0C6CA5     144       db 0x0c, 0x6c, 0xa5 ; 18 19
0945 0CFDA3     145       db 0x0c, 0xfd, 0xa3 ; 19 20
0948 0DBBCC     146       db 0x0d, 0xbb, 0xcc ; 20 30
094B 0E6953     147       db 0x0e, 0x69, 0x53 ; 21 40
094E 0F03D2     148       db 0x0f, 0x03, 0xd2 ; 22 50
0951 0FC1FB     149       db 0x0f, 0xc1, 0xfb ; 23 60
0954 106AC2     150       db 0x10, 0x6a, 0xc2 ; 24 70
0957 1115E8     151       db 0x11, 0x15, 0xe8 ; 25 80
095A 11CA8E     152       db 0x11, 0xca, 0x8e ; 26 90
095D 127812     153       db 0x12, 0x78, 0x12 ; 27 100
0960 1327FB     154       db 0x13, 0x27, 0xfb ; 28 200
0963 13D0C0     155       db 0x13, 0xd0, 0xc0 ; 29 idle
0966 147725     156       db 0x14, 0x77, 0x25 ; 30 heating to soak
0969 153551     157       db 0x15, 0x35, 0x51 ; 31 soaking
096C 15CD72     158       db 0x15, 0xcd, 0x72 ; 32 heating to reflow
096F 168B8B     159       db 0x16, 0x8b, 0x8b ; 33 reflowing
0972 172ADE     160       db 0x17, 0x2a, 0xde ; 34 cooling 
0975 17D605     161       db 0x17, 0xd6, 0x05 ; 35 error
0978 187ECC     162       db 0x18, 0x7e, 0xcc 
097B            163   
097B            164   ; Size of each sound in 'sound_index'
097B            165   Size_sound:
097B 00AB26     166       db 0x00, 0xab, 0x26 ; 0 
097E 00AFE7     167       db 0x00, 0xaf, 0xe7 ; 1 
0981 00B706     168       db 0x00, 0xb7, 0x06 ; 2 
0984 00AB27     169       db 0x00, 0xab, 0x27 ; 3 
0987 00A665     170       db 0x00, 0xa6, 0x65 ; 4 
098A 00A666     171       db 0x00, 0xa6, 0x66 ; 5 
098D 00B965     172       db 0x00, 0xb9, 0x65 ; 6 
0990 00AB27     173       db 0x00, 0xab, 0x27 ; 7 
0993 00B96A     174       db 0x00, 0xb9, 0x6a ; 8 
0996 00A1A3     175       db 0x00, 0xa1, 0xa3 ; 9 
0999 00AB24     176       db 0x00, 0xab, 0x24 ; 10 
099C 00AFE8     177       db 0x00, 0xaf, 0xe8 ; 11 
099F 00B969     178       db 0x00, 0xb9, 0x69 ; 12 
09A2 009F40     179       db 0x00, 0x9f, 0x40 ; 13 
09A5 00A8C6     180       db 0x00, 0xa8, 0xc6 ; 14 
09A8 00AD86     181       db 0x00, 0xad, 0x86 ; 15 
09AB 00AD86     182       db 0x00, 0xad, 0x86 ; 16 
09AE 00B249     183       db 0x00, 0xb2, 0x49 ; 17 
09B1 0090FE     184       db 0x00, 0x90, 0xfe ; 18 
09B4 00BE29     185       db 0x00, 0xbe, 0x29 ; 19 
09B7 00AD87     186       db 0x00, 0xad, 0x87 ; 20 
09BA 009A7F     187       db 0x00, 0x9a, 0x7f ; 21 
09BD 00BE29     188       db 0x00, 0xbe, 0x29 ; 22 
09C0 00A8C7     189       db 0x00, 0xa8, 0xc7 ; 23 
09C3 00AB26     190       db 0x00, 0xab, 0x26 ; 24 
09C6 00B4A6     191       db 0x00, 0xb4, 0xa6 ; 25 
09C9 00AD84     192       db 0x00, 0xad, 0x84 ; 26 
09CC 00AFE9     193       db 0x00, 0xaf, 0xe9 ; 27 
09CF 00A8C5     194       db 0x00, 0xa8, 0xc5 ; 28 
09D2 00A665     195       db 0x00, 0xa6, 0x65 ; 29 
09D5 00BE2C     196       db 0x00, 0xbe, 0x2c ; 30 
09D8 009821     197       db 0x00, 0x98, 0x21 ; 31 
09DB 00BE19     198       db 0x00, 0xbe, 0x19 ; 32 
09DE 009F53     199       db 0x00, 0x9f, 0x53 ; 33 
09E1 00AB27     200       db 0x00, 0xab, 0x27 ; 34 
09E4 00A8C7     201       db 0x00, 0xa8, 0xc7 ; 35 
09E7            202   
09E7            203   Timer1_Init:
09E7            204            ; Configure P2.0, P2.4, P2.5 as open drain outputs
09E7 43CE31     205            orl P2M0, #0b_0011_0001
09EA 43CF31     206            orl P2M1, #0b_0011_0001
09ED D2A1       207            setb PIN_TWO_ONE  ; Configured as input
09EF D2A5       208            setb FLASH_CE ; CS=1 for SPI flash memory
09F1 C2A0       209            clr PIN_TWO_ZERO   ; Rest state of SCLK=0
09F3 C2A6       210            clr SPEAKER   ; Turn off speaker.
09F5            211            
09F5            212            ; Configure timer 1
09F5 53890F     213            anl     TMOD, #0x0F ; Clear the bits of timer 1 in TMOD
09F8 438910     214            orl     TMOD, #0x10 ; Set timer 1 in 16-bit timer mode.  Don't change the bits of timer 0
09FB 758DFC     215            mov TH1, #high(TIMER1_RELOAD)
09FE 758B15     216            mov TL1, #low(TIMER1_RELOAD)
0A01            217            ; Set autoreload value
0A01 75F5FC     218            mov RH1, #high(TIMER1_RELOAD)
0A04 75F315     219            mov RL1, #low(TIMER1_RELOAD)
0A07            220   
0A07            221            ; Enable the timer and interrupts
0A07 D2AB       222       setb ET1  ; Enable timer 1 interrupt
0A09 C28E       223            clr TR1 ; Timer 1 is only enabled to play stored sound
0A0B            224   
0A0B            225            ; Configure the DAC.  The DAC output we are using is P2.3, but P2.2 is also reserved.
0A0B 75A5A0     226            mov DADI, #0b_1010_0000 ; ACON=1
0A0E 75A43A     227            mov DADC, #0b_0011_1010 ; Enabled, DAC mode, Left adjusted, CLK/4
0A11 75AD80     228            mov DADH, #0x80 ; Middle of scale
0A14 75AC00     229            mov DADL, #0
0A17 43A440     230            orl DADC, #0b_0100_0000 ; Start DAC by GO/BSY=1
0A1A            231   
0A1A            232   check_DAC_init:
0A1A E5A4       233            mov a, DADC
0A1C 20E6FB     234            jb acc.6, check_DAC_init ; Wait for DAC to finish
0A1F D2AF       235            setb EA ; Enable interrupts
0A21 22         236       ret
0A22            237   
0A22            238   ;---------------------------------;
0A22            239   ; Routine to initialize the ISR   ;
0A22            240   ; for timer 2                     ;
0A22            241   ;---------------------------------;
0A22            242   Timer2_Init:
0A22 75C800     243            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
0A25 75CDA9     244            mov TH2, #high(TIMER2_RELOAD)
0A28 75CC9A     245            mov TL2, #low(TIMER2_RELOAD)
0A2B            246            ; Set the reload value
0A2B 75CBA9     247            mov RCAP2H, #high(TIMER2_RELOAD)
0A2E 75CA9A     248            mov RCAP2L, #low(TIMER2_RELOAD)
0A31            249            ; Init one millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
0A31 E4         250            clr a
0A32 F530       251            mov Count1ms+0, a
0A34 F531       252            mov Count1ms+1, a
0A36            253       ; Init five second interrupt counter
0A36 F532       254       mov Count5s, a
0A38            255            ; Enable the timer and interrupts
0A38 D2AD       256       setb ET2  ; Enable timer 2 interrupt
0A3A D2CA       257       setb TR2  ; Enable timer 2
0A3C 22         258            ret
0A3D            259   
0A3D            260   ; Configure the serial port and baud rate
0A3D            261   InitSerialPort:
0A3D            262       ; Since the reset button bounces, we need to wait a bit before
0A3D            263       ; sending messages, otherwise we risk displaying gibberish!
0A3D 79DE       264       mov R1, #222
0A3F 78A6       265       mov R0, #166
0A41 D8FE       266       djnz R0, $   ; 3 cycles->3*45.21123ns*166=22.51519us
0A43 D9FA       267       djnz R1, $-4 ; 22.51519us*222=4.998ms
0A45            268       ; Now we can proceed with the configuration
0A45 438780     269            orl     PCON,#0x80
0A48 759852     270            mov     SCON,#0x52
0A4B 759B00     271            mov     BDRCON,#0x00
0A4E 759AF4     272            mov     BRL,#BRG_VAL
0A51 759B1E     273            mov     BDRCON,#0x1E ; BDRCON=BRR|TBCK|RBCK|SPD;
0A54 22         274       ret
0A55            275   
0A55            276   INIT_SPI:
0A55 D282       277       setb MY_MISO    ; Make MISO an input pin
0A57 C281       278       clr MY_SCLK     ; For mode (0,0) SCLK is zero
0A59 22         279       ret
0A5A            280   
0A5A            281   ;-------------------------------------;
0A5A            282   ; ISR for Timer 1.  Used to playback  ;
0A5A            283   ; the WAV file stored in the SPI      ;
0A5A            284   ; flash memory.                       ;
0A5A            285   ;-------------------------------------;
0A5A            286   Timer1_ISR:
0A5A            287            ; The registers used in the ISR must be saved in the stack
0A5A C0E0       288            push acc
0A5C C0D0       289            push psw
0A5E            290   
0A5E            291            ; Check if the play counter is zero.  If so, stop playing sound.
0A5E E545       292            mov a, w+0
0A60 4546       293            orl a, w+1
0A62 4547       294            orl a, w+2
0A64 601E       295            jz stop_playing
0A66            296            
0A66            297            ; Decrement play counter 'w'.  In this implementation 'w' is a 24-bit counter.
0A66 74FF       298            mov a, #0xff
0A68 1545       299            dec w+0
0A6A B54507     300            cjne a, w+0, keep_playing
0A6D 1546       301            dec w+1
0A6F B54602     302            cjne a, w+1, keep_playing
0A72 1547       303            dec w+2
0A74            304            
0A74            305   keep_playing:
0A74 D2A6       306            setb SPEAKER
0A76 120433     307            lcall Send_SPI ; Read the next byte from the SPI Flash...
0A79 F580       308            mov P0, a ; WARNING: Remove this if not using an external DAC to use the pins of P0 as GPIO
0A7B 2480       309            add a, #0x80
0A7D F5AD       310            mov DADH, a ; Output to DAC. DAC output is pin P2.3
0A7F 43A440     311            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
0A82 800E       312            sjmp Timer1_ISR_Done
0A84            313   
0A84            314   stop_playing:
0A84 C28E       315            clr TR1 ; Stop timer 1
0A86 D2A5       316            setb FLASH_CE  ; Disable SPI Flash
0A88 C2A6       317            clr SPEAKER ; Turn off speaker.  Removes hissing noise when not playing sound.
0A8A 75AD80     318            mov DADH, #0x80 ; middle of range
0A8D 43A440     319            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
0A90            320   
0A90            321       ; Timer 1 has finished playing a sound. Set a flag so the main program knows         
0A90 D204       322       setb play_done
0A92            323   
0A92            324   Timer1_ISR_Done:
0A92 D0D0       325            pop psw
0A94 D0E0       326            pop acc
0A96 32         327            reti
0A97            328   
0A97            329   ;---------------------------------;
0A97            330   ; ISR for timer 2                 ;
0A97            331   ;---------------------------------;
0A97            332   Timer2_ISR:
0A97 C2CF       333            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
0A99            334            ;cpl P1.0 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
0A99            335            
0A99            336            ; The two registers used in the ISR must be saved in the stack
0A99 C0E0       337            push acc
0A9B C0D0       338            push psw
0A9D            339            
0A9D            340            ; Increment the 16-bit one mili second counter
0A9D 0530       341            inc Count1ms+0    ; Increment the low 8-bits first
0A9F E530       342            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0AA1 7002       343            jnz Inc_Done
0AA3 0531       344            inc Count1ms+1
0AA5            345   
0AA5            346   Inc_Done:
0AA5            347            ; Check if 1 second has passed
0AA5 E530       348            mov a, Count1ms+0
0AA7 B4E818     349            cjne a, #low(1000), Timer2_ISR_done ; Warning: this instruction high_low_flags the carry flag!
0AAA E531       350            mov a, Count1ms+1
0AAC B40313     351            cjne a, #high(1000), Timer2_ISR_done
0AAF            352            
0AAF            353            ; 1 second has passed. Set a flag so the main program knows
0AAF D200       354            setb seconds_flag ; Let the main program know 1 second has passed
0AB1 E4         355            clr a
0AB2 F530       356            mov Count1ms+0, a
0AB4 F531       357            mov Count1ms+1, a
0AB6 0532       358       inc Count5s
0AB8            359   
0AB8            360   Inc_Done_a:
0AB8            361       ; Check if 5 seconds has passed
0AB8 E532       362       mov a, Count5s
0ABA B40505     363       cjne a, #5, Timer2_ISR_done
0ABD            364       
0ABD            365       ; 5 seconds have passed. Set a flag so the main program knows
0ABD D201       366       setb five_seconds_flag
0ABF 753200     367       mov Count5s, #0
0AC2            368   
0AC2            369   Timer2_ISR_done:
0AC2 D0D0       370            pop psw
0AC4 D0E0       371            pop acc
0AC6 32         372            reti
0AC7            373   
0AC7            374   ;---------------------------------;
0AC7            375   ; Main Program                    ;
0AC7            376   ;---------------------------------;
0AC7            377   MainProgram:
0AC7 75817F     378       mov SP, #7FH ; Set the stack pointer to the begining of idata
0ACA D2AF       379       setb EA   ; Enable Global interrupts
0ACC 75E600     380       mov P0M0, #0
0ACF 75E700     381       mov P0M1, #0
0AD2 75D600     382       mov P1M0, #0
0AD5 75D700     383       mov P1M1, #0
0AD8 75CE00     384       mov P2M0, #0
0ADB 75CF00     385       mov P2M1, #0
0ADE            386       
0ADE 120A3D     387       lcall InitSerialPort
0AE1 120A55     388       lcall INIT_SPI
0AE4 120088     389       lcall LCD_4BIT
0AE7 1209E7     390       lcall Timer1_Init
0AEA 120A22     391       lcall Timer2_Init
0AED            392   
0AED D292       393       setb STATE_bit0
0AEF D293       394       setb STATE_bit1
0AF1 D294       395       setb STATE_bit2
0AF3 D295       396       setb STATE_STABLE
0AF5            397   
0AF5 C290       398       clr TEMP_OK
0AF7 C291       399       clr TEMP_50
0AF9 C296       400       clr OVEN_CTL_PIN
0AFB            401   
0AFB C200       402       clr seconds_flag
0AFD C201       403       clr five_seconds_flag
0AFF C203       404       clr hold_button
0B01 D204       405       setb play_done
0B03            406   
0B03 753000     407       mov count1ms+0, #0
0B06 753000     408       mov count1ms+0, #0
0B09            409       ; defualt soaktemp = 150
0B09 754096     410       mov soaktemp, #0x96
0B0C            411       ; default reflowtemp = 240
0B0C 7541F0     412       mov reflowtemp, #0xF0
0B0F            413   
0B0F 020E0E     414       ljmp setup ; jump to setup after reset
0B12            415   
0B12            416   ;-------------------------------------------------- STATE 0 --------------------------------------------------
0B12            417   ; idle state, reflow oven is off
0B12            418   State_0:
0B12            419       ; check state
0B12 3095FD     420       jnb STATE_STABLE, $ ; wait for state to be stable
0B15 120497     421       lcall read_state 
0B18 B40051     422       cjne a, #0, State_1
0B1B            423   
0B1B            424       ; turn off the oven
0B1B C296       425       clr OVEN_CTL_PIN
0B1D            426   
0B1D            427       ; temperature is set, TEMP_OK = 1
0B1D D290       428       setb TEMP_OK
0B1F            429   
0B1F            430       ; display "OVEN OFF" message
0B1F C0E0       431            push acc
0B21 7401       431            mov a, #1
0B23 14         431            dec a
0B24 1200BD     431            lcall ?Set_Cursor_2 ; Select column and row
0B27 D0E0       431            pop acc
0B29 C083       432            push dph
0B2B C082       432            push dpl
0B2D C0E0       432            push acc
0B2F 9008FB     432            mov dptr, #OVEN_OFF
0B32 1200B2     432            lcall ?Send_Constant_String
0B35 D0E0       432            pop acc
0B37 D082       432            pop dpl
0B39 D083       432            pop dph
0B3B            433   
0B3B            434       ;lcall Sound_Idle; [sound saying the current state "Idle"]
0B3B 781D       435       mov r0, #29
0B3D 12050A     436       lcall Play_Sound_Using_Index
0B40            437       ; if BOOT_BUTTON is being pressed, wait for release
0B40 30C5FD     438       jnb BOOT_BUTTON, $
0B43            439       
0B43            440   Idle:
0B43            441       ; check state
0B43 3095FD     442       jnb STATE_STABLE, $ ; wait for state to be stable
0B46 120497     443       lcall read_state
0B49 B40020     444       cjne a, #0, State_1
0B4C            445       ; Read tempurature every second
0B4C 30000B     446       jnb seconds_flag, Idle_a
0B4F C200       447       clr seconds_flag
0B51 1203F7     448       lcall Read_ADC
0B54 1204A3     449       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0B57 120396     450       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
0B5A            451   Idle_a:
0B5A            452       ; if BOOT_BUTTON is pressed, jump to setup
0B5A 20C5E6     453       jb BOOT_BUTTON, Idle
0B5D C002       454            push AR2
0B5F 7A32       454            mov R2, #50
0B61 120039     454            lcall ?Wait_Milli_Seconds
0B64 D002       454            pop AR2 ; debounce time
0B66 20C5DA     455       jb BOOT_BUTTON, Idle
0B69 020E0E     456       ljmp setup
0B6C            457   
0B6C            458   ;-------------------------------------------------- STATE 1 --------------------------------------------------
0B6C            459   ; heating to soak temperature
0B6C            460   State_1:
0B6C            461       ; check state
0B6C 3095FD     462       jnb STATE_STABLE, $ ; wait for state to be stable
0B6F 120497     463       lcall read_state
0B72 B40160     464       cjne a, #1, Jump_State_2 ; offset was too large for cjne to jump to State_2, branching to a ljmp
0B75            465   
0B75            466       ; turn on the oven
0B75 D296       467       setb OVEN_CTL_PIN
0B77            468   
0B77            469       ; display target temperature
0B77 C0E0       470            push acc
0B79 7401       470            mov a, #1
0B7B 14         470            dec a
0B7C 1200BD     470            lcall ?Set_Cursor_2 ; Select column and row
0B7F D0E0       470            pop acc
0B81 C083       471            push dph
0B83 C082       471            push dpl
0B85 C0E0       471            push acc
0B87 9008EA     471            mov dptr, #TARGET_TEMP
0B8A 1200B2     471            lcall ?Send_Constant_String
0B8D D0E0       471            pop acc
0B8F D082       471            pop dpl
0B91 D083       471            pop dph
0B93 753300     472            mov x+0, #low (0 % 0x10000) 
0B96 753400     472            mov x+1, #high(0 % 0x10000) 
0B99 753500     472            mov x+2, #low (0 / 0x10000) 
0B9C 753600     472            mov x+3, #high(0 / 0x10000) 
0B9F 854033     473       mov x+0, soaktemp
0BA2 1200DA     474       lcall hex2bcd
0BA5 C0E0       475            push acc
0BA7 7408       475            mov a, #8
0BA9 14         475            dec a
0BAA 1200BD     475            lcall ?Set_Cursor_2 ; Select column and row
0BAD D0E0       475            pop acc
0BAF C000       475            push ar0
0BB1 A83C       475            mov r0, bcd+1
0BB3 1200C4     475            lcall ?Display_BCD
0BB6 D000       475            pop ar0
0BB8 C000       475            push ar0
0BBA A83B       475            mov r0, bcd+0
0BBC 1200C4     475            lcall ?Display_BCD
0BBF D000       475            pop ar0
0BC1            475            ; Replace all the zeros to the left with blanks
0BC1 C0E0       475            push acc
0BC3 7408       475            mov a, #8
0BC5 14         475            dec a
0BC6 1200BD     475            lcall ?Set_Cursor_2 ; Select column and row
0BC9 D0E0       475            pop acc
0BCB 12034A     475            lcall replace_zeros
0BCE            476   
0BCE            477       ; [Sound for saying the current state "Heating to soak"]
0BCE 781E       478       mov r0, #30
0BD0 12050A     479       lcall Play_Sound_Using_Index
0BD3 8003       480       sjmp Heating_To_Soak
0BD5            481   
0BD5            482   Jump_State_2:   ; ljmp to state 2
0BD5 020C23     483       ljmp State_2
0BD8            484   
0BD8            485   Heating_To_Soak:
0BD8            486       ; read temperature every second
0BD8 30000B     487       jnb seconds_flag, Heating_To_Soak_a
0BDB C200       488       clr seconds_flag
0BDD 1203F7     489       lcall Read_ADC
0BE0 1204A3     490       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0BE3 120396     491       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
0BE6            492   Heating_To_Soak_a:
0BE6            493       ; play sound every five seconds
0BE6 300105     494       jnb five_seconds_flag, Heating_To_Soak_b
0BE9 C201       495       clr five_seconds_flag
0BEB 12055E     496       lcall Play_Temp_Sound; [function to play sound here]
0BEE            497   Heating_To_Soak_b:
0BEE            498       ; if temperature >= reflow temperature, TEMP_OK = 0
0BEE            499       ; else 1
0BEE 753300     500            mov x+0, #low (0 % 0x10000) 
0BF1 753400     500            mov x+1, #high(0 % 0x10000) 
0BF4 753500     500            mov x+2, #low (0 / 0x10000) 
0BF7 753600     500            mov x+3, #high(0 / 0x10000) 
0BFA 753700     501            mov y+0, #low (0 % 0x10000) 
0BFD 753800     501            mov y+1, #high(0 % 0x10000) 
0C00 753900     501            mov y+2, #low (0 / 0x10000) 
0C03 753A00     501            mov y+3, #high(0 / 0x10000) 
0C06 854433     502       mov x+0, temp_reading
0C09 854037     503       mov y+0, soaktemp
0C0C 120240     504       lcall x_gteq_y
0C0F 300202     505       jnb mf, Heating_To_Soak_c
0C12 C290       506       clr TEMP_OK
0C14            507   Heating_To_Soak_c:
0C14            508       ; if temperature >= 50, TEMP_50 = 1
0C14            509       ; else, TEMP_50 = 0
0C14 1204E3     510       lcall Check_50
0C17            511       ; check state
0C17 3095FD     512       jnb STATE_STABLE, $ ; wait for state to be stable
0C1A 120497     513       lcall read_state
0C1D B40103     514       cjne a, #1, State_2
0C20 020BD8     515       ljmp Heating_To_Soak
0C23            516   
0C23            517   ;-------------------------------------------------- STATE 2 --------------------------------------------------
0C23            518   ; soak temperature has been reached, temperature is held for [soaktime]
0C23            519   State_2:
0C23            520       ; check state
0C23 3095FD     521       jnb STATE_STABLE, $ ; wait for state to be stable
0C26 120497     522       lcall read_state
0C29 B4024D     523       cjne a, #2, State_3
0C2C            524   
0C2C            525       ; [sound saying the current state "Soaking"]
0C2C 781F       526       mov r0,#31
0C2E 12050A     527       lcall Play_Sound_Using_Index
0C31            528   
0C31            529   Soaking:
0C31            530       ; read temperature every second
0C31 30000B     531       jnb seconds_flag, Soaking_a
0C34 C200       532       clr seconds_flag
0C36 1203F7     533       lcall Read_ADC
0C39 1204A3     534       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0C3C 120396     535       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
0C3F            536   Soaking_a:
0C3F            537       ; play sound every five seconds
0C3F 300102     538       jnb five_seconds_flag, Soaking_b
0C42 C201       539       clr five_seconds_flag
0C44            540       ;lcall Play_Temp_Sound; [function to play sound here]
0C44            541   Soaking_b:
0C44            542       ; compare temperature to soaktemp
0C44 753300     543            mov x+0, #low (0 % 0x10000) 
0C47 753400     543            mov x+1, #high(0 % 0x10000) 
0C4A 753500     543            mov x+2, #low (0 / 0x10000) 
0C4D 753600     543            mov x+3, #high(0 / 0x10000) 
0C50 753700     544            mov y+0, #low (0 % 0x10000) 
0C53 753800     544            mov y+1, #high(0 % 0x10000) 
0C56 753900     544            mov y+2, #low (0 / 0x10000) 
0C59 753A00     544            mov y+3, #high(0 / 0x10000) 
0C5C 854433     545       mov x+0, temp_reading
0C5F 854037     546       mov y+0, soaktemp
0C62 120240     547       lcall x_gteq_y
0C65            548       ; if temperature >= soaktemp, turn off the oven
0C65 20020D     549       jb mf, Soaking_too_high
0C68            550       ; else, turn on the oven
0C68 D296       551       setb OVEN_CTL_PIN
0C6A            552   Soaking_d:
0C6A            553       ; check state
0C6A 3095FD     554       jnb STATE_STABLE, $ ; wait for state to be stable
0C6D 120497     555       lcall read_state
0C70 B40206     556       cjne a, #2, State_3
0C73 80BC       557       sjmp Soaking
0C75            558   
0C75            559   Soaking_too_high:
0C75 C296       560       clr OVEN_CTL_PIN ; turn off the oven
0C77 80F1       561       sjmp Soaking_d
0C79            562   
0C79            563   ;-------------------------------------------------- STATE 3 --------------------------------------------------
0C79            564   ; heating to reflow temperature
0C79            565   State_3:
0C79            566       ; check state
0C79 3095FD     567       jnb STATE_STABLE, $ ; wait for state to be stable
0C7C 120497     568       lcall read_state
0C7F B40344     569       cjne a, #3, Jump_State_4
0C82            570   
0C82            571       ; turn on the oven
0C82 D296       572       setb OVEN_CTL_PIN
0C84            573   
0C84            574       ; display target temperature
0C84 753300     575            mov x+0, #low (0 % 0x10000) 
0C87 753400     575            mov x+1, #high(0 % 0x10000) 
0C8A 753500     575            mov x+2, #low (0 / 0x10000) 
0C8D 753600     575            mov x+3, #high(0 / 0x10000) 
0C90 854133     576       mov x+0, reflowtemp
0C93 1200DA     577       lcall hex2bcd
0C96 C0E0       578            push acc
0C98 7408       578            mov a, #8
0C9A 14         578            dec a
0C9B 1200BD     578            lcall ?Set_Cursor_2 ; Select column and row
0C9E D0E0       578            pop acc
0CA0 C000       578            push ar0
0CA2 A83C       578            mov r0, bcd+1
0CA4 1200C4     578            lcall ?Display_BCD
0CA7 D000       578            pop ar0
0CA9 C000       578            push ar0
0CAB A83B       578            mov r0, bcd+0
0CAD 1200C4     578            lcall ?Display_BCD
0CB0 D000       578            pop ar0
0CB2            578            ; Replace all the zeros to the left with blanks
0CB2 C0E0       578            push acc
0CB4 7408       578            mov a, #8
0CB6 14         578            dec a
0CB7 1200BD     578            lcall ?Set_Cursor_2 ; Select column and row
0CBA D0E0       578            pop acc
0CBC 12034A     578            lcall replace_zeros
0CBF            579   
0CBF            580       ; [sound saying the current state "Heating to reflow"]
0CBF 7820       581       mov r0,#32
0CC1 12050A     582       lcall Play_Sound_Using_Index
0CC4 8003       583       sjmp Heating_To_Reflow
0CC6            584   
0CC6            585   Jump_State_4:   ; ljmp to state 4
0CC6 020D0D     586       ljmp State_4
0CC9            587   
0CC9            588   Heating_To_Reflow:
0CC9            589       ; read temperature every second
0CC9 30000B     590       jnb seconds_flag, Heating_To_Reflow_a
0CCC C200       591       clr seconds_flag
0CCE 1203F7     592       lcall Read_ADC
0CD1 1204A3     593       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0CD4 120396     594       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
0CD7            595   Heating_To_Reflow_a:
0CD7            596       ; play sound every five seconds
0CD7 300102     597       jnb five_seconds_flag, Heating_To_Reflow_b
0CDA C201       598       clr five_seconds_flag
0CDC            599       ;lcall Play_Temp_Sound ; [function to play sound here]
0CDC            600   Heating_To_Reflow_b:
0CDC 753300     601            mov x+0, #low (0 % 0x10000) 
0CDF 753400     601            mov x+1, #high(0 % 0x10000) 
0CE2 753500     601            mov x+2, #low (0 / 0x10000) 
0CE5 753600     601            mov x+3, #high(0 / 0x10000) 
0CE8 753700     602            mov y+0, #low (0 % 0x10000) 
0CEB 753800     602            mov y+1, #high(0 % 0x10000) 
0CEE 753900     602            mov y+2, #low (0 / 0x10000) 
0CF1 753A00     602            mov y+3, #high(0 / 0x10000) 
0CF4 854433     603       mov x+0, temp_reading
0CF7 854137     604       mov y+0, reflowtemp
0CFA 120240     605       lcall x_gteq_y
0CFD 300202     606       jnb mf, Heating_To_Reflow_c
0D00 D290       607       setb TEMP_OK
0D02            608   Heating_To_Reflow_c:
0D02            609       ; check state
0D02 3095FD     610       jnb STATE_STABLE, $ ; wait for state to be stable
0D05 120497     611       lcall read_state
0D08 B40302     612       cjne a, #3, State_4
0D0B 80BC       613       sjmp Heating_To_Reflow
0D0D            614   
0D0D            615   ;-------------------------------------------------- STATE 4 --------------------------------------------------
0D0D            616   ; reflow temperature has been reached, temperature is held for [reflowtime]
0D0D            617   State_4:
0D0D            618       ; check state
0D0D 3095FD     619       jnb STATE_STABLE, $ ; wait for state to be stable
0D10 120497     620       lcall read_state
0D13 B40450     621       cjne a, #4, State_5
0D16            622   
0D16            623       ;[Sound saying the current state "Reflowing"]
0D16 7821       624       mov r0, #33
0D18 02050A     625       ljmp Play_Sound_Using_Index 
0D1B            626   
0D1B            627   Reflowing:
0D1B            628       ; read temperature every second
0D1B 30000B     629       jnb seconds_flag, Reflowing_a
0D1E C200       630       clr seconds_flag
0D20 1203F7     631       lcall Read_ADC
0D23 1204A3     632       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0D26 120396     633       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
0D29            634   Reflowing_a:
0D29            635       ; play sound every five seconds
0D29 300102     636       jnb five_seconds_flag, Reflowing_b
0D2C C201       637       clr five_seconds_flag
0D2E            638       ;lcall Play_Temp_Sound ; [function to play sound here]
0D2E            639   Reflowing_b:
0D2E 753300     640            mov x+0, #low (0 % 0x10000) 
0D31 753400     640            mov x+1, #high(0 % 0x10000) 
0D34 753500     640            mov x+2, #low (0 / 0x10000) 
0D37 753600     640            mov x+3, #high(0 / 0x10000) 
0D3A 753700     641            mov y+0, #low (0 % 0x10000) 
0D3D 753800     641            mov y+1, #high(0 % 0x10000) 
0D40 753900     641            mov y+2, #low (0 / 0x10000) 
0D43 753A00     641            mov y+3, #high(0 / 0x10000) 
0D46 854433     642       mov x+0, temp_reading
0D49 854137     643       mov y+0, reflowtemp
0D4C 120240     644       lcall x_gteq_y
0D4F 200210     645       jb mf, Reflowing_too_high
0D52            646       ; if temperature >= soaktemp, turn off the oven
0D52 20020D     647       jb mf, Reflowing_too_high
0D55            648       ; else, turn on the oven
0D55 D296       649       setb OVEN_CTL_PIN
0D57            650   Reflowing_d:
0D57            651       ; check state
0D57 3095FD     652       jnb STATE_STABLE, $ ; wait for state to be stable
0D5A 120497     653       lcall read_state
0D5D B40406     654       cjne a, #4, State_5
0D60 80B9       655       sjmp Reflowing
0D62            656   
0D62            657   Reflowing_too_high:
0D62 C296       658       clr OVEN_CTL_PIN ; turn off the oven
0D64 80F1       659       sjmp Reflowing_d
0D66            660   
0D66            661   ;------------------------------------------------- STATE 5/6 -------------------------------------------------
0D66            662   ; cooldown/error
0D66            663   State_5:
0D66            664       ; check state
0D66 3095FD     665       jnb STATE_STABLE, $ ; wait for state to be stable
0D69 120497     666       lcall read_state
0D6C B40525     667       cjne a, #5, State_6
0D6F            668   
0D6F            669       ; turn off the oven
0D6F C296       670       clr OVEN_CTL_PIN
0D71            671   
0D71            672       ; display "OVEN OFF" message
0D71 C0E0       673            push acc
0D73 7401       673            mov a, #1
0D75 14         673            dec a
0D76 1200BD     673            lcall ?Set_Cursor_2 ; Select column and row
0D79 D0E0       673            pop acc
0D7B C083       674            push dph
0D7D C082       674            push dpl
0D7F C0E0       674            push acc
0D81 9008FB     674            mov dptr, #OVEN_OFF
0D84 1200B2     674            lcall ?Send_Constant_String
0D87 D0E0       674            pop acc
0D89 D082       674            pop dpl
0D8B D083       674            pop dph
0D8D            675   
0D8D 7822       676       mov r0, #34 ; moves the index for cooling into r0
0D8F 12050A     677       lcall Play_Sound_Using_Index; [Sound saying current state "Cooldown"]
0D92 8031       678       sjmp Cooldown
0D94            679   
0D94            680   State_6:
0D94            681       ; check state
0D94 3095FD     682       jnb STATE_STABLE, $ ; wait for state to be stable
0D97 120497     683       lcall read_state
0D9A B40625     684       cjne a, #6, Jump_State_0
0D9D            685   
0D9D            686       ; turn off the oven
0D9D C296       687       clr OVEN_CTL_PIN
0D9F            688   
0D9F            689       ; display "OVEN OFF" message
0D9F C0E0       690            push acc
0DA1 7401       690            mov a, #1
0DA3 14         690            dec a
0DA4 1200BD     690            lcall ?Set_Cursor_2 ; Select column and row
0DA7 D0E0       690            pop acc
0DA9 C083       691            push dph
0DAB C082       691            push dpl
0DAD C0E0       691            push acc
0DAF 9008FB     691            mov dptr, #OVEN_OFF
0DB2 1200B2     691            lcall ?Send_Constant_String
0DB5 D0E0       691            pop acc
0DB7 D082       691            pop dpl
0DB9 D083       691            pop dph
0DBB            692   
0DBB            693   
0DBB 7823       694       mov r0, #35 ; moves the index for error into r0
0DBD 12050A     695       lcall Play_Sound_Using_Index; [Sound saying current state "Error"]
0DC0 8003       696       sjmp Cooldown
0DC2            697   
0DC2            698   Jump_State_0:
0DC2 020B12     699       ljmp State_0
0DC5            700   
0DC5            701   Cooldown:
0DC5            702       ; read temperature every second
0DC5 30000B     703       jnb seconds_flag, Cooldown_a
0DC8 C200       704       clr seconds_flag
0DCA 1203F7     705       lcall Read_ADC
0DCD 1204A3     706       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0DD0 120396     707       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
0DD3            708   Cooldown_a:
0DD3            709       ; play sound every five seconds
0DD3 300102     710       jnb five_seconds_flag, Cooldown_b
0DD6 C201       711       clr five_seconds_flag
0DD8            712       ;lcall Play_Temp_Sound ; [function to play sound here] NOT FUNCTIONAL
0DD8            713   Cooldown_b:
0DD8 753300     714            mov x+0, #low (0 % 0x10000) 
0DDB 753400     714            mov x+1, #high(0 % 0x10000) 
0DDE 753500     714            mov x+2, #low (0 / 0x10000) 
0DE1 753600     714            mov x+3, #high(0 / 0x10000) 
0DE4 753732     715            mov y+0, #low (50 % 0x10000) 
0DE7 753800     715            mov y+1, #high(50 % 0x10000) 
0DEA 753900     715            mov y+2, #low (50 / 0x10000) 
0DED 753A00     715            mov y+3, #high(50 / 0x10000) 
0DF0 854433     716       mov x+0, temp_reading
0DF3 120240     717       lcall x_gteq_y
0DF6 200202     718       jb mf, Cooldown_c
0DF9 C291       719       clr TEMP_50
0DFB            720   Cooldown_c:
0DFB            721       ; if temperature >= 50, TEMP_50 = 1
0DFB            722       ; else, TEMP_50 = 0
0DFB 1204E3     723       lcall Check_50
0DFE            724       ; check state
0DFE 3095FD     725       jnb STATE_STABLE, $ ; wait for state to be stable
0E01 120497     726       lcall read_state
0E04 B40502     727       cjne a, #5, Cooldown_d
0E07 80BC       728       sjmp Cooldown
0E09            729   Cooldown_d:
0E09 B406B6     730       cjne a, #6, Jump_State_0
0E0C 80B7       731       sjmp Cooldown
0E0E            732   
0E0E            733   ;-------------------------------------------------- SETUP ----------------------------------------------------
0E0E            734   setup:
0E0E C2CA       735       clr TR2
0E10            736       ; temperature not set, TEMP_OK = 0
0E10 C290       737       clr TEMP_OK
0E12            738       ; prints "SOAK" left aligned in the top row
0E12 C0E0       739            push acc
0E14 7401       739            mov a, #1
0E16 14         739            dec a
0E17 1200BF     739            lcall ?Set_Cursor_1 ; Select column and row
0E1A D0E0       739            pop acc
0E1C C083       740            push dph
0E1E C082       740            push dpl
0E20 C0E0       740            push acc
0E22 9008B7     740            mov dptr, #SOAK_TEMP
0E25 1200B2     740            lcall ?Send_Constant_String
0E28 D0E0       740            pop acc
0E2A D082       740            pop dpl
0E2C D083       740            pop dph
0E2E            741       ; prints "REFLOW" left aligned in the bottom row
0E2E C0E0       742            push acc
0E30 7401       742            mov a, #1
0E32 14         742            dec a
0E33 1200BD     742            lcall ?Set_Cursor_2 ; Select column and row
0E36 D0E0       742            pop acc
0E38 C083       743            push dph
0E3A C082       743            push dpl
0E3C C0E0       743            push acc
0E3E 9008C8     743            mov dptr, #REFLOW_TEMP
0E41 1200B2     743            lcall ?Send_Constant_String
0E44 D0E0       743            pop acc
0E46 D082       743            pop dpl
0E48 D083       743            pop dph
0E4A            744       ; display soak temperature
0E4A 753300     745            mov x+0, #low (0 % 0x10000) 
0E4D 753400     745            mov x+1, #high(0 % 0x10000) 
0E50 753500     745            mov x+2, #low (0 / 0x10000) 
0E53 753600     745            mov x+3, #high(0 / 0x10000) 
0E56 854033     746       mov x+0, soaktemp
0E59 1200DA     747       lcall hex2bcd
0E5C C0E0       748            push acc
0E5E 7408       748            mov a, #8
0E60 14         748            dec a
0E61 1200BF     748            lcall ?Set_Cursor_1 ; Select column and row
0E64 D0E0       748            pop acc
0E66 C000       748            push ar0
0E68 A83C       748            mov r0, bcd+1
0E6A 1200C4     748            lcall ?Display_BCD
0E6D D000       748            pop ar0
0E6F C000       748            push ar0
0E71 A83B       748            mov r0, bcd+0
0E73 1200C4     748            lcall ?Display_BCD
0E76 D000       748            pop ar0
0E78            748            ; Replace all the zeros to the left with blanks
0E78 C0E0       748            push acc
0E7A 7408       748            mov a, #8
0E7C 14         748            dec a
0E7D 1200BF     748            lcall ?Set_Cursor_1 ; Select column and row
0E80 D0E0       748            pop acc
0E82 12034A     748            lcall replace_zeros
0E85            749       ; display reflow temperature
0E85 854133     750       mov x+0, reflowtemp+0
0E88 1200DA     751       lcall hex2bcd
0E8B C0E0       752            push acc
0E8D 7408       752            mov a, #8
0E8F 14         752            dec a
0E90 1200BD     752            lcall ?Set_Cursor_2 ; Select column and row
0E93 D0E0       752            pop acc
0E95 C000       752            push ar0
0E97 A83C       752            mov r0, bcd+1
0E99 1200C4     752            lcall ?Display_BCD
0E9C D000       752            pop ar0
0E9E C000       752            push ar0
0EA0 A83B       752            mov r0, bcd+0
0EA2 1200C4     752            lcall ?Display_BCD
0EA5 D000       752            pop ar0
0EA7            752            ; Replace all the zeros to the left with blanks
0EA7 C0E0       752            push acc
0EA9 7408       752            mov a, #8
0EAB 14         752            dec a
0EAC 1200BD     752            lcall ?Set_Cursor_2 ; Select column and row
0EAF D0E0       752            pop acc
0EB1 12034A     752            lcall replace_zeros
0EB4            753   
0EB4            754   ; set soak temperature
0EB4            755   ; MAX: 240
0EB4            756   ; MIN: 120
0EB4            757   set_soak_temp:
0EB4 854033     758       mov x+0, soaktemp
0EB7 C0E0       759            push acc
0EB9 740B       759            mov a, #11
0EBB 14         759            dec a
0EBC 1200BF     759            lcall ?Set_Cursor_1 ; Select column and row
0EBF D0E0       759            pop acc
0EC1 C0E0       760            push acc
0EC3 740E       760            mov a, #0xE
0EC5 120083     760            lcall ?WriteCommand
0EC8 D0E0       760            pop acc
0ECA            761       ; if BOOT_BUTTON is being pressed, wait for release
0ECA 30C5FD     762       jnb BOOT_BUTTON, $
0ECD            763   set_soak_temp_a:
0ECD            764       ; if UP is pressed, increment temperature
0ECD 208705     765       jb UP, set_soak_temp_b
0ED0 E533       766       mov a, x+0
0ED2            767       ; if temperature < 240, increment temperature
0ED2 B4F032     768       cjne a, #0xF0, set_soak_temp_d
0ED5            769   set_soak_temp_b:
0ED5            770       ; if DOWN button is pressed, increment temperature  
0ED5 208505     771       jb DOWN, set_soak_temp_c
0ED8 E533       772       mov a, x+0
0EDA            773       ; if temperature > 120, decrement temperature
0EDA B4783A     774       cjne a, #0x78, set_soak_temp_e
0EDD            775   set_soak_temp_c:  
0EDD C203       776       clr hold_button
0EDF C0E0       777            push acc
0EE1 740B       777            mov a, #11
0EE3 14         777            dec a
0EE4 1200BF     777            lcall ?Set_Cursor_1 ; Select column and row
0EE7 D0E0       777            pop acc
0EE9 C0E0       778            push acc
0EEB 740E       778            mov a, #0xE
0EED 120083     778            lcall ?WriteCommand
0EF0 D0E0       778            pop acc
0EF2            779       ; if BOOT_BUTTON is pressed, set reflow time
0EF2 20C5D8     780       jb BOOT_BUTTON, set_soak_temp_a
0EF5 C002       781            push AR2
0EF7 7A32       781            mov R2, #50
0EF9 120039     781            lcall ?Wait_Milli_Seconds
0EFC D002       781            pop AR2 ; debounce time
0EFE 20C5CC     782       jb BOOT_BUTTON, set_soak_temp_a
0F01 853340     783       mov soaktemp, x+0
0F04 020FBF     784       ljmp set_reflow_temp
0F07            785   set_soak_temp_d:
0F07            786       ; increment soak temperature
0F07 C0E0       787            push acc
0F09 740C       787            mov a, #0xC
0F0B 120083     787            lcall ?WriteCommand
0F0E D0E0       787            pop acc
0F10 0533       788       inc x+0
0F12            789       ; if UP is held, increment temperature rapidly
0F12 200312     790       jb hold_button, set_soak_temp_f
0F15 804D       791       sjmp set_soak_temp_g
0F17            792   set_soak_temp_e:
0F17            793       ; decrement soak temperature
0F17 C0E0       794            push acc
0F19 740C       794            mov a, #0xC
0F1B 120083     794            lcall ?WriteCommand
0F1E D0E0       794            pop acc
0F20 1533       795       dec x+0
0F22            796       ; if DOWN button is held, decrement temperature rapidly
0F22 200302     797       jb hold_button, set_soak_temp_f
0F25 803D       798       sjmp set_soak_temp_g
0F27            799   set_soak_temp_f:
0F27            800       ; update display and wait 25 ms
0F27 1200DA     801       lcall hex2bcd
0F2A C0E0       802            push acc
0F2C 7408       802            mov a, #8
0F2E 14         802            dec a
0F2F 1200BF     802            lcall ?Set_Cursor_1 ; Select column and row
0F32 D0E0       802            pop acc
0F34 C000       802            push ar0
0F36 A83C       802            mov r0, bcd+1
0F38 1200C4     802            lcall ?Display_BCD
0F3B D000       802            pop ar0
0F3D C000       802            push ar0
0F3F A83B       802            mov r0, bcd+0
0F41 1200C4     802            lcall ?Display_BCD
0F44 D000       802            pop ar0
0F46            802            ; Replace all the zeros to the left with blanks
0F46 C0E0       802            push acc
0F48 7408       802            mov a, #8
0F4A 14         802            dec a
0F4B 1200BF     802            lcall ?Set_Cursor_1 ; Select column and row
0F4E D0E0       802            pop acc
0F50 12034A     802            lcall replace_zeros
0F53 C002       803            push AR2
0F55 7A19       803            mov R2, #25
0F57 120039     803            lcall ?Wait_Milli_Seconds
0F5A D002       803            pop AR2
0F5C            804       ; if UP is held, increment temperature
0F5C 308756     805       jnb UP, set_soak_temp_h
0F5F            806       ; if DOWN button is held, decrement temperature
0F5F 308558     807       jnb DOWN, set_soak_temp_i
0F62 C203       808       clr hold_button
0F64            809   set_soak_temp_g:
0F64            810       ; update display and wait 250 ms
0F64 1200DA     811       lcall hex2bcd
0F67 C0E0       812            push acc
0F69 7408       812            mov a, #8
0F6B 14         812            dec a
0F6C 1200BF     812            lcall ?Set_Cursor_1 ; Select column and row
0F6F D0E0       812            pop acc
0F71 C000       812            push ar0
0F73 A83C       812            mov r0, bcd+1
0F75 1200C4     812            lcall ?Display_BCD
0F78 D000       812            pop ar0
0F7A C000       812            push ar0
0F7C A83B       812            mov r0, bcd+0
0F7E 1200C4     812            lcall ?Display_BCD
0F81 D000       812            pop ar0
0F83            812            ; Replace all the zeros to the left with blanks
0F83 C0E0       812            push acc
0F85 7408       812            mov a, #8
0F87 14         812            dec a
0F88 1200BF     812            lcall ?Set_Cursor_1 ; Select column and row
0F8B D0E0       812            pop acc
0F8D 12034A     812            lcall replace_zeros
0F90 C0E0       813            push acc
0F92 740B       813            mov a, #11
0F94 14         813            dec a
0F95 1200BF     813            lcall ?Set_Cursor_1 ; Select column and row
0F98 D0E0       813            pop acc
0F9A C0E0       814            push acc
0F9C 740E       814            mov a, #0xE
0F9E 120083     814            lcall ?WriteCommand
0FA1 D0E0       814            pop acc
0FA3 C002       815            push AR2
0FA5 7AFA       815            mov R2, #250
0FA7 120039     815            lcall ?Wait_Milli_Seconds
0FAA D002       815            pop AR2
0FAC            816       ; if UP is held, set a flag so the program knows
0FAC 308706     817       jnb UP, set_soak_temp_h
0FAF            818       ; if DOWN button is held, set a flag so the program knows 
0FAF 308508     819       jnb DOWN, set_soak_temp_i
0FB2 020ECD     820       ljmp set_soak_temp_a
0FB5            821   set_soak_temp_h:
0FB5 D203       822       setb hold_button
0FB7 020ECD     823       ljmp set_soak_temp_a
0FBA            824   set_soak_temp_i:
0FBA D203       825       setb hold_button
0FBC 020ED5     826       ljmp set_soak_temp_b
0FBF            827   
0FBF            828   ; set reflow temp
0FBF            829   ; MAX: 240
0FBF            830   ; MIN: 120
0FBF            831   set_reflow_temp:
0FBF 854133     832       mov x+0, reflowtemp
0FC2 C0E0       833            push acc
0FC4 740B       833            mov a, #11
0FC6 14         833            dec a
0FC7 1200BD     833            lcall ?Set_Cursor_2 ; Select column and row
0FCA D0E0       833            pop acc
0FCC C0E0       834            push acc
0FCE 740E       834            mov a, #0xE
0FD0 120083     834            lcall ?WriteCommand
0FD3 D0E0       834            pop acc
0FD5            835       ; if BOOT_BUTTON is being pressed, wait for release
0FD5 30C5FD     836       jnb BOOT_BUTTON, $
0FD8            837   set_reflow_temp_a:
0FD8            838       ; if UP is pressed, increment temperature
0FD8 208705     839       jb UP, set_reflow_temp_b
0FDB E533       840       mov a, x+0
0FDD            841       ; if temperature < 240, increment temperature
0FDD B4F032     842       cjne a, #0xF0, set_reflow_temp_d
0FE0            843   set_reflow_temp_b:
0FE0            844       ; if DOWN button is pressed, increment temperature  
0FE0 208505     845       jb DOWN, set_reflow_temp_c
0FE3 E533       846       mov a, x+0
0FE5            847       ; if temperature > 0, decrement temperature
0FE5 B4783A     848       cjne a, #0x78, set_reflow_temp_e
0FE8            849   set_reflow_temp_c:  
0FE8 C203       850       clr hold_button
0FEA C0E0       851            push acc
0FEC 740B       851            mov a, #11
0FEE 14         851            dec a
0FEF 1200BD     851            lcall ?Set_Cursor_2 ; Select column and row
0FF2 D0E0       851            pop acc
0FF4 C0E0       852            push acc
0FF6 740E       852            mov a, #0xE
0FF8 120083     852            lcall ?WriteCommand
0FFB D0E0       852            pop acc
0FFD            853       ; if BOOT_BUTTON is pressed, set reflow time
0FFD 20C5D8     854       jb BOOT_BUTTON, set_reflow_temp_a
1000 C002       855            push AR2
1002 7A32       855            mov R2, #50
1004 120039     855            lcall ?Wait_Milli_Seconds
1007 D002       855            pop AR2 ; debounce time
1009 20C5CC     856       jb BOOT_BUTTON, set_reflow_temp_a
100C 853341     857       mov reflowtemp, x+0
100F 0210CA     858       ljmp setup_done
1012            859   set_reflow_temp_d:
1012            860       ; increment reflow temperature
1012 C0E0       861            push acc
1014 740C       861            mov a, #0xC
1016 120083     861            lcall ?WriteCommand
1019 D0E0       861            pop acc
101B 0533       862       inc x+0
101D            863       ; if UP is held, increment temperature rapidly
101D 200312     864       jb hold_button, set_reflow_temp_f
1020 804D       865       sjmp set_reflow_temp_g
1022            866   set_reflow_temp_e:
1022            867       ; decrement reflow temperature
1022 C0E0       868            push acc
1024 740C       868            mov a, #0xC
1026 120083     868            lcall ?WriteCommand
1029 D0E0       868            pop acc
102B 1533       869       dec x+0
102D            870       ; if DOWN button is held, decrement temperature rapidly
102D 200302     871       jb hold_button, set_reflow_temp_f
1030 803D       872       sjmp set_reflow_temp_g
1032            873   set_reflow_temp_f:
1032            874       ; update display and wait 25 ms
1032 1200DA     875       lcall hex2bcd
1035 C0E0       876            push acc
1037 7408       876            mov a, #8
1039 14         876            dec a
103A 1200BD     876            lcall ?Set_Cursor_2 ; Select column and row
103D D0E0       876            pop acc
103F C000       876            push ar0
1041 A83C       876            mov r0, bcd+1
1043 1200C4     876            lcall ?Display_BCD
1046 D000       876            pop ar0
1048 C000       876            push ar0
104A A83B       876            mov r0, bcd+0
104C 1200C4     876            lcall ?Display_BCD
104F D000       876            pop ar0
1051            876            ; Replace all the zeros to the left with blanks
1051 C0E0       876            push acc
1053 7408       876            mov a, #8
1055 14         876            dec a
1056 1200BD     876            lcall ?Set_Cursor_2 ; Select column and row
1059 D0E0       876            pop acc
105B 12034A     876            lcall replace_zeros
105E C002       877            push AR2
1060 7A19       877            mov R2, #25
1062 120039     877            lcall ?Wait_Milli_Seconds
1065 D002       877            pop AR2
1067            878       ; if UP is held, increment temperature
1067 308756     879       jnb UP, set_reflow_temp_h
106A            880       ; if DOWN button is held, decrement temperature
106A 308558     881       jnb DOWN, set_reflow_temp_i
106D C203       882       clr hold_button
106F            883   set_reflow_temp_g:
106F            884       ; update display and wait 250 ms
106F 1200DA     885       lcall hex2bcd
1072 C0E0       886            push acc
1074 7408       886            mov a, #8
1076 14         886            dec a
1077 1200BD     886            lcall ?Set_Cursor_2 ; Select column and row
107A D0E0       886            pop acc
107C C000       886            push ar0
107E A83C       886            mov r0, bcd+1
1080 1200C4     886            lcall ?Display_BCD
1083 D000       886            pop ar0
1085 C000       886            push ar0
1087 A83B       886            mov r0, bcd+0
1089 1200C4     886            lcall ?Display_BCD
108C D000       886            pop ar0
108E            886            ; Replace all the zeros to the left with blanks
108E C0E0       886            push acc
1090 7408       886            mov a, #8
1092 14         886            dec a
1093 1200BD     886            lcall ?Set_Cursor_2 ; Select column and row
1096 D0E0       886            pop acc
1098 12034A     886            lcall replace_zeros
109B C0E0       887            push acc
109D 740B       887            mov a, #11
109F 14         887            dec a
10A0 1200BD     887            lcall ?Set_Cursor_2 ; Select column and row
10A3 D0E0       887            pop acc
10A5 C0E0       888            push acc
10A7 740E       888            mov a, #0xE
10A9 120083     888            lcall ?WriteCommand
10AC D0E0       888            pop acc
10AE C002       889            push AR2
10B0 7AFA       889            mov R2, #250
10B2 120039     889            lcall ?Wait_Milli_Seconds
10B5 D002       889            pop AR2
10B7            890       ; if UP is held, set a flag so the program knows
10B7 308706     891       jnb UP, set_reflow_temp_h
10BA            892       ; if DOWN button is held, set a flag so the program knows 
10BA 308508     893       jnb DOWN, set_reflow_temp_i
10BD 020FD8     894       ljmp set_reflow_temp_a
10C0            895   set_reflow_temp_h:
10C0 D203       896       setb hold_button
10C2 020FD8     897       ljmp set_reflow_temp_a
10C5            898   set_reflow_temp_i:
10C5 D203       899       setb hold_button
10C7 020FE0     900       ljmp set_reflow_temp_b
10CA            901   
10CA            902   setup_done:
10CA C0E0       903            push acc
10CC 740C       903            mov a, #0xC
10CE 120083     903            lcall ?WriteCommand
10D1 D0E0       903            pop acc
10D3            904       ; display current temperature
10D3 C0E0       905            push acc
10D5 7401       905            mov a, #1
10D7 14         905            dec a
10D8 1200BF     905            lcall ?Set_Cursor_1 ; Select column and row
10DB D0E0       905            pop acc
10DD C083       906            push dph
10DF C082       906            push dpl
10E1 C0E0       906            push acc
10E3 9008D9     906            mov dptr, #CURRENT_TEMP
10E6 1200B2     906            lcall ?Send_Constant_String
10E9 D0E0       906            pop acc
10EB D082       906            pop dpl
10ED D083       906            pop dph
10EF 1203F7     907       lcall Read_ADC
10F2 C0E0       908            push acc
10F4 7408       908            mov a, #8
10F6 14         908            dec a
10F7 1200BF     908            lcall ?Set_Cursor_1 ; Select column and row
10FA D0E0       908            pop acc
10FC C000       908            push ar0
10FE A83C       908            mov r0, bcd+1
1100 1200C4     908            lcall ?Display_BCD
1103 D000       908            pop ar0
1105 C000       908            push ar0
1107 A83B       908            mov r0, bcd+0
1109 1200C4     908            lcall ?Display_BCD
110C D000       908            pop ar0
110E            908            ; Replace all the zeros to the left with blanks
110E C0E0       908            push acc
1110 7408       908            mov a, #8
1112 14         908            dec a
1113 1200BF     908            lcall ?Set_Cursor_1 ; Select column and row
1116 D0E0       908            pop acc
1118 12034A     908            lcall replace_zeros
111B D2CA       909       setb TR2
111D 020B12     910       ljmp State_0
