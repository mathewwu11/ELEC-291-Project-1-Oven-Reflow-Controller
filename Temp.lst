                  2   $LIST
0000              4   
0000              5   CLK  EQU 22118400
0000              6   BAUD equ 115200
0000              7   BRG_VAL equ (0x100-(CLK/(16*BAUD)))
0000              8   
0000              9   TIMER1_RATE    EQU 22050     ; 22050Hz is the sampling rate of the wav file we are playing
0000             10   TIMER1_RELOAD  EQU 0x10000-(CLK/TIMER1_RATE)
0000             11   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             12   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             13   
0000             14   ; The pins used for SPI
0000             15   FLASH_CE  EQU  P2.5
0000             16   PIN_TWO_FOUR   EQU  P2.4 
0000             17   PIN_TWO_ONE   EQU  P2.1
0000             18   PIN_TWO_ZERO   EQU  P2.0 
0000             19   
0000             20   BOOT_BUTTON   equ P4.5
0000             21   SPEAKER  EQU P2.6 ; Used with a MOSFET to turn off speaker when not in use
0000             22   UP            equ P0.7
0000             23   DOWN               equ P0.5
0000             24   ; Input 3 bit binary state from TIME/FSM MCU
0000             25   STATE_bit0      equ P1.2
0000             26   STATE_bit1      equ P1.3
0000             27   STATE_bit2      equ P1.4
0000             28   STATE_STABLE    equ P1.5
0000             29   ; Outputs to Time/FSM MCU
0000             30   TEMP_OK        equ P1.0
0000             31   TEMP_50        equ P1.1
0000             32   OVEN_CTL_PIN   equ P1.6
0000             33   
0000             34    ; Commands supported by the SPI flash memory according to the datasheet
0000             35   WRITE_ENABLE     EQU 0x06  ; Address:0 Dummy:0 Num:0
0000             36   WRITE_DISABLE    EQU 0x04  ; Address:0 Dummy:0 Num:0
0000             37   READ_STATUS      EQU 0x05  ; Address:0 Dummy:0 Num:1 to infinite
0000             38   READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
0000             39   READ_SILICON_ID  EQU 0xab  ; Address:0 Dummy:3 Num:1 to infinite
0000             40   FAST_READ        EQU 0x0b  ; Address:3 Dummy:1 Num:1 to infinite
0000             41   WRITE_STATUS     EQU 0x01  ; Address:0 Dummy:0 Num:1
0000             42   WRITE_BYTES      EQU 0x02  ; Address:3 Dummy:0 Num:1 to 256
0000             43   ERASE_ALL        EQU 0xc7  ; Address:0 Dummy:0 Num:0
0000             44   ERASE_BLOCK      EQU 0xd8  ; Address:3 Dummy:0 Num:0
0000             45   READ_DEVICE_ID   EQU 0x9f  ; Address:0 Dummy:2 Num:1 to infinite
0000             46   
0000             47   org 0000H
0000 020AE1      48      ljmp MainProgram
0003             49   
0003             50   ; External interrupt 0 vector (not used in this code)
0003             51   org 0x0003
0003 32          52            reti
0004             53   
0004             54   ; Timer/Counter 0 overflow interrupt vector (not used in this code)
000B             55   org 0x000B
000B 32          56            reti
000C             57   
000C             58   ; External interrupt 1 vector (not used in this code)
0013             59   org 0x0013
0013 32          60            reti
0014             61   
0014             62   ; Timer/Counter 1 overflow interrupt vector
001B             63   org 0x001B
001B 020A74      64            ljmp Timer1_ISR
001E             65   
001E             66   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             67   org 0x0023 
0023 32          68            reti
0024             69            
0024             70   ; Timer/Counter 2 overflow interrupt vector
002B             71   org 0x002B
002B 020AB1      72            ljmp Timer2_ISR
002E             73   
0030             74   DSEG at 30H
0030             75   Count1ms:           ds 2
0032             76   Count5s:            ds 1 
0033             77   x:                  ds 4 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file
0037             78   y:                  ds 4 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file
003B             79   bcd:                ds 5 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file 
0040             80   soaktemp:           ds 1
0041             81   reflowtemp:         ds 1
0042             82   volt_reading:       ds 2 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file
0044             83   temp_reading:       ds 1
0045             84   w:                               ds 3 ; 24-bit play counter.  Decremented in Timer 1 ISR.
0048             85   
0000             86   BSEG
0000             87   seconds_flag:       dbit 1
0001             88   five_seconds_flag:  dbit 1
0002             89   mf:                 dbit 1 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file
0003             90   hold_button:        dbit 1
0004             91   play_done:          dbit 1
0005             92   
002E             93   CSEG
002E             94   ; These ’EQU’ must match the wiring between the microcontroller and ADC (used in the INC file)
002E             95   CE_ADC  EQU P0.4
002E             96   MY_MOSI EQU P0.3
002E             97   MY_MISO EQU P0.2
002E             98   MY_SCLK EQU P0.1
002E             99   ; These 'equ' must match the hardware wiring
002E            100   ; They are used by 'LCD_4bit.inc'
002E            101   LCD_RS equ P3.2
002E            102   ; LCD_RW equ Px.x ; Always grounded
002E            103   LCD_E  equ P3.3
002E            104   LCD_D4 equ P3.4
002E            105   LCD_D5 equ P3.5
002E            106   LCD_D6 equ P3.6
002E            107   LCD_D7 equ P3.7
002E            108   
                553   $LIST
                113      $LIST
08C5            115   
08C5            116   ;                   1234567890123456
08C5 536F616B   117   SOAK_TEMP:      db 'Soak:   xxx', 0xDF, 'C   ', 0
     3A202020
     787878DF
     43202020
     00
08D6 5265666C   118   REFLOW_TEMP:    db 'Reflow: xxx', 0xDF, 'C   ', 0
     6F773A20
     787878DF
     43202020
     00
08E7 54656D70   119   CURRENT_TEMP:   db 'Temp:   xxx', 0xDF, 'C   ', 0
     3A202020
     787878DF
     43202020
     00
08F8 54617267   120   TARGET_TEMP:    db 'Target: xxx', 0xDF, 'C   ', 0
     65743A20
     787878DF
     43202020
     00
0909 4F56454E   121   OVEN_OFF:       db 'OVEN OFF        ', 0
     204F4646
     20202020
     20202020
     00
091A            122   
091A            123   
091A            124   ; Approximate index of sounds in file 'nsound.wav'
091A            125   ;sound_index:       ; index | number
091A            126       ;Approximate index of sounds in file '1secsound.wav'
091A            127   sound_index:
091A 00002B     128       db 0x00, 0x00, 0x2b ; 0 same -
091D 0027B3     129       db 0x00, 0x27, 0xb3 ; 1 
0920 0094FF     130       db 0x00, 0x94, 0xff ; 2 
0923 00FF4B     131       db 0x00, 0xff, 0x4b ; 3 
0926 016AEF     132       db 0x01, 0x6a, 0xef ; 4 
0929 01D7A5     133       db 0x01, 0xd7, 0xa5 ; 5 
092C 024744     134       db 0x02, 0x47, 0x44 ; 6 
092F 02B48F     135       db 0x02, 0xb4, 0x8f ; 7 
0932 0329FE     136       db 0x03, 0x29, 0xfe ; 8 
0935 039141     137       db 0x03, 0x91, 0x41 ; 9 
0938 03FD9B     138       db 0x03, 0xfd, 0x9b ; 10 
093B 0466D4     139       db 0x04, 0x66, 0xd4 ; 11 
093E 04E214     140       db 0x04, 0xe2, 0x14 ; 12 
0941 0552E1     141       db 0x05, 0x52, 0xe1 ; 13 
0944 05D0ED     142       db 0x05, 0xd0, 0xed ; 14 
0947 065464     143       db 0x06, 0x54, 0x64 ; 15 
094A 06CAFF     144       db 0x06, 0xca, 0xff ; 16 
094D 074CA3     145       db 0x07, 0x4c, 0xa3 ; 17 
0950 07D1C4     146       db 0x07, 0xd1, 0xc4 ; 18 
0953 084AB0     147       db 0x08, 0x4a, 0xb0 ; 19 
0956 08CC51     148       db 0x08, 0xcc, 0x51 ; 20 same
0959 094445     149       db 0x09, 0x44, 0x45 ; 21  thirty
095C 09BB41     150       db 0x09, 0xbb, 0x41 ; 22   fourty
095F 0A30B1     151       db 0x0a, 0x30, 0xb1 ; 23 fifty
0962 0AA33A     152       db 0x0a, 0xa3, 0x3a ; 24 sixty
0965 0B2D96     153       db 0x0b, 0x2d, 0x96 ; 25 seventy
0968 0BA305     154       db 0x0b, 0xa3, 0x05 ; 26 eighty
096B 0C1874     155       db 0x0c, 0x18, 0x74 ; 27 ninty
096E 0C8DE3     156       db 0x0c, 0x8d, 0xe3 ; 28 one hundred
0971 0D1CF5     157       db 0x0d, 0x1c, 0xf5 ; 29 two hundred
0974 0DAA17     158       db 0x0d, 0xaa, 0x17 ; 30 idle 
0977 0E1F87     159       db 0x0e, 0x1f, 0x87 ; 31 heating to soak
097A 0EBA3E     160       db 0x0e, 0xba, 0x3e ; 32 soaking
097D 0F2CC5     161       db 0x0f, 0x2c, 0xc5 ; 33 heating to reflow
0980 0FCDCE     162       db 0x0f, 0xcd, 0xce ; 34 reflowing
0983 1051C2     163       db 0x10, 0x51, 0xc2 ; 35 cooldown
0986 10D2D4     164       db 0x10, 0xd2, 0xd4 ; 36 error
0989 114870     165       db 0x11, 0x48, 0x70 ; 37 trash
098C 118A64     166       db 0x11, 0x8a, 0x64  ;trash
098F            167   
098F            168   ; Size of each sound in 'sound_index'
098F            169   Size_sound:
098F 002788     170       db 0x00, 0x27, 0x88 ; 0 
0992 006D4C     171       db 0x00, 0x6d, 0x4c ; 1 
0995 006A4C     172       db 0x00, 0x6a, 0x4c ; 2 
0998 006BA4     173       db 0x00, 0x6b, 0xa4 ; 3 
099B 006CB6     174       db 0x00, 0x6c, 0xb6 ; 4 
099E 006F9F     175       db 0x00, 0x6f, 0x9f ; 5 
09A1 006D4B     176       db 0x00, 0x6d, 0x4b ; 6 
09A4 00756F     177       db 0x00, 0x75, 0x6f ; 7 
09A7 006743     178       db 0x00, 0x67, 0x43 ; 8 
09AA 006C5A     179       db 0x00, 0x6c, 0x5a ; 9 
09AD 006939     180       db 0x00, 0x69, 0x39 ; 10 
09B0 007B40     181       db 0x00, 0x7b, 0x40 ; 11 
09B3 0070CD     182       db 0x00, 0x70, 0xcd ; 12 
09B6 007E0C     183       db 0x00, 0x7e, 0x0c ; 13 
09B9 008377     184       db 0x00, 0x83, 0x77 ; 14 
09BC 00769B     185       db 0x00, 0x76, 0x9b ; 15 
09BF 0081A4     186       db 0x00, 0x81, 0xa4 ; 16 
09C2 008521     187       db 0x00, 0x85, 0x21 ; 17 
09C5 0078EC     188       db 0x00, 0x78, 0xec ; 18 
09C8 0081A1     189       db 0x00, 0x81, 0xa1 ; 19 
09CB 0077F4     190       db 0x00, 0x77, 0xf4 ; 20 
09CE 0076FC     191       db 0x00, 0x76, 0xfc ; 21 
09D1 007570     192       db 0x00, 0x75, 0x70 ; 22 
09D4 007289     193       db 0x00, 0x72, 0x89 ; 23 
09D7 008A5C     194       db 0x00, 0x8a, 0x5c ; 24 
09DA 00756F     195       db 0x00, 0x75, 0x6f ; 25 
09DD 00756F     196       db 0x00, 0x75, 0x6f ; 26 
09E0 00756F     197       db 0x00, 0x75, 0x6f ; 27 
09E3 008F12     198       db 0x00, 0x8f, 0x12 ; 28 
09E6 008D22     199       db 0x00, 0x8d, 0x22 ; 29 
09E9 007570     200       db 0x00, 0x75, 0x70 ; 30 
09EC 009AB7     201       db 0x00, 0x9a, 0xb7 ; 31 
09EF 007287     202       db 0x00, 0x72, 0x87 ; 32 
09F2 00A109     203       db 0x00, 0xa1, 0x09 ; 33 
09F5 0083F4     204       db 0x00, 0x83, 0xf4 ; 34 
09F8 008112     205       db 0x00, 0x81, 0x12 ; 35 
09FB 00759C     206       db 0x00, 0x75, 0x9c ; 36 
09FE 0041F4     207       db 0x00, 0x41, 0xf4 ; 37  
0A01            208   
0A01            209   Timer1_Init:
0A01            210            ; Configure P2.0, P2.4, P2.5 as open drain outputs
0A01 43CE31     211            orl P2M0, #0b_0011_0001
0A04 43CF31     212            orl P2M1, #0b_0011_0001
0A07 D2A1       213            setb PIN_TWO_ONE  ; Configured as input
0A09 D2A5       214            setb FLASH_CE ; CS=1 for SPI flash memory
0A0B C2A0       215            clr PIN_TWO_ZERO   ; Rest state of SCLK=0
0A0D C2A6       216            clr SPEAKER   ; Turn off speaker.
0A0F            217            
0A0F            218            ; Configure timer 1
0A0F 53890F     219            anl     TMOD, #0x0F ; Clear the bits of timer 1 in TMOD
0A12 438910     220            orl     TMOD, #0x10 ; Set timer 1 in 16-bit timer mode.  Don't change the bits of timer 0
0A15 758DFC     221            mov TH1, #high(TIMER1_RELOAD)
0A18 758B15     222            mov TL1, #low(TIMER1_RELOAD)
0A1B            223            ; Set autoreload value
0A1B 75F5FC     224            mov RH1, #high(TIMER1_RELOAD)
0A1E 75F315     225            mov RL1, #low(TIMER1_RELOAD)
0A21            226   
0A21            227            ; Enable the timer and interrupts
0A21 D2AB       228       setb ET1  ; Enable timer 1 interrupt
0A23 C28E       229            clr TR1 ; Timer 1 is only enabled to play stored sound
0A25            230   
0A25            231            ; Configure the DAC.  The DAC output we are using is P2.3, but P2.2 is also reserved.
0A25 75A5A0     232            mov DADI, #0b_1010_0000 ; ACON=1
0A28 75A43A     233            mov DADC, #0b_0011_1010 ; Enabled, DAC mode, Left adjusted, CLK/4
0A2B 75AD80     234            mov DADH, #0x80 ; Middle of scale
0A2E 75AC00     235            mov DADL, #0
0A31 43A440     236            orl DADC, #0b_0100_0000 ; Start DAC by GO/BSY=1
0A34            237   
0A34            238   check_DAC_init:
0A34 E5A4       239            mov a, DADC
0A36 20E6FB     240            jb acc.6, check_DAC_init ; Wait for DAC to finish
0A39 D2AF       241            setb EA ; Enable interrupts
0A3B 22         242       ret
0A3C            243   
0A3C            244   ;---------------------------------;
0A3C            245   ; Routine to initialize the ISR   ;
0A3C            246   ; for timer 2                     ;
0A3C            247   ;---------------------------------;
0A3C            248   Timer2_Init:
0A3C 75C800     249            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
0A3F 75CDA9     250            mov TH2, #high(TIMER2_RELOAD)
0A42 75CC9A     251            mov TL2, #low(TIMER2_RELOAD)
0A45            252            ; Set the reload value
0A45 75CBA9     253            mov RCAP2H, #high(TIMER2_RELOAD)
0A48 75CA9A     254            mov RCAP2L, #low(TIMER2_RELOAD)
0A4B            255            ; Init one millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
0A4B E4         256            clr a
0A4C F530       257            mov Count1ms+0, a
0A4E F531       258            mov Count1ms+1, a
0A50            259       ; Init five second interrupt counter
0A50 F532       260       mov Count5s, a
0A52            261            ; Enable the timer and interrupts
0A52 D2AD       262       setb ET2  ; Enable timer 2 interrupt
0A54 D2CA       263       setb TR2  ; Enable timer 2
0A56 22         264            ret
0A57            265   
0A57            266   ; Configure the serial port and baud rate
0A57            267   InitSerialPort:
0A57            268       ; Since the reset button bounces, we need to wait a bit before
0A57            269       ; sending messages, otherwise we risk displaying gibberish!
0A57 79DE       270       mov R1, #222
0A59 78A6       271       mov R0, #166
0A5B D8FE       272       djnz R0, $   ; 3 cycles->3*45.21123ns*166=22.51519us
0A5D D9FA       273       djnz R1, $-4 ; 22.51519us*222=4.998ms
0A5F            274       ; Now we can proceed with the configuration
0A5F 438780     275            orl     PCON,#0x80
0A62 759852     276            mov     SCON,#0x52
0A65 759B00     277            mov     BDRCON,#0x00
0A68 759AF4     278            mov     BRL,#BRG_VAL
0A6B 759B1E     279            mov     BDRCON,#0x1E ; BDRCON=BRR|TBCK|RBCK|SPD;
0A6E 22         280       ret
0A6F            281   
0A6F            282   INIT_SPI:
0A6F D282       283       setb MY_MISO    ; Make MISO an input pin
0A71 C281       284       clr MY_SCLK     ; For mode (0,0) SCLK is zero
0A73 22         285       ret
0A74            286   
0A74            287   ;-------------------------------------;
0A74            288   ; ISR for Timer 1.  Used to playback  ;
0A74            289   ; the WAV file stored in the SPI      ;
0A74            290   ; flash memory.                       ;
0A74            291   ;-------------------------------------;
0A74            292   Timer1_ISR:
0A74            293            ; The registers used in the ISR must be saved in the stack
0A74 C0E0       294            push acc
0A76 C0D0       295            push psw
0A78            296   
0A78            297            ; Check if the play counter is zero.  If so, stop playing sound.
0A78 E545       298            mov a, w+0
0A7A 4546       299            orl a, w+1
0A7C 4547       300            orl a, w+2
0A7E 601E       301            jz stop_playing
0A80            302            
0A80            303            ; Decrement play counter 'w'.  In this implementation 'w' is a 24-bit counter.
0A80 74FF       304            mov a, #0xff
0A82 1545       305            dec w+0
0A84 B54507     306            cjne a, w+0, keep_playing
0A87 1546       307            dec w+1
0A89 B54602     308            cjne a, w+1, keep_playing
0A8C 1547       309            dec w+2
0A8E            310            
0A8E            311   keep_playing:
0A8E D2A6       312            setb SPEAKER
0A90 120433     313            lcall Send_SPI ; Read the next byte from the SPI Flash...
0A93 F580       314            mov P0, a ; WARNING: Remove this if not using an external DAC to use the pins of P0 as GPIO
0A95 2480       315            add a, #0x80
0A97 F5AD       316            mov DADH, a ; Output to DAC. DAC output is pin P2.3
0A99 43A440     317            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
0A9C 800E       318            sjmp Timer1_ISR_Done
0A9E            319   
0A9E            320   stop_playing:
0A9E C28E       321            clr TR1 ; Stop timer 1
0AA0 D2A5       322            setb FLASH_CE  ; Disable SPI Flash
0AA2 C2A6       323            clr SPEAKER ; Turn off speaker.  Removes hissing noise when not playing sound.
0AA4 75AD80     324            mov DADH, #0x80 ; middle of range
0AA7 43A440     325            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
0AAA            326   
0AAA            327       ; Timer 1 has finished playing a sound. Set a flag so the main program knows         
0AAA D204       328       setb play_done
0AAC            329   
0AAC            330   Timer1_ISR_Done:
0AAC D0D0       331            pop psw
0AAE D0E0       332            pop acc
0AB0 32         333            reti
0AB1            334   
0AB1            335   ;---------------------------------;
0AB1            336   ; ISR for timer 2                 ;
0AB1            337   ;---------------------------------;
0AB1            338   Timer2_ISR:
0AB1 C2CF       339            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
0AB3            340            ;cpl P1.0 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
0AB3            341            
0AB3            342            ; The two registers used in the ISR must be saved in the stack
0AB3 C0E0       343            push acc
0AB5 C0D0       344            push psw
0AB7            345            
0AB7            346            ; Increment the 16-bit one mili second counter
0AB7 0530       347            inc Count1ms+0    ; Increment the low 8-bits first
0AB9 E530       348            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0ABB 7002       349            jnz Inc_Done
0ABD 0531       350            inc Count1ms+1
0ABF            351   
0ABF            352   Inc_Done:
0ABF            353            ; Check if 1 second has passed
0ABF E530       354            mov a, Count1ms+0
0AC1 B4E818     355            cjne a, #low(1000), Timer2_ISR_done ; Warning: this instruction high_low_flags the carry flag!
0AC4 E531       356            mov a, Count1ms+1
0AC6 B40313     357            cjne a, #high(1000), Timer2_ISR_done
0AC9            358            
0AC9            359            ; 1 second has passed. Set a flag so the main program knows
0AC9 D200       360            setb seconds_flag ; Let the main program know 1 second has passed
0ACB E4         361            clr a
0ACC F530       362            mov Count1ms+0, a
0ACE F531       363            mov Count1ms+1, a
0AD0 0532       364       inc Count5s
0AD2            365   
0AD2            366   Inc_Done_a:
0AD2            367       ; Check if 5 seconds has passed
0AD2 E532       368       mov a, Count5s
0AD4 B40505     369       cjne a, #5, Timer2_ISR_done
0AD7            370       
0AD7            371       ; 5 seconds have passed. Set a flag so the main program knows
0AD7 D201       372       setb five_seconds_flag
0AD9 753200     373       mov Count5s, #0
0ADC            374   
0ADC            375   Timer2_ISR_done:
0ADC D0D0       376            pop psw
0ADE D0E0       377            pop acc
0AE0 32         378            reti
0AE1            379   
0AE1            380   ;---------------------------------;
0AE1            381   ; Main Program                    ;
0AE1            382   ;---------------------------------;
0AE1            383   MainProgram:
0AE1 75817F     384       mov SP, #7FH ; Set the stack pointer to the begining of idata
0AE4 D2AF       385       setb EA   ; Enable Global interrupts
0AE6 75E600     386       mov P0M0, #0
0AE9 75E700     387       mov P0M1, #0
0AEC 75D600     388       mov P1M0, #0
0AEF 75D700     389       mov P1M1, #0
0AF2 75CE00     390       mov P2M0, #0
0AF5 75CF00     391       mov P2M1, #0
0AF8            392       
0AF8 120A57     393       lcall InitSerialPort
0AFB 120A6F     394       lcall INIT_SPI
0AFE 120088     395       lcall LCD_4BIT
0B01 120A01     396       lcall Timer1_Init
0B04 120A3C     397       lcall Timer2_Init
0B07            398   
0B07 D292       399       setb STATE_bit0
0B09 D293       400       setb STATE_bit1
0B0B D294       401       setb STATE_bit2
0B0D D295       402       setb STATE_STABLE
0B0F            403   
0B0F C290       404       clr TEMP_OK
0B11 C291       405       clr TEMP_50
0B13 C296       406       clr OVEN_CTL_PIN
0B15            407   
0B15 C200       408       clr seconds_flag
0B17 C201       409       clr five_seconds_flag
0B19 C203       410       clr hold_button
0B1B D204       411       setb play_done
0B1D            412   
0B1D 753000     413       mov count1ms+0, #0
0B20 753000     414       mov count1ms+0, #0
0B23            415       ; defualt soaktemp = 150
0B23 754096     416       mov soaktemp, #0x96
0B26            417       ; default reflowtemp = 240
0B26 7541F0     418       mov reflowtemp, #0xF0
0B29            419   
0B29 020E25     420       ljmp setup ; jump to setup after reset
0B2C            421   
0B2C            422   ;-------------------------------------------------- STATE 0 --------------------------------------------------
0B2C            423   ; idle state, reflow oven is off
0B2C            424   State_0:
0B2C            425       ; check state
0B2C 3095FD     426       jnb STATE_STABLE, $ ; wait for state to be stable
0B2F 120497     427       lcall read_state 
0B32 B40051     428       cjne a, #0, State_1
0B35            429   
0B35            430       ; turn off the oven
0B35 C296       431       clr OVEN_CTL_PIN
0B37            432   
0B37            433       ; temperature is set, TEMP_OK = 1
0B37 D290       434       setb TEMP_OK
0B39            435   
0B39            436       ; display "OVEN OFF" message
0B39 C0E0       437            push acc
0B3B 7401       437            mov a, #1
0B3D 14         437            dec a
0B3E 1200BD     437            lcall ?Set_Cursor_2 ; Select column and row
0B41 D0E0       437            pop acc
0B43 C083       438            push dph
0B45 C082       438            push dpl
0B47 C0E0       438            push acc
0B49 900909     438            mov dptr, #OVEN_OFF
0B4C 1200B2     438            lcall ?Send_Constant_String
0B4F D0E0       438            pop acc
0B51 D082       438            pop dpl
0B53 D083       438            pop dph
0B55            439   
0B55            440       ;lcall Sound_Idle; [sound saying the current state "Idle"]
0B55 781E       441       mov r0, #30
0B57 12050A     442       lcall Play_Sound_Using_Index
0B5A            443       ; if BOOT_BUTTON is being pressed, wait for release
0B5A 30C5FD     444       jnb BOOT_BUTTON, $
0B5D            445       
0B5D            446   Idle:
0B5D            447       ; check state
0B5D 3095FD     448       jnb STATE_STABLE, $ ; wait for state to be stable
0B60 120497     449       lcall read_state
0B63 B40020     450       cjne a, #0, State_1
0B66            451       ; Read tempurature every second
0B66 30000B     452       jnb seconds_flag, Idle_a
0B69 C200       453       clr seconds_flag
0B6B 1203F7     454       lcall Read_ADC
0B6E 1204A3     455       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0B71 120396     456       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
0B74            457   Idle_a:
0B74            458       ; if BOOT_BUTTON is pressed, jump to setup
0B74 20C5E6     459       jb BOOT_BUTTON, Idle
0B77 C002       460            push AR2
0B79 7A32       460            mov R2, #50
0B7B 120039     460            lcall ?Wait_Milli_Seconds
0B7E D002       460            pop AR2 ; debounce time
0B80 20C5DA     461       jb BOOT_BUTTON, Idle
0B83 020E25     462       ljmp setup
0B86            463   
0B86            464   ;-------------------------------------------------- STATE 1 --------------------------------------------------
0B86            465   ; heating to soak temperature
0B86            466   State_1:
0B86            467       ; check state
0B86 3095FD     468       jnb STATE_STABLE, $ ; wait for state to be stable
0B89 120497     469       lcall read_state
0B8C B40160     470       cjne a, #1, Jump_State_2 ; offset was too large for cjne to jump to State_2, branching to a ljmp
0B8F            471   
0B8F            472       ; turn on the oven
0B8F D296       473       setb OVEN_CTL_PIN
0B91            474   
0B91            475       ; display target temperature
0B91 C0E0       476            push acc
0B93 7401       476            mov a, #1
0B95 14         476            dec a
0B96 1200BD     476            lcall ?Set_Cursor_2 ; Select column and row
0B99 D0E0       476            pop acc
0B9B C083       477            push dph
0B9D C082       477            push dpl
0B9F C0E0       477            push acc
0BA1 9008F8     477            mov dptr, #TARGET_TEMP
0BA4 1200B2     477            lcall ?Send_Constant_String
0BA7 D0E0       477            pop acc
0BA9 D082       477            pop dpl
0BAB D083       477            pop dph
0BAD 753300     478            mov x+0, #low (0 % 0x10000) 
0BB0 753400     478            mov x+1, #high(0 % 0x10000) 
0BB3 753500     478            mov x+2, #low (0 / 0x10000) 
0BB6 753600     478            mov x+3, #high(0 / 0x10000) 
0BB9 854033     479       mov x+0, soaktemp
0BBC 1200DA     480       lcall hex2bcd
0BBF C0E0       481            push acc
0BC1 7408       481            mov a, #8
0BC3 14         481            dec a
0BC4 1200BD     481            lcall ?Set_Cursor_2 ; Select column and row
0BC7 D0E0       481            pop acc
0BC9 C000       481            push ar0
0BCB A83C       481            mov r0, bcd+1
0BCD 1200C4     481            lcall ?Display_BCD
0BD0 D000       481            pop ar0
0BD2 C000       481            push ar0
0BD4 A83B       481            mov r0, bcd+0
0BD6 1200C4     481            lcall ?Display_BCD
0BD9 D000       481            pop ar0
0BDB            481            ; Replace all the zeros to the left with blanks
0BDB C0E0       481            push acc
0BDD 7408       481            mov a, #8
0BDF 14         481            dec a
0BE0 1200BD     481            lcall ?Set_Cursor_2 ; Select column and row
0BE3 D0E0       481            pop acc
0BE5 12034A     481            lcall replace_zeros
0BE8            482   
0BE8            483       ; [Sound for saying the current state "Heating to soak"]
0BE8 781E       484       mov r0, #30
0BEA 12050A     485       lcall Play_Sound_Using_Index
0BED 8003       486       sjmp Heating_To_Soak
0BEF            487   
0BEF            488   Jump_State_2:   ; ljmp to state 2
0BEF 020C3A     489       ljmp State_2
0BF2            490   
0BF2            491   Heating_To_Soak:
0BF2            492       ; read temperature every second
0BF2 30000B     493       jnb seconds_flag, Heating_To_Soak_a
0BF5 C200       494       clr seconds_flag
0BF7 1203F7     495       lcall Read_ADC
0BFA 1204A3     496       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0BFD 120396     497       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
0C00            498   Heating_To_Soak_a:
0C00            499       ; play sound every five seconds
0C00 300102     500       jnb five_seconds_flag, Heating_To_Soak_b
0C03 C201       501       clr five_seconds_flag
0C05            502       ; lcall Play_Temp_Sound; [function to play sound here]
0C05            503   Heating_To_Soak_b:
0C05            504       ; if temperature >= reflow temperature, TEMP_OK = 0
0C05            505       ; else 1
0C05 753300     506            mov x+0, #low (0 % 0x10000) 
0C08 753400     506            mov x+1, #high(0 % 0x10000) 
0C0B 753500     506            mov x+2, #low (0 / 0x10000) 
0C0E 753600     506            mov x+3, #high(0 / 0x10000) 
0C11 753700     507            mov y+0, #low (0 % 0x10000) 
0C14 753800     507            mov y+1, #high(0 % 0x10000) 
0C17 753900     507            mov y+2, #low (0 / 0x10000) 
0C1A 753A00     507            mov y+3, #high(0 / 0x10000) 
0C1D 854433     508       mov x+0, temp_reading
0C20 854037     509       mov y+0, soaktemp
0C23 120240     510       lcall x_gteq_y
0C26 300202     511       jnb mf, Heating_To_Soak_c
0C29 C290       512       clr TEMP_OK
0C2B            513   Heating_To_Soak_c:
0C2B            514       ; if temperature >= 50, TEMP_50 = 1
0C2B            515       ; else, TEMP_50 = 0
0C2B 1204E3     516       lcall Check_50
0C2E            517       ; check state
0C2E 3095FD     518       jnb STATE_STABLE, $ ; wait for state to be stable
0C31 120497     519       lcall read_state
0C34 B40103     520       cjne a, #1, State_2
0C37 020BF2     521       ljmp Heating_To_Soak
0C3A            522   
0C3A            523   ;-------------------------------------------------- STATE 2 --------------------------------------------------
0C3A            524   ; soak temperature has been reached, temperature is held for [soaktime]
0C3A            525   State_2:
0C3A            526       ; check state
0C3A 3095FD     527       jnb STATE_STABLE, $ ; wait for state to be stable
0C3D 120497     528       lcall read_state
0C40 B4024D     529       cjne a, #2, State_3
0C43            530   
0C43            531       ; [sound saying the current state "Soaking"]
0C43 781F       532       mov r0,#31
0C45 12050A     533       lcall Play_Sound_Using_Index
0C48            534   
0C48            535   Soaking:
0C48            536       ; read temperature every second
0C48 30000B     537       jnb seconds_flag, Soaking_a
0C4B C200       538       clr seconds_flag
0C4D 1203F7     539       lcall Read_ADC
0C50 1204A3     540       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0C53 120396     541       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
0C56            542   Soaking_a:
0C56            543       ; play sound every five seconds
0C56 300102     544       jnb five_seconds_flag, Soaking_b
0C59 C201       545       clr five_seconds_flag
0C5B            546       ;lcall Play_Temp_Sound; [function to play sound here]
0C5B            547   Soaking_b:
0C5B            548       ; compare temperature to soaktemp
0C5B 753300     549            mov x+0, #low (0 % 0x10000) 
0C5E 753400     549            mov x+1, #high(0 % 0x10000) 
0C61 753500     549            mov x+2, #low (0 / 0x10000) 
0C64 753600     549            mov x+3, #high(0 / 0x10000) 
0C67 753700     550            mov y+0, #low (0 % 0x10000) 
0C6A 753800     550            mov y+1, #high(0 % 0x10000) 
0C6D 753900     550            mov y+2, #low (0 / 0x10000) 
0C70 753A00     550            mov y+3, #high(0 / 0x10000) 
0C73 854433     551       mov x+0, temp_reading
0C76 854037     552       mov y+0, soaktemp
0C79 120240     553       lcall x_gteq_y
0C7C            554       ; if temperature >= soaktemp, turn off the oven
0C7C 20020D     555       jb mf, Soaking_too_high
0C7F            556       ; else, turn on the oven
0C7F D296       557       setb OVEN_CTL_PIN
0C81            558   Soaking_d:
0C81            559       ; check state
0C81 3095FD     560       jnb STATE_STABLE, $ ; wait for state to be stable
0C84 120497     561       lcall read_state
0C87 B40206     562       cjne a, #2, State_3
0C8A 80BC       563       sjmp Soaking
0C8C            564   
0C8C            565   Soaking_too_high:
0C8C C296       566       clr OVEN_CTL_PIN ; turn off the oven
0C8E 80F1       567       sjmp Soaking_d
0C90            568   
0C90            569   ;-------------------------------------------------- STATE 3 --------------------------------------------------
0C90            570   ; heating to reflow temperature
0C90            571   State_3:
0C90            572       ; check state
0C90 3095FD     573       jnb STATE_STABLE, $ ; wait for state to be stable
0C93 120497     574       lcall read_state
0C96 B40344     575       cjne a, #3, Jump_State_4
0C99            576   
0C99            577       ; turn on the oven
0C99 D296       578       setb OVEN_CTL_PIN
0C9B            579   
0C9B            580       ; display target temperature
0C9B 753300     581            mov x+0, #low (0 % 0x10000) 
0C9E 753400     581            mov x+1, #high(0 % 0x10000) 
0CA1 753500     581            mov x+2, #low (0 / 0x10000) 
0CA4 753600     581            mov x+3, #high(0 / 0x10000) 
0CA7 854133     582       mov x+0, reflowtemp
0CAA 1200DA     583       lcall hex2bcd
0CAD C0E0       584            push acc
0CAF 7408       584            mov a, #8
0CB1 14         584            dec a
0CB2 1200BD     584            lcall ?Set_Cursor_2 ; Select column and row
0CB5 D0E0       584            pop acc
0CB7 C000       584            push ar0
0CB9 A83C       584            mov r0, bcd+1
0CBB 1200C4     584            lcall ?Display_BCD
0CBE D000       584            pop ar0
0CC0 C000       584            push ar0
0CC2 A83B       584            mov r0, bcd+0
0CC4 1200C4     584            lcall ?Display_BCD
0CC7 D000       584            pop ar0
0CC9            584            ; Replace all the zeros to the left with blanks
0CC9 C0E0       584            push acc
0CCB 7408       584            mov a, #8
0CCD 14         584            dec a
0CCE 1200BD     584            lcall ?Set_Cursor_2 ; Select column and row
0CD1 D0E0       584            pop acc
0CD3 12034A     584            lcall replace_zeros
0CD6            585   
0CD6            586       ; [sound saying the current state "Heating to reflow"]
0CD6 7820       587       mov r0,#32
0CD8 12050A     588       lcall Play_Sound_Using_Index
0CDB 8003       589       sjmp Heating_To_Reflow
0CDD            590   
0CDD            591   Jump_State_4:   ; ljmp to state 4
0CDD 020D24     592       ljmp State_4
0CE0            593   
0CE0            594   Heating_To_Reflow:
0CE0            595       ; read temperature every second
0CE0 30000B     596       jnb seconds_flag, Heating_To_Reflow_a
0CE3 C200       597       clr seconds_flag
0CE5 1203F7     598       lcall Read_ADC
0CE8 1204A3     599       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0CEB 120396     600       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
0CEE            601   Heating_To_Reflow_a:
0CEE            602       ; play sound every five seconds
0CEE 300102     603       jnb five_seconds_flag, Heating_To_Reflow_b
0CF1 C201       604       clr five_seconds_flag
0CF3            605       ;lcall Play_Temp_Sound ; [function to play sound here]
0CF3            606   Heating_To_Reflow_b:
0CF3 753300     607            mov x+0, #low (0 % 0x10000) 
0CF6 753400     607            mov x+1, #high(0 % 0x10000) 
0CF9 753500     607            mov x+2, #low (0 / 0x10000) 
0CFC 753600     607            mov x+3, #high(0 / 0x10000) 
0CFF 753700     608            mov y+0, #low (0 % 0x10000) 
0D02 753800     608            mov y+1, #high(0 % 0x10000) 
0D05 753900     608            mov y+2, #low (0 / 0x10000) 
0D08 753A00     608            mov y+3, #high(0 / 0x10000) 
0D0B 854433     609       mov x+0, temp_reading
0D0E 854137     610       mov y+0, reflowtemp
0D11 120240     611       lcall x_gteq_y
0D14 300202     612       jnb mf, Heating_To_Reflow_c
0D17 D290       613       setb TEMP_OK
0D19            614   Heating_To_Reflow_c:
0D19            615       ; check state
0D19 3095FD     616       jnb STATE_STABLE, $ ; wait for state to be stable
0D1C 120497     617       lcall read_state
0D1F B40302     618       cjne a, #3, State_4
0D22 80BC       619       sjmp Heating_To_Reflow
0D24            620   
0D24            621   ;-------------------------------------------------- STATE 4 --------------------------------------------------
0D24            622   ; reflow temperature has been reached, temperature is held for [reflowtime]
0D24            623   State_4:
0D24            624       ; check state
0D24 3095FD     625       jnb STATE_STABLE, $ ; wait for state to be stable
0D27 120497     626       lcall read_state
0D2A B40450     627       cjne a, #4, State_5
0D2D            628   
0D2D            629       ;[Sound saying the current state "Reflowing"]
0D2D 7821       630       mov r0, #33
0D2F 02050A     631       ljmp Play_Sound_Using_Index 
0D32            632   
0D32            633   Reflowing:
0D32            634       ; read temperature every second
0D32 30000B     635       jnb seconds_flag, Reflowing_a
0D35 C200       636       clr seconds_flag
0D37 1203F7     637       lcall Read_ADC
0D3A 1204A3     638       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0D3D 120396     639       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
0D40            640   Reflowing_a:
0D40            641       ; play sound every five seconds
0D40 300102     642       jnb five_seconds_flag, Reflowing_b
0D43 C201       643       clr five_seconds_flag
0D45            644       ;lcall Play_Temp_Sound ; [function to play sound here]
0D45            645   Reflowing_b:
0D45 753300     646            mov x+0, #low (0 % 0x10000) 
0D48 753400     646            mov x+1, #high(0 % 0x10000) 
0D4B 753500     646            mov x+2, #low (0 / 0x10000) 
0D4E 753600     646            mov x+3, #high(0 / 0x10000) 
0D51 753700     647            mov y+0, #low (0 % 0x10000) 
0D54 753800     647            mov y+1, #high(0 % 0x10000) 
0D57 753900     647            mov y+2, #low (0 / 0x10000) 
0D5A 753A00     647            mov y+3, #high(0 / 0x10000) 
0D5D 854433     648       mov x+0, temp_reading
0D60 854137     649       mov y+0, reflowtemp
0D63 120240     650       lcall x_gteq_y
0D66 200210     651       jb mf, Reflowing_too_high
0D69            652       ; if temperature >= soaktemp, turn off the oven
0D69 20020D     653       jb mf, Reflowing_too_high
0D6C            654       ; else, turn on the oven
0D6C D296       655       setb OVEN_CTL_PIN
0D6E            656   Reflowing_d:
0D6E            657       ; check state
0D6E 3095FD     658       jnb STATE_STABLE, $ ; wait for state to be stable
0D71 120497     659       lcall read_state
0D74 B40406     660       cjne a, #4, State_5
0D77 80B9       661       sjmp Reflowing
0D79            662   
0D79            663   Reflowing_too_high:
0D79 C296       664       clr OVEN_CTL_PIN ; turn off the oven
0D7B 80F1       665       sjmp Reflowing_d
0D7D            666   
0D7D            667   ;------------------------------------------------- STATE 5/6 -------------------------------------------------
0D7D            668   ; cooldown/error
0D7D            669   State_5:
0D7D            670       ; check state
0D7D 3095FD     671       jnb STATE_STABLE, $ ; wait for state to be stable
0D80 120497     672       lcall read_state
0D83 B40525     673       cjne a, #5, State_6
0D86            674   
0D86            675       ; turn off the oven
0D86 C296       676       clr OVEN_CTL_PIN
0D88            677   
0D88            678       ; display "OVEN OFF" message
0D88 C0E0       679            push acc
0D8A 7401       679            mov a, #1
0D8C 14         679            dec a
0D8D 1200BD     679            lcall ?Set_Cursor_2 ; Select column and row
0D90 D0E0       679            pop acc
0D92 C083       680            push dph
0D94 C082       680            push dpl
0D96 C0E0       680            push acc
0D98 900909     680            mov dptr, #OVEN_OFF
0D9B 1200B2     680            lcall ?Send_Constant_String
0D9E D0E0       680            pop acc
0DA0 D082       680            pop dpl
0DA2 D083       680            pop dph
0DA4            681   
0DA4 7822       682       mov r0, #34 ; moves the index for cooling into r0
0DA6 12050A     683       lcall Play_Sound_Using_Index; [Sound saying current state "Cooldown"]
0DA9 8031       684       sjmp Cooldown
0DAB            685   
0DAB            686   State_6:
0DAB            687       ; check state
0DAB 3095FD     688       jnb STATE_STABLE, $ ; wait for state to be stable
0DAE 120497     689       lcall read_state
0DB1 B40625     690       cjne a, #6, Jump_State_0
0DB4            691   
0DB4            692       ; turn off the oven
0DB4 C296       693       clr OVEN_CTL_PIN
0DB6            694   
0DB6            695       ; display "OVEN OFF" message
0DB6 C0E0       696            push acc
0DB8 7401       696            mov a, #1
0DBA 14         696            dec a
0DBB 1200BD     696            lcall ?Set_Cursor_2 ; Select column and row
0DBE D0E0       696            pop acc
0DC0 C083       697            push dph
0DC2 C082       697            push dpl
0DC4 C0E0       697            push acc
0DC6 900909     697            mov dptr, #OVEN_OFF
0DC9 1200B2     697            lcall ?Send_Constant_String
0DCC D0E0       697            pop acc
0DCE D082       697            pop dpl
0DD0 D083       697            pop dph
0DD2            698   
0DD2 7823       699       mov r0, #35 ; moves the index for error into r0
0DD4 12050A     700       lcall Play_Sound_Using_Index; [Sound saying current state "Error"]
0DD7 8003       701       sjmp Cooldown
0DD9            702   
0DD9            703   Jump_State_0:
0DD9 020B2C     704       ljmp State_0
0DDC            705   
0DDC            706   Cooldown:
0DDC            707       ; read temperature every second
0DDC 30000B     708       jnb seconds_flag, Cooldown_a
0DDF C200       709       clr seconds_flag
0DE1 1203F7     710       lcall Read_ADC
0DE4 1204A3     711       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0DE7 120396     712       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
0DEA            713   Cooldown_a:
0DEA            714       ; play sound every five seconds
0DEA 300102     715       jnb five_seconds_flag, Cooldown_b
0DED C201       716       clr five_seconds_flag
0DEF            717       ;lcall Play_Temp_Sound ; [function to play sound here] NOT FUNCTIONAL
0DEF            718   Cooldown_b:
0DEF 753300     719            mov x+0, #low (0 % 0x10000) 
0DF2 753400     719            mov x+1, #high(0 % 0x10000) 
0DF5 753500     719            mov x+2, #low (0 / 0x10000) 
0DF8 753600     719            mov x+3, #high(0 / 0x10000) 
0DFB 753732     720            mov y+0, #low (50 % 0x10000) 
0DFE 753800     720            mov y+1, #high(50 % 0x10000) 
0E01 753900     720            mov y+2, #low (50 / 0x10000) 
0E04 753A00     720            mov y+3, #high(50 / 0x10000) 
0E07 854433     721       mov x+0, temp_reading
0E0A 120240     722       lcall x_gteq_y
0E0D 200202     723       jb mf, Cooldown_c
0E10 C291       724       clr TEMP_50
0E12            725   Cooldown_c:
0E12            726       ; if temperature >= 50, TEMP_50 = 1
0E12            727       ; else, TEMP_50 = 0
0E12 1204E3     728       lcall Check_50
0E15            729       ; check state
0E15 3095FD     730       jnb STATE_STABLE, $ ; wait for state to be stable
0E18 120497     731       lcall read_state
0E1B B40502     732       cjne a, #5, Cooldown_d
0E1E 80BC       733       sjmp Cooldown
0E20            734   Cooldown_d:
0E20 B406B6     735       cjne a, #6, Jump_State_0
0E23 80B7       736       sjmp Cooldown
0E25            737   
0E25            738   ;-------------------------------------------------- SETUP ----------------------------------------------------
0E25            739   setup:
0E25 C2CA       740       clr TR2
0E27            741       ; temperature not set, TEMP_OK = 0
0E27 C290       742       clr TEMP_OK
0E29            743       ; prints "SOAK" left aligned in the top row
0E29 C0E0       744            push acc
0E2B 7401       744            mov a, #1
0E2D 14         744            dec a
0E2E 1200BF     744            lcall ?Set_Cursor_1 ; Select column and row
0E31 D0E0       744            pop acc
0E33 C083       745            push dph
0E35 C082       745            push dpl
0E37 C0E0       745            push acc
0E39 9008C5     745            mov dptr, #SOAK_TEMP
0E3C 1200B2     745            lcall ?Send_Constant_String
0E3F D0E0       745            pop acc
0E41 D082       745            pop dpl
0E43 D083       745            pop dph
0E45            746       ; prints "REFLOW" left aligned in the bottom row
0E45 C0E0       747            push acc
0E47 7401       747            mov a, #1
0E49 14         747            dec a
0E4A 1200BD     747            lcall ?Set_Cursor_2 ; Select column and row
0E4D D0E0       747            pop acc
0E4F C083       748            push dph
0E51 C082       748            push dpl
0E53 C0E0       748            push acc
0E55 9008D6     748            mov dptr, #REFLOW_TEMP
0E58 1200B2     748            lcall ?Send_Constant_String
0E5B D0E0       748            pop acc
0E5D D082       748            pop dpl
0E5F D083       748            pop dph
0E61            749       ; display soak temperature
0E61 753300     750            mov x+0, #low (0 % 0x10000) 
0E64 753400     750            mov x+1, #high(0 % 0x10000) 
0E67 753500     750            mov x+2, #low (0 / 0x10000) 
0E6A 753600     750            mov x+3, #high(0 / 0x10000) 
0E6D 854033     751       mov x+0, soaktemp
0E70 1200DA     752       lcall hex2bcd
0E73 C0E0       753            push acc
0E75 7408       753            mov a, #8
0E77 14         753            dec a
0E78 1200BF     753            lcall ?Set_Cursor_1 ; Select column and row
0E7B D0E0       753            pop acc
0E7D C000       753            push ar0
0E7F A83C       753            mov r0, bcd+1
0E81 1200C4     753            lcall ?Display_BCD
0E84 D000       753            pop ar0
0E86 C000       753            push ar0
0E88 A83B       753            mov r0, bcd+0
0E8A 1200C4     753            lcall ?Display_BCD
0E8D D000       753            pop ar0
0E8F            753            ; Replace all the zeros to the left with blanks
0E8F C0E0       753            push acc
0E91 7408       753            mov a, #8
0E93 14         753            dec a
0E94 1200BF     753            lcall ?Set_Cursor_1 ; Select column and row
0E97 D0E0       753            pop acc
0E99 12034A     753            lcall replace_zeros
0E9C            754       ; display reflow temperature
0E9C 854133     755       mov x+0, reflowtemp+0
0E9F 1200DA     756       lcall hex2bcd
0EA2 C0E0       757            push acc
0EA4 7408       757            mov a, #8
0EA6 14         757            dec a
0EA7 1200BD     757            lcall ?Set_Cursor_2 ; Select column and row
0EAA D0E0       757            pop acc
0EAC C000       757            push ar0
0EAE A83C       757            mov r0, bcd+1
0EB0 1200C4     757            lcall ?Display_BCD
0EB3 D000       757            pop ar0
0EB5 C000       757            push ar0
0EB7 A83B       757            mov r0, bcd+0
0EB9 1200C4     757            lcall ?Display_BCD
0EBC D000       757            pop ar0
0EBE            757            ; Replace all the zeros to the left with blanks
0EBE C0E0       757            push acc
0EC0 7408       757            mov a, #8
0EC2 14         757            dec a
0EC3 1200BD     757            lcall ?Set_Cursor_2 ; Select column and row
0EC6 D0E0       757            pop acc
0EC8 12034A     757            lcall replace_zeros
0ECB            758   
0ECB            759   ; set soak temperature
0ECB            760   ; MAX: 240
0ECB            761   ; MIN: 120
0ECB            762   set_soak_temp:
0ECB 854033     763       mov x+0, soaktemp
0ECE C0E0       764            push acc
0ED0 740B       764            mov a, #11
0ED2 14         764            dec a
0ED3 1200BF     764            lcall ?Set_Cursor_1 ; Select column and row
0ED6 D0E0       764            pop acc
0ED8 C0E0       765            push acc
0EDA 740E       765            mov a, #0xE
0EDC 120083     765            lcall ?WriteCommand
0EDF D0E0       765            pop acc
0EE1            766       ; if BOOT_BUTTON is being pressed, wait for release
0EE1 30C5FD     767       jnb BOOT_BUTTON, $
0EE4            768   set_soak_temp_a:
0EE4            769       ; if UP is pressed, increment temperature
0EE4 208705     770       jb UP, set_soak_temp_b
0EE7 E533       771       mov a, x+0
0EE9            772       ; if temperature < 240, increment temperature
0EE9 B4F032     773       cjne a, #0xF0, set_soak_temp_d
0EEC            774   set_soak_temp_b:
0EEC            775       ; if DOWN button is pressed, increment temperature  
0EEC 208505     776       jb DOWN, set_soak_temp_c
0EEF E533       777       mov a, x+0
0EF1            778       ; if temperature > 120, decrement temperature
0EF1 B4783A     779       cjne a, #0x78, set_soak_temp_e
0EF4            780   set_soak_temp_c:  
0EF4 C203       781       clr hold_button
0EF6 C0E0       782            push acc
0EF8 740B       782            mov a, #11
0EFA 14         782            dec a
0EFB 1200BF     782            lcall ?Set_Cursor_1 ; Select column and row
0EFE D0E0       782            pop acc
0F00 C0E0       783            push acc
0F02 740E       783            mov a, #0xE
0F04 120083     783            lcall ?WriteCommand
0F07 D0E0       783            pop acc
0F09            784       ; if BOOT_BUTTON is pressed, set reflow time
0F09 20C5D8     785       jb BOOT_BUTTON, set_soak_temp_a
0F0C C002       786            push AR2
0F0E 7A32       786            mov R2, #50
0F10 120039     786            lcall ?Wait_Milli_Seconds
0F13 D002       786            pop AR2 ; debounce time
0F15 20C5CC     787       jb BOOT_BUTTON, set_soak_temp_a
0F18 853340     788       mov soaktemp, x+0
0F1B 020FD6     789       ljmp set_reflow_temp
0F1E            790   set_soak_temp_d:
0F1E            791       ; increment soak temperature
0F1E C0E0       792            push acc
0F20 740C       792            mov a, #0xC
0F22 120083     792            lcall ?WriteCommand
0F25 D0E0       792            pop acc
0F27 0533       793       inc x+0
0F29            794       ; if UP is held, increment temperature rapidly
0F29 200312     795       jb hold_button, set_soak_temp_f
0F2C 804D       796       sjmp set_soak_temp_g
0F2E            797   set_soak_temp_e:
0F2E            798       ; decrement soak temperature
0F2E C0E0       799            push acc
0F30 740C       799            mov a, #0xC
0F32 120083     799            lcall ?WriteCommand
0F35 D0E0       799            pop acc
0F37 1533       800       dec x+0
0F39            801       ; if DOWN button is held, decrement temperature rapidly
0F39 200302     802       jb hold_button, set_soak_temp_f
0F3C 803D       803       sjmp set_soak_temp_g
0F3E            804   set_soak_temp_f:
0F3E            805       ; update display and wait 25 ms
0F3E 1200DA     806       lcall hex2bcd
0F41 C0E0       807            push acc
0F43 7408       807            mov a, #8
0F45 14         807            dec a
0F46 1200BF     807            lcall ?Set_Cursor_1 ; Select column and row
0F49 D0E0       807            pop acc
0F4B C000       807            push ar0
0F4D A83C       807            mov r0, bcd+1
0F4F 1200C4     807            lcall ?Display_BCD
0F52 D000       807            pop ar0
0F54 C000       807            push ar0
0F56 A83B       807            mov r0, bcd+0
0F58 1200C4     807            lcall ?Display_BCD
0F5B D000       807            pop ar0
0F5D            807            ; Replace all the zeros to the left with blanks
0F5D C0E0       807            push acc
0F5F 7408       807            mov a, #8
0F61 14         807            dec a
0F62 1200BF     807            lcall ?Set_Cursor_1 ; Select column and row
0F65 D0E0       807            pop acc
0F67 12034A     807            lcall replace_zeros
0F6A C002       808            push AR2
0F6C 7A19       808            mov R2, #25
0F6E 120039     808            lcall ?Wait_Milli_Seconds
0F71 D002       808            pop AR2
0F73            809       ; if UP is held, increment temperature
0F73 308756     810       jnb UP, set_soak_temp_h
0F76            811       ; if DOWN button is held, decrement temperature
0F76 308558     812       jnb DOWN, set_soak_temp_i
0F79 C203       813       clr hold_button
0F7B            814   set_soak_temp_g:
0F7B            815       ; update display and wait 250 ms
0F7B 1200DA     816       lcall hex2bcd
0F7E C0E0       817            push acc
0F80 7408       817            mov a, #8
0F82 14         817            dec a
0F83 1200BF     817            lcall ?Set_Cursor_1 ; Select column and row
0F86 D0E0       817            pop acc
0F88 C000       817            push ar0
0F8A A83C       817            mov r0, bcd+1
0F8C 1200C4     817            lcall ?Display_BCD
0F8F D000       817            pop ar0
0F91 C000       817            push ar0
0F93 A83B       817            mov r0, bcd+0
0F95 1200C4     817            lcall ?Display_BCD
0F98 D000       817            pop ar0
0F9A            817            ; Replace all the zeros to the left with blanks
0F9A C0E0       817            push acc
0F9C 7408       817            mov a, #8
0F9E 14         817            dec a
0F9F 1200BF     817            lcall ?Set_Cursor_1 ; Select column and row
0FA2 D0E0       817            pop acc
0FA4 12034A     817            lcall replace_zeros
0FA7 C0E0       818            push acc
0FA9 740B       818            mov a, #11
0FAB 14         818            dec a
0FAC 1200BF     818            lcall ?Set_Cursor_1 ; Select column and row
0FAF D0E0       818            pop acc
0FB1 C0E0       819            push acc
0FB3 740E       819            mov a, #0xE
0FB5 120083     819            lcall ?WriteCommand
0FB8 D0E0       819            pop acc
0FBA C002       820            push AR2
0FBC 7AFA       820            mov R2, #250
0FBE 120039     820            lcall ?Wait_Milli_Seconds
0FC1 D002       820            pop AR2
0FC3            821       ; if UP is held, set a flag so the program knows
0FC3 308706     822       jnb UP, set_soak_temp_h
0FC6            823       ; if DOWN button is held, set a flag so the program knows 
0FC6 308508     824       jnb DOWN, set_soak_temp_i
0FC9 020EE4     825       ljmp set_soak_temp_a
0FCC            826   set_soak_temp_h:
0FCC D203       827       setb hold_button
0FCE 020EE4     828       ljmp set_soak_temp_a
0FD1            829   set_soak_temp_i:
0FD1 D203       830       setb hold_button
0FD3 020EEC     831       ljmp set_soak_temp_b
0FD6            832   
0FD6            833   ; set reflow temp
0FD6            834   ; MAX: 240
0FD6            835   ; MIN: 120
0FD6            836   set_reflow_temp:
0FD6 854133     837       mov x+0, reflowtemp
0FD9 C0E0       838            push acc
0FDB 740B       838            mov a, #11
0FDD 14         838            dec a
0FDE 1200BD     838            lcall ?Set_Cursor_2 ; Select column and row
0FE1 D0E0       838            pop acc
0FE3 C0E0       839            push acc
0FE5 740E       839            mov a, #0xE
0FE7 120083     839            lcall ?WriteCommand
0FEA D0E0       839            pop acc
0FEC            840       ; if BOOT_BUTTON is being pressed, wait for release
0FEC 30C5FD     841       jnb BOOT_BUTTON, $
0FEF            842   set_reflow_temp_a:
0FEF            843       ; if UP is pressed, increment temperature
0FEF 208705     844       jb UP, set_reflow_temp_b
0FF2 E533       845       mov a, x+0
0FF4            846       ; if temperature < 240, increment temperature
0FF4 B4F032     847       cjne a, #0xF0, set_reflow_temp_d
0FF7            848   set_reflow_temp_b:
0FF7            849       ; if DOWN button is pressed, increment temperature  
0FF7 208505     850       jb DOWN, set_reflow_temp_c
0FFA E533       851       mov a, x+0
0FFC            852       ; if temperature > 0, decrement temperature
0FFC B4783A     853       cjne a, #0x78, set_reflow_temp_e
0FFF            854   set_reflow_temp_c:  
0FFF C203       855       clr hold_button
1001 C0E0       856            push acc
1003 740B       856            mov a, #11
1005 14         856            dec a
1006 1200BD     856            lcall ?Set_Cursor_2 ; Select column and row
1009 D0E0       856            pop acc
100B C0E0       857            push acc
100D 740E       857            mov a, #0xE
100F 120083     857            lcall ?WriteCommand
1012 D0E0       857            pop acc
1014            858       ; if BOOT_BUTTON is pressed, set reflow time
1014 20C5D8     859       jb BOOT_BUTTON, set_reflow_temp_a
1017 C002       860            push AR2
1019 7A32       860            mov R2, #50
101B 120039     860            lcall ?Wait_Milli_Seconds
101E D002       860            pop AR2 ; debounce time
1020 20C5CC     861       jb BOOT_BUTTON, set_reflow_temp_a
1023 853341     862       mov reflowtemp, x+0
1026 0210E1     863       ljmp setup_done
1029            864   set_reflow_temp_d:
1029            865       ; increment reflow temperature
1029 C0E0       866            push acc
102B 740C       866            mov a, #0xC
102D 120083     866            lcall ?WriteCommand
1030 D0E0       866            pop acc
1032 0533       867       inc x+0
1034            868       ; if UP is held, increment temperature rapidly
1034 200312     869       jb hold_button, set_reflow_temp_f
1037 804D       870       sjmp set_reflow_temp_g
1039            871   set_reflow_temp_e:
1039            872       ; decrement reflow temperature
1039 C0E0       873            push acc
103B 740C       873            mov a, #0xC
103D 120083     873            lcall ?WriteCommand
1040 D0E0       873            pop acc
1042 1533       874       dec x+0
1044            875       ; if DOWN button is held, decrement temperature rapidly
1044 200302     876       jb hold_button, set_reflow_temp_f
1047 803D       877       sjmp set_reflow_temp_g
1049            878   set_reflow_temp_f:
1049            879       ; update display and wait 25 ms
1049 1200DA     880       lcall hex2bcd
104C C0E0       881            push acc
104E 7408       881            mov a, #8
1050 14         881            dec a
1051 1200BD     881            lcall ?Set_Cursor_2 ; Select column and row
1054 D0E0       881            pop acc
1056 C000       881            push ar0
1058 A83C       881            mov r0, bcd+1
105A 1200C4     881            lcall ?Display_BCD
105D D000       881            pop ar0
105F C000       881            push ar0
1061 A83B       881            mov r0, bcd+0
1063 1200C4     881            lcall ?Display_BCD
1066 D000       881            pop ar0
1068            881            ; Replace all the zeros to the left with blanks
1068 C0E0       881            push acc
106A 7408       881            mov a, #8
106C 14         881            dec a
106D 1200BD     881            lcall ?Set_Cursor_2 ; Select column and row
1070 D0E0       881            pop acc
1072 12034A     881            lcall replace_zeros
1075 C002       882            push AR2
1077 7A19       882            mov R2, #25
1079 120039     882            lcall ?Wait_Milli_Seconds
107C D002       882            pop AR2
107E            883       ; if UP is held, increment temperature
107E 308756     884       jnb UP, set_reflow_temp_h
1081            885       ; if DOWN button is held, decrement temperature
1081 308558     886       jnb DOWN, set_reflow_temp_i
1084 C203       887       clr hold_button
1086            888   set_reflow_temp_g:
1086            889       ; update display and wait 250 ms
1086 1200DA     890       lcall hex2bcd
1089 C0E0       891            push acc
108B 7408       891            mov a, #8
108D 14         891            dec a
108E 1200BD     891            lcall ?Set_Cursor_2 ; Select column and row
1091 D0E0       891            pop acc
1093 C000       891            push ar0
1095 A83C       891            mov r0, bcd+1
1097 1200C4     891            lcall ?Display_BCD
109A D000       891            pop ar0
109C C000       891            push ar0
109E A83B       891            mov r0, bcd+0
10A0 1200C4     891            lcall ?Display_BCD
10A3 D000       891            pop ar0
10A5            891            ; Replace all the zeros to the left with blanks
10A5 C0E0       891            push acc
10A7 7408       891            mov a, #8
10A9 14         891            dec a
10AA 1200BD     891            lcall ?Set_Cursor_2 ; Select column and row
10AD D0E0       891            pop acc
10AF 12034A     891            lcall replace_zeros
10B2 C0E0       892            push acc
10B4 740B       892            mov a, #11
10B6 14         892            dec a
10B7 1200BD     892            lcall ?Set_Cursor_2 ; Select column and row
10BA D0E0       892            pop acc
10BC C0E0       893            push acc
10BE 740E       893            mov a, #0xE
10C0 120083     893            lcall ?WriteCommand
10C3 D0E0       893            pop acc
10C5 C002       894            push AR2
10C7 7AFA       894            mov R2, #250
10C9 120039     894            lcall ?Wait_Milli_Seconds
10CC D002       894            pop AR2
10CE            895       ; if UP is held, set a flag so the program knows
10CE 308706     896       jnb UP, set_reflow_temp_h
10D1            897       ; if DOWN button is held, set a flag so the program knows 
10D1 308508     898       jnb DOWN, set_reflow_temp_i
10D4 020FEF     899       ljmp set_reflow_temp_a
10D7            900   set_reflow_temp_h:
10D7 D203       901       setb hold_button
10D9 020FEF     902       ljmp set_reflow_temp_a
10DC            903   set_reflow_temp_i:
10DC D203       904       setb hold_button
10DE 020FF7     905       ljmp set_reflow_temp_b
10E1            906   
10E1            907   setup_done:
10E1 C0E0       908            push acc
10E3 740C       908            mov a, #0xC
10E5 120083     908            lcall ?WriteCommand
10E8 D0E0       908            pop acc
10EA            909       ; display current temperature
10EA C0E0       910            push acc
10EC 7401       910            mov a, #1
10EE 14         910            dec a
10EF 1200BF     910            lcall ?Set_Cursor_1 ; Select column and row
10F2 D0E0       910            pop acc
10F4 C083       911            push dph
10F6 C082       911            push dpl
10F8 C0E0       911            push acc
10FA 9008E7     911            mov dptr, #CURRENT_TEMP
10FD 1200B2     911            lcall ?Send_Constant_String
1100 D0E0       911            pop acc
1102 D082       911            pop dpl
1104 D083       911            pop dph
1106 1203F7     912       lcall Read_ADC
1109 C0E0       913            push acc
110B 7408       913            mov a, #8
110D 14         913            dec a
110E 1200BF     913            lcall ?Set_Cursor_1 ; Select column and row
1111 D0E0       913            pop acc
1113 C000       913            push ar0
1115 A83C       913            mov r0, bcd+1
1117 1200C4     913            lcall ?Display_BCD
111A D000       913            pop ar0
111C C000       913            push ar0
111E A83B       913            mov r0, bcd+0
1120 1200C4     913            lcall ?Display_BCD
1123 D000       913            pop ar0
1125            913            ; Replace all the zeros to the left with blanks
1125 C0E0       913            push acc
1127 7408       913            mov a, #8
1129 14         913            dec a
112A 1200BF     913            lcall ?Set_Cursor_1 ; Select column and row
112D D0E0       913            pop acc
112F 12034A     913            lcall replace_zeros
1132 D2CA       914       setb TR2
1134 020B2C     915       ljmp State_0
