                  2   $LIST
0000              4   
0000              5   CLK  EQU 22118400
0000              6   BAUD equ 115200
0000              7   BRG_VAL equ (0x100-(CLK/(16*BAUD)))
0000              8   
0000              9   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             10   TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
0000             11   TIMER1_RATE    EQU 22050     ; 22050Hz is the sampling rate of the wav file we are playing
0000             12   TIMER1_RELOAD  EQU 0x10000-(CLK/TIMER1_RATE)
0000             13   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             14   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             15   
0000             16   ; The pins used for SPI
0000             17   FLASH_CE  EQU  P2.5
0000             18   PIN_TWO_FOUR   EQU  P2.4 
0000             19   PIN_TWO_ONE   EQU  P2.1
0000             20   PIN_TWO_ZERO   EQU  P2.0 
0000             21   
0000             22   BOOT_BUTTON   equ P4.5
0000             23   SPEAKER  EQU P2.6 ; Used with a MOSFET to turn off speaker when not in use
0000             24   UP            equ P0.7
0000             25   DOWN               equ P0.5
0000             26   ; Input 3 bit binary state from TIME/FSM MCU
0000             27   STATE_bit0      equ P1.2
0000             28   STATE_bit1      equ P1.3
0000             29   STATE_bit2      equ P1.4
0000             30   STATE_STABLE    equ P1.5
0000             31   ; Outputs to Time/FSM MCU
0000             32    TEMP_OK        equ P1.0
0000             33    TEMP_50        equ P1.1
0000             34    OVEN_CTL_PIN   equ P1.6
0000             35   
0000             36    ; Commands supported by the SPI flash memory according to the datasheet
0000             37   WRITE_ENABLE     EQU 0x06  ; Address:0 Dummy:0 Num:0
0000             38   WRITE_DISABLE    EQU 0x04  ; Address:0 Dummy:0 Num:0
0000             39   READ_STATUS      EQU 0x05  ; Address:0 Dummy:0 Num:1 to infinite
0000             40   READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
0000             41   READ_SILICON_ID  EQU 0xab  ; Address:0 Dummy:3 Num:1 to infinite
0000             42   FAST_READ        EQU 0x0b  ; Address:3 Dummy:1 Num:1 to infinite
0000             43   WRITE_STATUS     EQU 0x01  ; Address:0 Dummy:0 Num:1
0000             44   WRITE_BYTES      EQU 0x02  ; Address:3 Dummy:0 Num:1 to 256
0000             45   ERASE_ALL        EQU 0xc7  ; Address:0 Dummy:0 Num:0
0000             46   ERASE_BLOCK      EQU 0xd8  ; Address:3 Dummy:0 Num:0
0000             47   READ_DEVICE_ID   EQU 0x9f  ; Address:0 Dummy:2 Num:1 to infinite
0000             48   
0000             49   org 0000H
0000 020735      50      ljmp MainProgram
0003             51   
0003             52   ; External interrupt 0 vector (not used in this code)
0003             53   org 0x0003
0003 32          54            reti
0004             55   
0004             56   ; Timer/Counter 0 overflow interrupt vector (not used in this code)
000B             57   org 0x000B
000B 32          58            reti
000C             59   
000C             60   ; External interrupt 1 vector (not used in this code)
0013             61   org 0x0013
0013 32          62            reti
0014             63   
0014             64   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             65   org 0x001B
001B 020601      66            ljmp Timer1_ISR
001E             67   
001E             68   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             69   org 0x0023 
0023 32          70            reti
0024             71            
0024             72   ; Timer/Counter 2 overflow interrupt vector
002B             73   org 0x002B
002B 020705      74            ljmp Timer2_ISR
002E             75   
0030             76   DSEG at 30H
0030             77   Count1ms:           ds 2
0032             78   Count5s:            ds 1 
0033             79   x:                  ds 4 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file
0037             80   y:                  ds 4 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file
003B             81   bcd:                ds 5 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file 
0040             82   soaktemp:           ds 1
0041             83   reflowtemp:         ds 1
0042             84   volt_reading:       ds 2 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file
0044             85   temp_reading:       ds 1
0045             86   fsm_state:          ds 1 
0046             87   w:                               ds 3 ; 24-bit play counter.  Decremented in Timer 1 ISR.
0049             88   temp_sound_state:     ds 1 
004A             89   
004A             90   
0000             91   BSEG
0000             92   seconds_flag:       dbit 1
0001             93   five_seconds_flag:  dbit 1
0002             94   mf:                 dbit 1 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file
0003             95   hold_button:        dbit 1
0004             96   sound_flag:         dbit 1
0005             97   playstart_flag:      dbit 1 ;used in play temp
0006             98   PLAYDONE: dbit 1
0007             99   
002E            100   CSEG
002E            101   ; These ’EQU’ must match the wiring between the microcontroller and ADC (used in the INC file)
002E            102   CE_ADC  EQU P0.4
002E            103   MY_MOSI EQU P0.3
002E            104   MY_MISO EQU P0.2
002E            105   MY_SCLK EQU P0.1
002E            106   ; These 'equ' must match the hardware wiring
002E            107   ; They are used by 'LCD_4bit.inc'
002E            108   LCD_RS equ P3.2
002E            109   ; LCD_RW equ Px.x ; Always grounded
002E            110   LCD_E  equ P3.3
002E            111   LCD_D4 equ P3.4
002E            112   LCD_D5 equ P3.5
002E            113   LCD_D6 equ P3.6
002E            114   LCD_D7 equ P3.7
002E            115   
                553   $LIST
                119   $LIST
04B1            121   
04B1            122   ;                   1234567890123456
04B1 536F616B   123   SOAK_TEMP:      db 'Soak:   xxx', 0xDF, 'C   ', 0
     3A202020
     787878DF
     43202020
     00
04C2 5265666C   124   REFLOW_TEMP:    db 'Reflow: xxx', 0xDF, 'C   ', 0
     6F773A20
     787878DF
     43202020
     00
04D3 54656D70   125   CURRENT_TEMP:   db 'Temp:   xxx', 0xDF, 'C   ', 0
     3A202020
     787878DF
     43202020
     00
04E4 54617267   126   TARGET_TEMP:    db 'Target: xxx', 0xDF, 'C   ', 0
     65743A20
     787878DF
     43202020
     00
04F5 4F56454E   127   OVEN_OFF:       db 'OVEN OFF        ', 0
     204F4646
     20202020
     20202020
     00
0506            128   
0506            129   
0506            130   
0506            131   ; Approximate index of sounds in file 'nsound.wav'
0506            132   sound_index:
0506 003937     133       db 0x00, 0x39, 0x37 ; 0 number1
0509 00E45D     134       db 0x00, 0xe4, 0x5d ; 1 2
050C 019444     135       db 0x01, 0x94, 0x44 ; 2 3
050F 024B4A     136       db 0x02, 0x4b, 0x4a ; 3 4
0512 02F671     137       db 0x02, 0xf6, 0x71 ; 4 5
0515 039CD6     138       db 0x03, 0x9c, 0xd6 ; 5 6
0518 04433C     139       db 0x04, 0x43, 0x3c ; 6 7
051B 04FCA1     140       db 0x04, 0xfc, 0xa1 ; 7 8
051E 05A7C8     141       db 0x05, 0xa7, 0xc8 ; 8 9
0521 066132     142       db 0x06, 0x61, 0x32 ; 9 10
0524 0702D5     143       db 0x07, 0x02, 0xd5 ; 10 11
0527 07ADF9     144       db 0x07, 0xad, 0xf9 ; 11 12
052A 085DE1     145       db 0x08, 0x5d, 0xe1 ; 12 13
052D 09174A     146       db 0x09, 0x17, 0x4a ; 13 14
0530 09B68A     147       db 0x09, 0xb6, 0x8a ; 14 15
0533 0A5F50     148       db 0x0a, 0x5f, 0x50 ; 15 16
0536 0B0CD6     149       db 0x0b, 0x0c, 0xd6 ; 16 17
0539 0BBA5C     150       db 0x0b, 0xba, 0x5c ; 17 18
053C 0C6CA5     151       db 0x0c, 0x6c, 0xa5 ; 18 19
053F 0CFDA3     152       db 0x0c, 0xfd, 0xa3 ; 19 20
0542 0DBBCC     153       db 0x0d, 0xbb, 0xcc ; 20 30
0545 0E6953     154       db 0x0e, 0x69, 0x53 ; 21 40
0548 0F03D2     155       db 0x0f, 0x03, 0xd2 ; 22 50
054B 0FC1FB     156       db 0x0f, 0xc1, 0xfb ; 23 60
054E 106AC2     157       db 0x10, 0x6a, 0xc2 ; 24 70
0551 1115E8     158       db 0x11, 0x15, 0xe8 ; 25 80
0554 11CA8E     159       db 0x11, 0xca, 0x8e ; 26 90
0557 127812     160       db 0x12, 0x78, 0x12 ; 27 100
055A 1327FB     161       db 0x13, 0x27, 0xfb ; 28 200
055D 13D0C0     162       db 0x13, 0xd0, 0xc0 ; 29 idle
0560 147725     163       db 0x14, 0x77, 0x25 ; 30 
0563 153551     164       db 0x15, 0x35, 0x51 ; 31 
0566 15CD72     165       db 0x15, 0xcd, 0x72 ; 32 
0569 168B8B     166       db 0x16, 0x8b, 0x8b ; 33 
056C 172ADE     167       db 0x17, 0x2a, 0xde ; 34 
056F 17D605     168       db 0x17, 0xd6, 0x05 ; 35 
0572 187ECC     169       db 0x18, 0x7e, 0xcc 
0575            170   
0575            171   ; Size of each sound in 'sound_index'
0575            172   Size_sound:
0575 00AB26     173       db 0x00, 0xab, 0x26 ; 0 
0578 00AFE7     174       db 0x00, 0xaf, 0xe7 ; 1 
057B 00B706     175       db 0x00, 0xb7, 0x06 ; 2 
057E 00AB27     176       db 0x00, 0xab, 0x27 ; 3 
0581 00A665     177       db 0x00, 0xa6, 0x65 ; 4 
0584 00A666     178       db 0x00, 0xa6, 0x66 ; 5 
0587 00B965     179       db 0x00, 0xb9, 0x65 ; 6 
058A 00AB27     180       db 0x00, 0xab, 0x27 ; 7 
058D 00B96A     181       db 0x00, 0xb9, 0x6a ; 8 
0590 00A1A3     182       db 0x00, 0xa1, 0xa3 ; 9 
0593 00AB24     183       db 0x00, 0xab, 0x24 ; 10 
0596 00AFE8     184       db 0x00, 0xaf, 0xe8 ; 11 
0599 00B969     185       db 0x00, 0xb9, 0x69 ; 12 
059C 009F40     186       db 0x00, 0x9f, 0x40 ; 13 
059F 00A8C6     187       db 0x00, 0xa8, 0xc6 ; 14 
05A2 00AD86     188       db 0x00, 0xad, 0x86 ; 15 
05A5 00AD86     189       db 0x00, 0xad, 0x86 ; 16 
05A8 00B249     190       db 0x00, 0xb2, 0x49 ; 17 
05AB 0090FE     191       db 0x00, 0x90, 0xfe ; 18 
05AE 00BE29     192       db 0x00, 0xbe, 0x29 ; 19 
05B1 00AD87     193       db 0x00, 0xad, 0x87 ; 20 
05B4 009A7F     194       db 0x00, 0x9a, 0x7f ; 21 
05B7 00BE29     195       db 0x00, 0xbe, 0x29 ; 22 
05BA 00A8C7     196       db 0x00, 0xa8, 0xc7 ; 23 
05BD 00AB26     197       db 0x00, 0xab, 0x26 ; 24 
05C0 00B4A6     198       db 0x00, 0xb4, 0xa6 ; 25 
05C3 00AD84     199       db 0x00, 0xad, 0x84 ; 26 
05C6 00AFE9     200       db 0x00, 0xaf, 0xe9 ; 27 
05C9 00A8C5     201       db 0x00, 0xa8, 0xc5 ; 28 
05CC 00A665     202       db 0x00, 0xa6, 0x65 ; 29 
05CF 00BE2C     203       db 0x00, 0xbe, 0x2c ; 30 
05D2 009821     204       db 0x00, 0x98, 0x21 ; 31 
05D5 00BE19     205       db 0x00, 0xbe, 0x19 ; 32 
05D8 009F53     206       db 0x00, 0x9f, 0x53 ; 33 
05DB 00AB27     207       db 0x00, 0xab, 0x27 ; 34 
05DE 00A8C7     208       db 0x00, 0xa8, 0xc7 ; 35 
05E1            209   
05E1            210   
05E1            211   
05E1            212   
05E1            213   
05E1            214   
05E1            215   
05E1            216   
05E1            217   ;---------------------------------;
05E1            218   ; Routine to initialize the ISR   ;
05E1            219   ; for timer 0                     ;
05E1            220   ;---------------------------------;
05E1            221   Timer0_Init:
05E1 E589       222            mov a, TMOD
05E3 54F0       223            anl a, #0xf0 ; 11110000 Clear the bits for timer 0
05E5 4401       224            orl a, #0x01 ; 00000001 Configure timer 0 as 16-timer
05E7 F589       225            mov TMOD, a
05E9 758CEA     226            mov TH0, #high(TIMER0_RELOAD)
05EC 758AE8     227            mov TL0, #low(TIMER0_RELOAD)
05EF            228            ; Set autoreload value
05EF 75F4EA     229            mov RH0, #high(TIMER0_RELOAD)
05F2 75F2E8     230            mov RL0, #low(TIMER0_RELOAD)
05F5            231            ; Enable the timer and interrupts
05F5 D2A9       232       setb ET0  ; Enable timer 0 interrupt
05F7 D28C       233       setb TR0  ; Start timer 0
05F9 22         234            ret
05FA            235            
05FA            236   ;---------------------------------;
05FA            237   ; ISR for timer 0                 ;
05FA            238   ;---------------------------------;
05FA            239   Timer0_ISR:
05FA 200401     240            jb sound_flag, Start_Chirping
05FD 32         241            reti
05FE            242   
05FE            243   Start_Chirping:
05FE B2A6       244            cpl SPEAKER 
0600 32         245            reti
0601            246   ;-------------------------------------;
0601            247   ; ISR for Timer 1.  Used to playback  ;
0601            248   ; the WAV file stored in the SPI      ;
0601            249   ; flash memory.                       ;
0601            250   ;-------------------------------------;
0601            251   Timer1_ISR:
0601            252            ; The registers used in the ISR must be saved in the stack
0601 C0E0       253            push acc
0603 C0D0       254            push psw
0605            255            
0605            256            ; Check if the play counter is zero.  If so, stop playing sound.
0605 E546       257            mov a, w+0
0607 4547       258            orl a, w+1
0609 4548       259            orl a, w+2
060B 601E       260            jz stop_playing
060D            261            
060D            262            ; Decrement play counter 'w'.  In this implementation 'w' is a 24-bit counter.
060D 74FF       263            mov a, #0xff
060F 1546       264            dec w+0
0611 B54607     265            cjne a, w+0, keep_playing
0614 1547       266            dec w+1
0616 B54702     267            cjne a, w+1, keep_playing
0619 1548       268            dec w+2
061B            269            
061B            270   keep_playing:
061B D2A6       271            setb SPEAKER
061D 12063C     272            lcall Send_SPI ; Read the next byte from the SPI Flash...
0620 F580       273            mov P0, a ; WARNING: Remove this if not using an external DAC to use the pins of P0 as GPIO
0622 2480       274            add a, #0x80
0624 F5AD       275            mov DADH, a ; Output to DAC. DAC output is pin P2.3
0626 43A440     276            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
0629 800C       277            sjmp Timer1_ISR_Done
062B            278   
062B            279   stop_playing:
062B C28E       280            clr TR1 ; Stop timer 1
062D D2A5       281            setb FLASH_CE  ; Disable SPI Flash
062F C2A6       282            clr SPEAKER ; Turn off speaker.  Removes hissing noise when not playing sound.
0631 75AD80     283            mov DADH, #0x80 ; middle of range
0634 43A440     284            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
0637            285   
0637            286   Timer1_ISR_Done:         
0637 D0D0       287            pop psw
0639 D0E0       288            pop acc
063B 32         289            reti
063C            290   
063C            291   ;---------------------------------;
063C            292   ; Sends AND receives a byte via   ;
063C            293   ; SPI.                            ;
063C            294   ;---------------------------------;
063C            295   Send_SPI:
                296   	SPIBIT MAC
                297   	    ; Send/Receive bit %0
                298   		rlc a
                299   		mov PIN_TWO_FOUR, c
                300   		setb PIN_TWO_ZERO
                301   		mov c, PIN_TWO_ONE
                302   		clr PIN_TWO_ZERO
                303   		mov acc.0, c
                304   	ENDMAC
063C            305            
063C            306                ; Send/Receive bit 7
063C 33         306                    rlc a
063D 92A4       306                    mov PIN_TWO_FOUR, c
063F D2A0       306                    setb PIN_TWO_ZERO
0641 A2A1       306                    mov c, PIN_TWO_ONE
0643 C2A0       306                    clr PIN_TWO_ZERO
0645 92E0       306                    mov acc.0, c
0647            307                ; Send/Receive bit 6
0647 33         307                    rlc a
0648 92A4       307                    mov PIN_TWO_FOUR, c
064A D2A0       307                    setb PIN_TWO_ZERO
064C A2A1       307                    mov c, PIN_TWO_ONE
064E C2A0       307                    clr PIN_TWO_ZERO
0650 92E0       307                    mov acc.0, c
0652            308                ; Send/Receive bit 5
0652 33         308                    rlc a
0653 92A4       308                    mov PIN_TWO_FOUR, c
0655 D2A0       308                    setb PIN_TWO_ZERO
0657 A2A1       308                    mov c, PIN_TWO_ONE
0659 C2A0       308                    clr PIN_TWO_ZERO
065B 92E0       308                    mov acc.0, c
065D            309                ; Send/Receive bit 4
065D 33         309                    rlc a
065E 92A4       309                    mov PIN_TWO_FOUR, c
0660 D2A0       309                    setb PIN_TWO_ZERO
0662 A2A1       309                    mov c, PIN_TWO_ONE
0664 C2A0       309                    clr PIN_TWO_ZERO
0666 92E0       309                    mov acc.0, c
0668            310                ; Send/Receive bit 3
0668 33         310                    rlc a
0669 92A4       310                    mov PIN_TWO_FOUR, c
066B D2A0       310                    setb PIN_TWO_ZERO
066D A2A1       310                    mov c, PIN_TWO_ONE
066F C2A0       310                    clr PIN_TWO_ZERO
0671 92E0       310                    mov acc.0, c
0673            311                ; Send/Receive bit 2
0673 33         311                    rlc a
0674 92A4       311                    mov PIN_TWO_FOUR, c
0676 D2A0       311                    setb PIN_TWO_ZERO
0678 A2A1       311                    mov c, PIN_TWO_ONE
067A C2A0       311                    clr PIN_TWO_ZERO
067C 92E0       311                    mov acc.0, c
067E            312                ; Send/Receive bit 1
067E 33         312                    rlc a
067F 92A4       312                    mov PIN_TWO_FOUR, c
0681 D2A0       312                    setb PIN_TWO_ZERO
0683 A2A1       312                    mov c, PIN_TWO_ONE
0685 C2A0       312                    clr PIN_TWO_ZERO
0687 92E0       312                    mov acc.0, c
0689            313                ; Send/Receive bit 0
0689 33         313                    rlc a
068A 92A4       313                    mov PIN_TWO_FOUR, c
068C D2A0       313                    setb PIN_TWO_ZERO
068E A2A1       313                    mov c, PIN_TWO_ONE
0690 C2A0       313                    clr PIN_TWO_ZERO
0692 92E0       313                    mov acc.0, c
0694            314   
0694 22         315            ret
0695            316   
0695            317   Timer1_Init:
0695            318            ; Configure P2.0, P2.4, P2.5 as open drain outputs
0695 43CE31     319            orl P2M0, #0b_0011_0001
0698 43CF31     320            orl P2M1, #0b_0011_0001
069B D2A1       321            setb PIN_TWO_ONE  ; Configured as input
069D D2A5       322            setb FLASH_CE ; CS=1 for SPI flash memory
069F C2A0       323            clr PIN_TWO_ZERO   ; Rest state of SCLK=0
06A1 C2A6       324            clr SPEAKER   ; Turn off speaker.
06A3            325            
06A3            326            ; Configure timer 1
06A3 53890F     327            anl     TMOD, #0x0F ; Clear the bits of timer 1 in TMOD
06A6 438910     328            orl     TMOD, #0x10 ; Set timer 1 in 16-bit timer mode.  Don't change the bits of timer 0
06A9 758DFC     329            mov TH1, #high(TIMER1_RELOAD)
06AC 758B15     330            mov TL1, #low(TIMER1_RELOAD)
06AF            331            ; Set autoreload value
06AF 75F5FC     332            mov RH1, #high(TIMER1_RELOAD)
06B2 75F315     333            mov RL1, #low(TIMER1_RELOAD)
06B5            334   
06B5            335            ; Enable the timer and interrupts
06B5 D2AB       336       setb ET1  ; Enable timer 1 interrupt
06B7            337            ; setb TR1 ; Timer 1 is only enabled to play stored sound
06B7            338   
06B7            339            ; Configure the DAC.  The DAC output we are using is P2.3, but P2.2 is also reserved.
06B7 75A5A0     340            mov DADI, #0b_1010_0000 ; ACON=1
06BA 75A43A     341            mov DADC, #0b_0011_1010 ; Enabled, DAC mode, Left adjusted, CLK/4
06BD 75AD80     342            mov DADH, #0x80 ; Middle of scale
06C0 75AC00     343            mov DADL, #0
06C3 43A440     344            orl DADC, #0b_0100_0000 ; Start DAC by GO/BSY=1
06C6            345   
06C6            346   check_DAC_init:
06C6 E5A4       347            mov a, DADC
06C8 20E6FB     348            jb acc.6, check_DAC_init ; Wait for DAC to finish
06CB D2AF       349            setb EA ; Enable interrupts
06CD            350   
06CD            351   ;---------------------------------;
06CD            352   ; Routine to initialize the ISR   ;
06CD            353   ; for timer 2                     ;
06CD            354   ;---------------------------------;
06CD            355   Timer2_Init:
06CD 75C800     356            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
06D0 75CDA9     357            mov TH2, #high(TIMER2_RELOAD)
06D3 75CC9A     358            mov TL2, #low(TIMER2_RELOAD)
06D6            359            ; Set the reload value
06D6 75CBA9     360            mov RCAP2H, #high(TIMER2_RELOAD)
06D9 75CA9A     361            mov RCAP2L, #low(TIMER2_RELOAD)
06DC            362            ; Init one millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
06DC E4         363            clr a
06DD F530       364            mov Count1ms+0, a
06DF F531       365            mov Count1ms+1, a
06E1            366       ; Init five second interrupt counter
06E1 F532       367       mov Count5s, a
06E3            368            ; Enable the timer and interrupts
06E3 D2AD       369       setb ET2  ; Enable timer 2 interrupt
06E5 D2CA       370       setb TR2  ; Enable timer 2
06E7 22         371            ret
06E8            372   
06E8            373   ; Configure the serial port and baud rate
06E8            374   InitSerialPort:
06E8            375       ; Since the reset button bounces, we need to wait a bit before
06E8            376       ; sending messages, otherwise we risk displaying gibberish!
06E8 79DE       377       mov R1, #222
06EA 78A6       378       mov R0, #166
06EC D8FE       379       djnz R0, $   ; 3 cycles->3*45.21123ns*166=22.51519us
06EE D9FA       380       djnz R1, $-4 ; 22.51519us*222=4.998ms
06F0            381       ; Now we can proceed with the configuration
06F0 438780     382            orl     PCON,#0x80
06F3 759852     383            mov     SCON,#0x52
06F6 759B00     384            mov     BDRCON,#0x00
06F9 759AF4     385            mov     BRL,#BRG_VAL
06FC 759B1E     386            mov     BDRCON,#0x1E ; BDRCON=BRR|TBCK|RBCK|SPD;
06FF 22         387       ret
0700            388   
0700            389   INIT_SPI:
0700 D282       390       setb MY_MISO    ; Make MISO an input pin
0702 C281       391       clr MY_SCLK     ; For mode (0,0) SCLK is zero
0704 22         392       ret
0705            393   
0705            394   ;---------------------------------;
0705            395   ; ISR for timer 2                 ;
0705            396   ;---------------------------------;
0705            397   Timer2_ISR:
0705 C2CF       398            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
0707            399            ;cpl P1.0 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
0707            400            
0707            401            ; The two registers used in the ISR must be saved in the stack
0707 C0E0       402            push acc
0709 C0D0       403            push psw
070B            404            
070B            405            ; Increment the 16-bit one mili second counter
070B 0530       406            inc Count1ms+0    ; Increment the low 8-bits first
070D E530       407            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
070F 7002       408            jnz Inc_Done
0711 0531       409            inc Count1ms+1
0713            410   
0713            411   Inc_Done:
0713            412            ; Check if 1 second has passed
0713 E530       413            mov a, Count1ms+0
0715 B4FA18     414            cjne a, #low(250), Timer2_ISR_done ; Warning: this instruction high_low_flags the carry flag!
0718 E531       415            mov a, Count1ms+1
071A B40013     416            cjne a, #high(250), Timer2_ISR_done
071D            417            
071D            418            ; 1 second has passed. Set a flag so the main program knows
071D D200       419            setb seconds_flag ; Let the main program know 1 second has passed
071F E4         420            clr a
0720 F530       421            mov Count1ms+0, a
0722 F531       422            mov Count1ms+1, a
0724 0532       423       inc Count5s
0726            424   
0726            425   Inc_Done_a:
0726            426       ; Check if 5 seconds has passed
0726 E532       427       mov a, Count5s
0728 B40505     428       cjne a, #5, Timer2_ISR_done
072B            429       
072B            430       ; 5 seconds have passed. Set a flag so the main program knows
072B D201       431       setb five_seconds_flag
072D 753200     432       mov Count5s, #0
0730            433   
0730            434   Timer2_ISR_done:
0730 D0D0       435            pop psw
0732 D0E0       436            pop acc
0734 32         437            reti
0735            438   
0735            439   ;---------------------------------;
0735            440   ; Main Program                    ;
0735            441   ;---------------------------------;
0735            442   MainProgram:
0735 75817F     443       mov SP, #7FH ; Set the stack pointer to the begining of idata
0738 D2AF       444       setb EA   ; Enable Global interrupts
073A 75E600     445       mov P0M0, #0
073D 75E700     446       mov P0M1, #0
0740 75D600     447       mov P1M0, #0
0743 75D700     448       mov P1M1, #0
0746 75CE00     449       mov P2M0, #0
0749 75CF00     450       mov P2M1, #0
074C            451       
074C 1206E8     452       lcall InitSerialPort
074F 120700     453       lcall INIT_SPI
0752 1205E1     454       lcall Timer0_Init
0755 120695     455       lcall Timer1_Init
0758            456   
0758 120088     457       lcall LCD_4BIT
075B 1206CD     458       lcall Timer2_Init
075E            459   
075E D292       460       setb STATE_bit0
0760 D293       461       setb STATE_bit1
0762 D294       462       setb STATE_bit2
0764 D295       463       setb STATE_STABLE
0766            464   
0766 C290       465       clr TEMP_OK
0768 C291       466       clr TEMP_50
076A C296       467       clr OVEN_CTL_PIN
076C            468   
076C C200       469       clr seconds_flag
076E C201       470       clr five_seconds_flag
0770 C203       471       clr hold_button
0772            472   
0772 753000     473       mov count1ms+0, #0
0775 753000     474       mov count1ms+0, #0
0778            475       ; defualt soaktemp = 150
0778 754096     476       mov soaktemp, #0x96
077B            477       ; default reflowtemp = 240
077B 7541F0     478       mov reflowtemp, #0xF0
077E            479   
077E 020A7D     480       ljmp setup ; jump to setup after reset
0781            481   
0781            482   ;-------------------------------------------------- STATE 0 --------------------------------------------------
0781            483   ; idle state, reflow oven is off
0781            484   State_0:
0781            485       ; check state
0781 3095FD     486       jnb STATE_STABLE, $ ; wait for state to be stable
0784 12043E     487       lcall read_state 
0787 B40051     488       cjne a, #0, State_1
078A            489   
078A            490       ; turn off the oven
078A C296       491       clr OVEN_CTL_PIN
078C            492   
078C            493       ; temperature is set, TEMP_OK = 1
078C D290       494       setb TEMP_OK
078E            495   
078E            496       ; display "OVEN OFF" message
078E C0E0       497            push acc
0790 7401       497            mov a, #1
0792 14         497            dec a
0793 1200BD     497            lcall ?Set_Cursor_2 ; Select column and row
0796 D0E0       497            pop acc
0798 C083       498            push dph
079A C082       498            push dpl
079C C0E0       498            push acc
079E 9004F5     498            mov dptr, #OVEN_OFF
07A1 1200B2     498            lcall ?Send_Constant_String
07A4 D0E0       498            pop acc
07A6 D082       498            pop dpl
07A8 D083       498            pop dph
07AA            499   
07AA            500       ;lcall Sound_Idle; [sound saying the current state "Idle"]
07AA 781D       501       mov r0,#29
07AC 120D8B     502       lcall Play_Sound_Using_Index
07AF            503       ; if BOOT_BUTTON is being pressed, wait for release
07AF 30C5FD     504       jnb BOOT_BUTTON, $
07B2            505       
07B2            506   Idle:
07B2            507       ; check state
07B2 3095FD     508       jnb STATE_STABLE, $ ; wait for state to be stable
07B5 12043E     509       lcall read_state
07B8 B40020     510       cjne a, #0, State_1
07BB            511       ; Read tempurature every second
07BB 30000B     512       jnb seconds_flag, Idle_a
07BE C200       513       clr seconds_flag
07C0 1203F7     514       lcall Read_ADC
07C3 12044A     515       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
07C6 120396     516       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
07C9            517   Idle_a:
07C9            518       ; if BOOT_BUTTON is pressed, jump to setup
07C9 20C5E6     519       jb BOOT_BUTTON, Idle
07CC C002       520            push AR2
07CE 7A32       520            mov R2, #50
07D0 120039     520            lcall ?Wait_Milli_Seconds
07D3 D002       520            pop AR2 ; debounce time
07D5 20C5DA     521       jb BOOT_BUTTON, Idle
07D8 020A7D     522       ljmp setup
07DB            523   
07DB            524   ;-------------------------------------------------- STATE 1 --------------------------------------------------
07DB            525   ; heating to soak temperature
07DB            526   State_1:
07DB            527       ; check state
07DB 3095FD     528       jnb STATE_STABLE, $ ; wait for state to be stable
07DE 12043E     529       lcall read_state
07E1 B4015E     530       cjne a, #1, Jump_State_2 ; offset was too large for cjne to jump to State_2, branching to a ljmp
07E4            531   
07E4            532       ; turn on the oven
07E4 D296       533       setb OVEN_CTL_PIN
07E6            534   
07E6            535       ; display target temperature
07E6 C0E0       536            push acc
07E8 7401       536            mov a, #1
07EA 14         536            dec a
07EB 1200BD     536            lcall ?Set_Cursor_2 ; Select column and row
07EE D0E0       536            pop acc
07F0 C083       537            push dph
07F2 C082       537            push dpl
07F4 C0E0       537            push acc
07F6 9004E4     537            mov dptr, #TARGET_TEMP
07F9 1200B2     537            lcall ?Send_Constant_String
07FC D0E0       537            pop acc
07FE D082       537            pop dpl
0800 D083       537            pop dph
0802 753300     538            mov x+0, #low (0 % 0x10000) 
0805 753400     538            mov x+1, #high(0 % 0x10000) 
0808 753500     538            mov x+2, #low (0 / 0x10000) 
080B 753600     538            mov x+3, #high(0 / 0x10000) 
080E 854033     539       mov x+0, soaktemp
0811 1200DA     540       lcall hex2bcd
0814 C0E0       541            push acc
0816 7408       541            mov a, #8
0818 14         541            dec a
0819 1200BD     541            lcall ?Set_Cursor_2 ; Select column and row
081C D0E0       541            pop acc
081E C000       541            push ar0
0820 A83C       541            mov r0, bcd+1
0822 1200C4     541            lcall ?Display_BCD
0825 D000       541            pop ar0
0827 C000       541            push ar0
0829 A83B       541            mov r0, bcd+0
082B 1200C4     541            lcall ?Display_BCD
082E D000       541            pop ar0
0830            541            ; Replace all the zeros to the left with blanks
0830 C0E0       541            push acc
0832 7408       541            mov a, #8
0834 14         541            dec a
0835 1200BD     541            lcall ?Set_Cursor_2 ; Select column and row
0838 D0E0       541            pop acc
083A 12034A     541            lcall replace_zeros
083D            542   
083D 020E62     543       ljmp Sound_Heating_To_Soak ; [Sound for saying the current state "Heating to soak"]
0840 8003       544       sjmp Heating_To_Soak
0842            545   
0842            546   Jump_State_2:   ; ljmp to state 2
0842 020890     547       ljmp State_2
0845            548   
0845            549   Heating_To_Soak:
0845            550       ; read temperature every second
0845 30000B     551       jnb seconds_flag, Heating_To_Soak_a
0848 C200       552       clr seconds_flag
084A 1203F7     553       lcall Read_ADC
084D 12044A     554       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0850 120396     555       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
0853            556   Heating_To_Soak_a:
0853            557       ; play sound every five seconds
0853 300105     558       jnb five_seconds_flag, Heating_To_Soak_b
0856 C201       559       clr five_seconds_flag
0858 020DE0     560       ljmp play_temp; [function to play sound here]
085B            561   Heating_To_Soak_b:
085B            562       ; if temperature >= reflow temperature, TEMP_OK = 0
085B            563       ; else 1
085B 753300     564            mov x+0, #low (0 % 0x10000) 
085E 753400     564            mov x+1, #high(0 % 0x10000) 
0861 753500     564            mov x+2, #low (0 / 0x10000) 
0864 753600     564            mov x+3, #high(0 / 0x10000) 
0867 753700     565            mov y+0, #low (0 % 0x10000) 
086A 753800     565            mov y+1, #high(0 % 0x10000) 
086D 753900     565            mov y+2, #low (0 / 0x10000) 
0870 753A00     565            mov y+3, #high(0 / 0x10000) 
0873 854433     566       mov x+0, temp_reading
0876 854037     567       mov y+0, soaktemp
0879 120240     568       lcall x_gteq_y
087C 300202     569       jnb mf, Heating_To_Soak_c
087F C290       570       clr TEMP_OK
0881            571   Heating_To_Soak_c:
0881            572       ; if temperature >= 50, TEMP_50 = 1
0881            573       ; else, TEMP_50 = 0
0881 12048A     574       lcall Check_50
0884            575       ; check state
0884 3095FD     576       jnb STATE_STABLE, $ ; wait for state to be stable
0887 12043E     577       lcall read_state
088A B40103     578       cjne a, #1, State_2
088D 020845     579       ljmp Heating_To_Soak
0890            580   
0890            581   ;-------------------------------------------------- STATE 2 --------------------------------------------------
0890            582   ; soak temperature has been reached, temperature is held for [soaktime]
0890            583   State_2:
0890            584       ; check state
0890 3095FD     585       jnb STATE_STABLE, $ ; wait for state to be stable
0893 12043E     586       lcall read_state
0896 B4024E     587       cjne a, #2, State_3
0899            588   
0899 020E91     589       ljmp Sound_Soaking; [sound saying the current state "Soaking"]
089C            590   
089C            591   Soaking:
089C            592       ; read temperature every second
089C 30000B     593       jnb seconds_flag, Soaking_a
089F C200       594       clr seconds_flag
08A1 1203F7     595       lcall Read_ADC
08A4 12044A     596       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
08A7 120396     597       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
08AA            598   Soaking_a:
08AA            599       ; play sound every five seconds
08AA 300105     600       jnb five_seconds_flag, Soaking_b
08AD C201       601       clr five_seconds_flag
08AF 020DE0     602       ljmp play_temp; [function to play sound here]
08B2            603   Soaking_b:
08B2            604       ; compare temperature to soaktemp
08B2 753300     605            mov x+0, #low (0 % 0x10000) 
08B5 753400     605            mov x+1, #high(0 % 0x10000) 
08B8 753500     605            mov x+2, #low (0 / 0x10000) 
08BB 753600     605            mov x+3, #high(0 / 0x10000) 
08BE 753700     606            mov y+0, #low (0 % 0x10000) 
08C1 753800     606            mov y+1, #high(0 % 0x10000) 
08C4 753900     606            mov y+2, #low (0 / 0x10000) 
08C7 753A00     606            mov y+3, #high(0 / 0x10000) 
08CA 854433     607       mov x+0, temp_reading
08CD 854037     608       mov y+0, soaktemp
08D0 120240     609       lcall x_gteq_y
08D3            610       ; if temperature >= soaktemp, turn off the oven
08D3 20020D     611       jb mf, Soaking_too_high
08D6            612       ; else, turn on the oven
08D6 D296       613       setb OVEN_CTL_PIN
08D8            614   Soaking_d:
08D8            615       ; check state
08D8 3095FD     616       jnb STATE_STABLE, $ ; wait for state to be stable
08DB 12043E     617       lcall read_state
08DE B40206     618       cjne a, #2, State_3
08E1 80B9       619       sjmp Soaking
08E3            620   
08E3            621   Soaking_too_high:
08E3 C296       622       clr OVEN_CTL_PIN ; turn off the oven
08E5 80F1       623       sjmp Soaking_d
08E7            624   
08E7            625   ;-------------------------------------------------- STATE 3 --------------------------------------------------
08E7            626   ; heating to reflow temperature
08E7            627   State_3:
08E7            628       ; check state
08E7 3095FD     629       jnb STATE_STABLE, $ ; wait for state to be stable
08EA 12043E     630       lcall read_state
08ED B40342     631       cjne a, #3, Jump_State_4
08F0            632   
08F0            633       ; turn on the oven
08F0 D296       634       setb OVEN_CTL_PIN
08F2            635   
08F2            636       ; display target temperature
08F2 753300     637            mov x+0, #low (0 % 0x10000) 
08F5 753400     637            mov x+1, #high(0 % 0x10000) 
08F8 753500     637            mov x+2, #low (0 / 0x10000) 
08FB 753600     637            mov x+3, #high(0 / 0x10000) 
08FE 854133     638       mov x+0, reflowtemp
0901 1200DA     639       lcall hex2bcd
0904 C0E0       640            push acc
0906 7408       640            mov a, #8
0908 14         640            dec a
0909 1200BD     640            lcall ?Set_Cursor_2 ; Select column and row
090C D0E0       640            pop acc
090E C000       640            push ar0
0910 A83C       640            mov r0, bcd+1
0912 1200C4     640            lcall ?Display_BCD
0915 D000       640            pop ar0
0917 C000       640            push ar0
0919 A83B       640            mov r0, bcd+0
091B 1200C4     640            lcall ?Display_BCD
091E D000       640            pop ar0
0920            640            ; Replace all the zeros to the left with blanks
0920 C0E0       640            push acc
0922 7408       640            mov a, #8
0924 14         640            dec a
0925 1200BD     640            lcall ?Set_Cursor_2 ; Select column and row
0928 D0E0       640            pop acc
092A 12034A     640            lcall replace_zeros
092D            641   
092D 020EC0     642       ljmp Sound_Heating_To_Reflow; [sound saying the current state "Heating to reflow"]
0930 8003       643       sjmp Heating_To_Reflow
0932            644   
0932            645   Jump_State_4:   ; ljmp to state 4
0932 02097C     646       ljmp State_4
0935            647   
0935            648   Heating_To_Reflow:
0935            649       ; read temperature every second
0935 30000B     650       jnb seconds_flag, Heating_To_Reflow_a
0938 C200       651       clr seconds_flag
093A 1203F7     652       lcall Read_ADC
093D 12044A     653       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0940 120396     654       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
0943            655   Heating_To_Reflow_a:
0943            656       ; play sound every five seconds
0943 300105     657       jnb five_seconds_flag, Heating_To_Reflow_b
0946 C201       658       clr five_seconds_flag
0948 020DE0     659       ljmp play_temp; [function to play sound here]
094B            660   Heating_To_Reflow_b:
094B 753300     661            mov x+0, #low (0 % 0x10000) 
094E 753400     661            mov x+1, #high(0 % 0x10000) 
0951 753500     661            mov x+2, #low (0 / 0x10000) 
0954 753600     661            mov x+3, #high(0 / 0x10000) 
0957 753700     662            mov y+0, #low (0 % 0x10000) 
095A 753800     662            mov y+1, #high(0 % 0x10000) 
095D 753900     662            mov y+2, #low (0 / 0x10000) 
0960 753A00     662            mov y+3, #high(0 / 0x10000) 
0963 854433     663       mov x+0, temp_reading
0966 854137     664       mov y+0, reflowtemp
0969 120240     665       lcall x_gteq_y
096C 300202     666       jnb mf, Heating_To_Reflow_c
096F D290       667       setb TEMP_OK
0971            668   Heating_To_Reflow_c:
0971            669       ; check state
0971 3095FD     670       jnb STATE_STABLE, $ ; wait for state to be stable
0974 12043E     671       lcall read_state
0977 B40302     672       cjne a, #3, State_4
097A 80B9       673       sjmp Heating_To_Reflow
097C            674   
097C            675   ;-------------------------------------------------- STATE 4 --------------------------------------------------
097C            676   ; reflow temperature has been reached, temperature is held for [reflowtime]
097C            677   State_4:
097C            678       ; check state
097C 3095FD     679       jnb STATE_STABLE, $ ; wait for state to be stable
097F 12043E     680       lcall read_state
0982 B40451     681       cjne a, #4, State_5
0985            682   
0985 020EEF     683       ljmp Sound_Reflowing ;[Sound saying the current state "Reflowing"]
0988            684   
0988            685   Reflowing:
0988            686       ; read temperature every second
0988 30000B     687       jnb seconds_flag, Reflowing_a
098B C200       688       clr seconds_flag
098D 1203F7     689       lcall Read_ADC
0990 12044A     690       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0993 120396     691       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
0996            692   Reflowing_a:
0996            693       ; play sound every five seconds
0996 300105     694       jnb five_seconds_flag, Reflowing_b
0999 C201       695       clr five_seconds_flag
099B 020DE0     696       ljmp play_temp ; [function to play sound here]
099E            697   Reflowing_b:
099E 753300     698            mov x+0, #low (0 % 0x10000) 
09A1 753400     698            mov x+1, #high(0 % 0x10000) 
09A4 753500     698            mov x+2, #low (0 / 0x10000) 
09A7 753600     698            mov x+3, #high(0 / 0x10000) 
09AA 753700     699            mov y+0, #low (0 % 0x10000) 
09AD 753800     699            mov y+1, #high(0 % 0x10000) 
09B0 753900     699            mov y+2, #low (0 / 0x10000) 
09B3 753A00     699            mov y+3, #high(0 / 0x10000) 
09B6 854433     700       mov x+0, temp_reading
09B9 854137     701       mov y+0, reflowtemp
09BC 120240     702       lcall x_gteq_y
09BF 200210     703       jb mf, Reflowing_too_high
09C2            704       ; if temperature >= soaktemp, turn off the oven
09C2 20020D     705       jb mf, Reflowing_too_high
09C5            706       ; else, turn on the oven
09C5 D296       707       setb OVEN_CTL_PIN
09C7            708   Reflowing_d:
09C7            709       ; check state
09C7 3095FD     710       jnb STATE_STABLE, $ ; wait for state to be stable
09CA 12043E     711       lcall read_state
09CD B40406     712       cjne a, #4, State_5
09D0 80B6       713       sjmp Reflowing
09D2            714   
09D2            715   Reflowing_too_high:
09D2 C296       716       clr OVEN_CTL_PIN ; turn off the oven
09D4 80F1       717       sjmp Reflowing_d
09D6            718   
09D6            719   ;------------------------------------------------- STATE 5/6 -------------------------------------------------
09D6            720   ; cooldown/error
09D6            721   State_5:
09D6            722       ; check state
09D6 3095FD     723       jnb STATE_STABLE, $ ; wait for state to be stable
09D9 12043E     724       lcall read_state
09DC B40523     725       cjne a, #5, State_6
09DF            726   
09DF            727       ; turn off the oven
09DF C296       728       clr OVEN_CTL_PIN
09E1            729   
09E1            730       ; display "OVEN OFF" message
09E1 C0E0       731            push acc
09E3 7401       731            mov a, #1
09E5 14         731            dec a
09E6 1200BD     731            lcall ?Set_Cursor_2 ; Select column and row
09E9 D0E0       731            pop acc
09EB C083       732            push dph
09ED C082       732            push dpl
09EF C0E0       732            push acc
09F1 9004F5     732            mov dptr, #OVEN_OFF
09F4 1200B2     732            lcall ?Send_Constant_String
09F7 D0E0       732            pop acc
09F9 D082       732            pop dpl
09FB D083       732            pop dph
09FD            733   
09FD 020F1E     734       ljmp Sound_Cooldown; [Sound saying current state "Cooldown"]
0A00 802F       735       sjmp Cooldown
0A02            736   
0A02            737   State_6:
0A02            738       ; check state
0A02 3095FD     739       jnb STATE_STABLE, $ ; wait for state to be stable
0A05 12043E     740       lcall read_state
0A08 B40623     741       cjne a, #6, Jump_State_0
0A0B            742   
0A0B            743       ; turn off the oven
0A0B C296       744       clr OVEN_CTL_PIN
0A0D            745   
0A0D            746       ; display "OVEN OFF" message
0A0D C0E0       747            push acc
0A0F 7401       747            mov a, #1
0A11 14         747            dec a
0A12 1200BD     747            lcall ?Set_Cursor_2 ; Select column and row
0A15 D0E0       747            pop acc
0A17 C083       748            push dph
0A19 C082       748            push dpl
0A1B C0E0       748            push acc
0A1D 9004F5     748            mov dptr, #OVEN_OFF
0A20 1200B2     748            lcall ?Send_Constant_String
0A23 D0E0       748            pop acc
0A25 D082       748            pop dpl
0A27 D083       748            pop dph
0A29            749   
0A29 020F4D     750       ljmp Sound_Error; [Sound saying current state "Error"]
0A2C 8003       751       sjmp Cooldown
0A2E            752   
0A2E            753   Jump_State_0:
0A2E 020781     754       ljmp State_0
0A31            755   
0A31            756   Cooldown:
0A31            757       ; read temperature every second
0A31 30000B     758       jnb seconds_flag, Cooldown_a
0A34 C200       759       clr seconds_flag
0A36 1203F7     760       lcall Read_ADC
0A39 12044A     761       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0A3C 120396     762       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
0A3F            763   Cooldown_a:
0A3F            764       ; play sound every five seconds
0A3F 300105     765       jnb five_seconds_flag, Cooldown_b
0A42 C201       766       clr five_seconds_flag
0A44 020DE0     767       ljmp play_temp ; [function to play sound here]
0A47            768   Cooldown_b:
0A47 753300     769            mov x+0, #low (0 % 0x10000) 
0A4A 753400     769            mov x+1, #high(0 % 0x10000) 
0A4D 753500     769            mov x+2, #low (0 / 0x10000) 
0A50 753600     769            mov x+3, #high(0 / 0x10000) 
0A53 753732     770            mov y+0, #low (50 % 0x10000) 
0A56 753800     770            mov y+1, #high(50 % 0x10000) 
0A59 753900     770            mov y+2, #low (50 / 0x10000) 
0A5C 753A00     770            mov y+3, #high(50 / 0x10000) 
0A5F 854433     771       mov x+0, temp_reading
0A62 120240     772       lcall x_gteq_y
0A65 200202     773       jb mf, Cooldown_c
0A68 C291       774       clr TEMP_50
0A6A            775   Cooldown_c:
0A6A            776       ; if temperature >= 50, TEMP_50 = 1
0A6A            777       ; else, TEMP_50 = 0
0A6A 12048A     778       lcall Check_50
0A6D            779       ; check state
0A6D 3095FD     780       jnb STATE_STABLE, $ ; wait for state to be stable
0A70 12043E     781       lcall read_state
0A73 B40502     782       cjne a, #5, Cooldown_d
0A76 80B9       783       sjmp Cooldown
0A78            784   Cooldown_d:
0A78 B406B3     785       cjne a, #6, Jump_State_0
0A7B 80B4       786       sjmp Cooldown
0A7D            787   
0A7D            788   ;-------------------------------------------------- SETUP ----------------------------------------------------
0A7D            789   setup:
0A7D            790       ; temperature not set, TEMP_OK = 0
0A7D C290       791       clr TEMP_OK
0A7F            792       ; prints "SOAK" left aligned in the top row
0A7F C0E0       793            push acc
0A81 7401       793            mov a, #1
0A83 14         793            dec a
0A84 1200BF     793            lcall ?Set_Cursor_1 ; Select column and row
0A87 D0E0       793            pop acc
0A89 C083       794            push dph
0A8B C082       794            push dpl
0A8D C0E0       794            push acc
0A8F 9004B1     794            mov dptr, #SOAK_TEMP
0A92 1200B2     794            lcall ?Send_Constant_String
0A95 D0E0       794            pop acc
0A97 D082       794            pop dpl
0A99 D083       794            pop dph
0A9B            795       ; prints "REFLOW" left aligned in the bottom row
0A9B C0E0       796            push acc
0A9D 7401       796            mov a, #1
0A9F 14         796            dec a
0AA0 1200BD     796            lcall ?Set_Cursor_2 ; Select column and row
0AA3 D0E0       796            pop acc
0AA5 C083       797            push dph
0AA7 C082       797            push dpl
0AA9 C0E0       797            push acc
0AAB 9004C2     797            mov dptr, #REFLOW_TEMP
0AAE 1200B2     797            lcall ?Send_Constant_String
0AB1 D0E0       797            pop acc
0AB3 D082       797            pop dpl
0AB5 D083       797            pop dph
0AB7            798       ; display soak temperature
0AB7 753300     799            mov x+0, #low (0 % 0x10000) 
0ABA 753400     799            mov x+1, #high(0 % 0x10000) 
0ABD 753500     799            mov x+2, #low (0 / 0x10000) 
0AC0 753600     799            mov x+3, #high(0 / 0x10000) 
0AC3 854033     800       mov x+0, soaktemp
0AC6 1200DA     801       lcall hex2bcd
0AC9 C0E0       802            push acc
0ACB 7408       802            mov a, #8
0ACD 14         802            dec a
0ACE 1200BF     802            lcall ?Set_Cursor_1 ; Select column and row
0AD1 D0E0       802            pop acc
0AD3 C000       802            push ar0
0AD5 A83C       802            mov r0, bcd+1
0AD7 1200C4     802            lcall ?Display_BCD
0ADA D000       802            pop ar0
0ADC C000       802            push ar0
0ADE A83B       802            mov r0, bcd+0
0AE0 1200C4     802            lcall ?Display_BCD
0AE3 D000       802            pop ar0
0AE5            802            ; Replace all the zeros to the left with blanks
0AE5 C0E0       802            push acc
0AE7 7408       802            mov a, #8
0AE9 14         802            dec a
0AEA 1200BF     802            lcall ?Set_Cursor_1 ; Select column and row
0AED D0E0       802            pop acc
0AEF 12034A     802            lcall replace_zeros
0AF2            803       ; display reflow temperature
0AF2 854133     804       mov x+0, reflowtemp+0
0AF5 1200DA     805       lcall hex2bcd
0AF8 C0E0       806            push acc
0AFA 7408       806            mov a, #8
0AFC 14         806            dec a
0AFD 1200BD     806            lcall ?Set_Cursor_2 ; Select column and row
0B00 D0E0       806            pop acc
0B02 C000       806            push ar0
0B04 A83C       806            mov r0, bcd+1
0B06 1200C4     806            lcall ?Display_BCD
0B09 D000       806            pop ar0
0B0B C000       806            push ar0
0B0D A83B       806            mov r0, bcd+0
0B0F 1200C4     806            lcall ?Display_BCD
0B12 D000       806            pop ar0
0B14            806            ; Replace all the zeros to the left with blanks
0B14 C0E0       806            push acc
0B16 7408       806            mov a, #8
0B18 14         806            dec a
0B19 1200BD     806            lcall ?Set_Cursor_2 ; Select column and row
0B1C D0E0       806            pop acc
0B1E 12034A     806            lcall replace_zeros
0B21            807   
0B21            808   ; set soak temperature
0B21            809   ; MAX: 240
0B21            810   ; MIN: 120
0B21            811   set_soak_temp:
0B21 854033     812       mov x+0, soaktemp
0B24 C0E0       813            push acc
0B26 740B       813            mov a, #11
0B28 14         813            dec a
0B29 1200BF     813            lcall ?Set_Cursor_1 ; Select column and row
0B2C D0E0       813            pop acc
0B2E C0E0       814            push acc
0B30 740E       814            mov a, #0xE
0B32 120083     814            lcall ?WriteCommand
0B35 D0E0       814            pop acc
0B37            815       ; if BOOT_BUTTON is being pressed, wait for release
0B37 30C5FD     816       jnb BOOT_BUTTON, $
0B3A            817   set_soak_temp_a:
0B3A            818       ; if UP is pressed, increment temperature
0B3A 208705     819       jb UP, set_soak_temp_b
0B3D E533       820       mov a, x+0
0B3F            821       ; if temperature < 240, increment temperature
0B3F B4F032     822       cjne a, #0xF0, set_soak_temp_d
0B42            823   set_soak_temp_b:
0B42            824       ; if DOWN button is pressed, increment temperature  
0B42 208505     825       jb DOWN, set_soak_temp_c
0B45 E533       826       mov a, x+0
0B47            827       ; if temperature > 120, decrement temperature
0B47 B4783A     828       cjne a, #0x78, set_soak_temp_e
0B4A            829   set_soak_temp_c:  
0B4A C203       830       clr hold_button
0B4C C0E0       831            push acc
0B4E 740B       831            mov a, #11
0B50 14         831            dec a
0B51 1200BF     831            lcall ?Set_Cursor_1 ; Select column and row
0B54 D0E0       831            pop acc
0B56 C0E0       832            push acc
0B58 740E       832            mov a, #0xE
0B5A 120083     832            lcall ?WriteCommand
0B5D D0E0       832            pop acc
0B5F            833       ; if BOOT_BUTTON is pressed, set reflow time
0B5F 20C5D8     834       jb BOOT_BUTTON, set_soak_temp_a
0B62 C002       835            push AR2
0B64 7A32       835            mov R2, #50
0B66 120039     835            lcall ?Wait_Milli_Seconds
0B69 D002       835            pop AR2 ; debounce time
0B6B 20C5CC     836       jb BOOT_BUTTON, set_soak_temp_a
0B6E 853340     837       mov soaktemp, x+0
0B71 020C2C     838       ljmp set_reflow_temp
0B74            839   set_soak_temp_d:
0B74            840       ; increment soak temperature
0B74 C0E0       841            push acc
0B76 740C       841            mov a, #0xC
0B78 120083     841            lcall ?WriteCommand
0B7B D0E0       841            pop acc
0B7D 0533       842       inc x+0
0B7F            843       ; if UP is held, increment temperature rapidly
0B7F 200312     844       jb hold_button, set_soak_temp_f
0B82 804D       845       sjmp set_soak_temp_g
0B84            846   set_soak_temp_e:
0B84            847       ; decrement soak temperature
0B84 C0E0       848            push acc
0B86 740C       848            mov a, #0xC
0B88 120083     848            lcall ?WriteCommand
0B8B D0E0       848            pop acc
0B8D 1533       849       dec x+0
0B8F            850       ; if DOWN button is held, decrement temperature rapidly
0B8F 200302     851       jb hold_button, set_soak_temp_f
0B92 803D       852       sjmp set_soak_temp_g
0B94            853   set_soak_temp_f:
0B94            854       ; update display and wait 25 ms
0B94 1200DA     855       lcall hex2bcd
0B97 C0E0       856            push acc
0B99 7408       856            mov a, #8
0B9B 14         856            dec a
0B9C 1200BF     856            lcall ?Set_Cursor_1 ; Select column and row
0B9F D0E0       856            pop acc
0BA1 C000       856            push ar0
0BA3 A83C       856            mov r0, bcd+1
0BA5 1200C4     856            lcall ?Display_BCD
0BA8 D000       856            pop ar0
0BAA C000       856            push ar0
0BAC A83B       856            mov r0, bcd+0
0BAE 1200C4     856            lcall ?Display_BCD
0BB1 D000       856            pop ar0
0BB3            856            ; Replace all the zeros to the left with blanks
0BB3 C0E0       856            push acc
0BB5 7408       856            mov a, #8
0BB7 14         856            dec a
0BB8 1200BF     856            lcall ?Set_Cursor_1 ; Select column and row
0BBB D0E0       856            pop acc
0BBD 12034A     856            lcall replace_zeros
0BC0 C002       857            push AR2
0BC2 7A19       857            mov R2, #25
0BC4 120039     857            lcall ?Wait_Milli_Seconds
0BC7 D002       857            pop AR2
0BC9            858       ; if UP is held, increment temperature
0BC9 308756     859       jnb UP, set_soak_temp_h
0BCC            860       ; if DOWN button is held, decrement temperature
0BCC 308558     861       jnb DOWN, set_soak_temp_i
0BCF C203       862       clr hold_button
0BD1            863   set_soak_temp_g:
0BD1            864       ; update display and wait 250 ms
0BD1 1200DA     865       lcall hex2bcd
0BD4 C0E0       866            push acc
0BD6 7408       866            mov a, #8
0BD8 14         866            dec a
0BD9 1200BF     866            lcall ?Set_Cursor_1 ; Select column and row
0BDC D0E0       866            pop acc
0BDE C000       866            push ar0
0BE0 A83C       866            mov r0, bcd+1
0BE2 1200C4     866            lcall ?Display_BCD
0BE5 D000       866            pop ar0
0BE7 C000       866            push ar0
0BE9 A83B       866            mov r0, bcd+0
0BEB 1200C4     866            lcall ?Display_BCD
0BEE D000       866            pop ar0
0BF0            866            ; Replace all the zeros to the left with blanks
0BF0 C0E0       866            push acc
0BF2 7408       866            mov a, #8
0BF4 14         866            dec a
0BF5 1200BF     866            lcall ?Set_Cursor_1 ; Select column and row
0BF8 D0E0       866            pop acc
0BFA 12034A     866            lcall replace_zeros
0BFD C0E0       867            push acc
0BFF 740B       867            mov a, #11
0C01 14         867            dec a
0C02 1200BF     867            lcall ?Set_Cursor_1 ; Select column and row
0C05 D0E0       867            pop acc
0C07 C0E0       868            push acc
0C09 740E       868            mov a, #0xE
0C0B 120083     868            lcall ?WriteCommand
0C0E D0E0       868            pop acc
0C10 C002       869            push AR2
0C12 7AFA       869            mov R2, #250
0C14 120039     869            lcall ?Wait_Milli_Seconds
0C17 D002       869            pop AR2
0C19            870       ; if UP is held, set a flag so the program knows
0C19 308706     871       jnb UP, set_soak_temp_h
0C1C            872       ; if DOWN button is held, set a flag so the program knows 
0C1C 308508     873       jnb DOWN, set_soak_temp_i
0C1F 020B3A     874       ljmp set_soak_temp_a
0C22            875   set_soak_temp_h:
0C22 D203       876       setb hold_button
0C24 020B3A     877       ljmp set_soak_temp_a
0C27            878   set_soak_temp_i:
0C27 D203       879       setb hold_button
0C29 020B42     880       ljmp set_soak_temp_b
0C2C            881   
0C2C            882   ; set reflow temp
0C2C            883   ; MAX: 240
0C2C            884   ; MIN: 120
0C2C            885   set_reflow_temp:
0C2C 854133     886       mov x+0, reflowtemp
0C2F C0E0       887            push acc
0C31 740B       887            mov a, #11
0C33 14         887            dec a
0C34 1200BD     887            lcall ?Set_Cursor_2 ; Select column and row
0C37 D0E0       887            pop acc
0C39 C0E0       888            push acc
0C3B 740E       888            mov a, #0xE
0C3D 120083     888            lcall ?WriteCommand
0C40 D0E0       888            pop acc
0C42            889       ; if BOOT_BUTTON is being pressed, wait for release
0C42 30C5FD     890       jnb BOOT_BUTTON, $
0C45            891   set_reflow_temp_a:
0C45            892       ; if UP is pressed, increment temperature
0C45 208705     893       jb UP, set_reflow_temp_b
0C48 E533       894       mov a, x+0
0C4A            895       ; if temperature < 240, increment temperature
0C4A B4F032     896       cjne a, #0xF0, set_reflow_temp_d
0C4D            897   set_reflow_temp_b:
0C4D            898       ; if DOWN button is pressed, increment temperature  
0C4D 208505     899       jb DOWN, set_reflow_temp_c
0C50 E533       900       mov a, x+0
0C52            901       ; if temperature > 0, decrement temperature
0C52 B4783A     902       cjne a, #0x78, set_reflow_temp_e
0C55            903   set_reflow_temp_c:  
0C55 C203       904       clr hold_button
0C57 C0E0       905            push acc
0C59 740B       905            mov a, #11
0C5B 14         905            dec a
0C5C 1200BD     905            lcall ?Set_Cursor_2 ; Select column and row
0C5F D0E0       905            pop acc
0C61 C0E0       906            push acc
0C63 740E       906            mov a, #0xE
0C65 120083     906            lcall ?WriteCommand
0C68 D0E0       906            pop acc
0C6A            907       ; if BOOT_BUTTON is pressed, set reflow time
0C6A 20C5D8     908       jb BOOT_BUTTON, set_reflow_temp_a
0C6D C002       909            push AR2
0C6F 7A32       909            mov R2, #50
0C71 120039     909            lcall ?Wait_Milli_Seconds
0C74 D002       909            pop AR2 ; debounce time
0C76 20C5CC     910       jb BOOT_BUTTON, set_reflow_temp_a
0C79 853341     911       mov reflowtemp, x+0
0C7C 020D37     912       ljmp setup_done
0C7F            913   set_reflow_temp_d:
0C7F            914       ; increment reflow temperature
0C7F C0E0       915            push acc
0C81 740C       915            mov a, #0xC
0C83 120083     915            lcall ?WriteCommand
0C86 D0E0       915            pop acc
0C88 0533       916       inc x+0
0C8A            917       ; if UP is held, increment temperature rapidly
0C8A 200312     918       jb hold_button, set_reflow_temp_f
0C8D 804D       919       sjmp set_reflow_temp_g
0C8F            920   set_reflow_temp_e:
0C8F            921       ; decrement reflow temperature
0C8F C0E0       922            push acc
0C91 740C       922            mov a, #0xC
0C93 120083     922            lcall ?WriteCommand
0C96 D0E0       922            pop acc
0C98 1533       923       dec x+0
0C9A            924       ; if DOWN button is held, decrement temperature rapidly
0C9A 200302     925       jb hold_button, set_reflow_temp_f
0C9D 803D       926       sjmp set_reflow_temp_g
0C9F            927   set_reflow_temp_f:
0C9F            928       ; update display and wait 25 ms
0C9F 1200DA     929       lcall hex2bcd
0CA2 C0E0       930            push acc
0CA4 7408       930            mov a, #8
0CA6 14         930            dec a
0CA7 1200BD     930            lcall ?Set_Cursor_2 ; Select column and row
0CAA D0E0       930            pop acc
0CAC C000       930            push ar0
0CAE A83C       930            mov r0, bcd+1
0CB0 1200C4     930            lcall ?Display_BCD
0CB3 D000       930            pop ar0
0CB5 C000       930            push ar0
0CB7 A83B       930            mov r0, bcd+0
0CB9 1200C4     930            lcall ?Display_BCD
0CBC D000       930            pop ar0
0CBE            930            ; Replace all the zeros to the left with blanks
0CBE C0E0       930            push acc
0CC0 7408       930            mov a, #8
0CC2 14         930            dec a
0CC3 1200BD     930            lcall ?Set_Cursor_2 ; Select column and row
0CC6 D0E0       930            pop acc
0CC8 12034A     930            lcall replace_zeros
0CCB C002       931            push AR2
0CCD 7A19       931            mov R2, #25
0CCF 120039     931            lcall ?Wait_Milli_Seconds
0CD2 D002       931            pop AR2
0CD4            932       ; if UP is held, increment temperature
0CD4 308756     933       jnb UP, set_reflow_temp_h
0CD7            934       ; if DOWN button is held, decrement temperature
0CD7 308558     935       jnb DOWN, set_reflow_temp_i
0CDA C203       936       clr hold_button
0CDC            937   set_reflow_temp_g:
0CDC            938       ; update display and wait 250 ms
0CDC 1200DA     939       lcall hex2bcd
0CDF C0E0       940            push acc
0CE1 7408       940            mov a, #8
0CE3 14         940            dec a
0CE4 1200BD     940            lcall ?Set_Cursor_2 ; Select column and row
0CE7 D0E0       940            pop acc
0CE9 C000       940            push ar0
0CEB A83C       940            mov r0, bcd+1
0CED 1200C4     940            lcall ?Display_BCD
0CF0 D000       940            pop ar0
0CF2 C000       940            push ar0
0CF4 A83B       940            mov r0, bcd+0
0CF6 1200C4     940            lcall ?Display_BCD
0CF9 D000       940            pop ar0
0CFB            940            ; Replace all the zeros to the left with blanks
0CFB C0E0       940            push acc
0CFD 7408       940            mov a, #8
0CFF 14         940            dec a
0D00 1200BD     940            lcall ?Set_Cursor_2 ; Select column and row
0D03 D0E0       940            pop acc
0D05 12034A     940            lcall replace_zeros
0D08 C0E0       941            push acc
0D0A 740B       941            mov a, #11
0D0C 14         941            dec a
0D0D 1200BD     941            lcall ?Set_Cursor_2 ; Select column and row
0D10 D0E0       941            pop acc
0D12 C0E0       942            push acc
0D14 740E       942            mov a, #0xE
0D16 120083     942            lcall ?WriteCommand
0D19 D0E0       942            pop acc
0D1B C002       943            push AR2
0D1D 7AFA       943            mov R2, #250
0D1F 120039     943            lcall ?Wait_Milli_Seconds
0D22 D002       943            pop AR2
0D24            944       ; if UP is held, set a flag so the program knows
0D24 308706     945       jnb UP, set_reflow_temp_h
0D27            946       ; if DOWN button is held, set a flag so the program knows 
0D27 308508     947       jnb DOWN, set_reflow_temp_i
0D2A 020C45     948       ljmp set_reflow_temp_a
0D2D            949   set_reflow_temp_h:
0D2D D203       950       setb hold_button
0D2F 020C45     951       ljmp set_reflow_temp_a
0D32            952   set_reflow_temp_i:
0D32 D203       953       setb hold_button
0D34 020C4D     954       ljmp set_reflow_temp_b
0D37            955   
0D37            956   setup_done:
0D37 C0E0       957            push acc
0D39 740C       957            mov a, #0xC
0D3B 120083     957            lcall ?WriteCommand
0D3E D0E0       957            pop acc
0D40            958       ; display current temperature
0D40 C0E0       959            push acc
0D42 7401       959            mov a, #1
0D44 14         959            dec a
0D45 1200BF     959            lcall ?Set_Cursor_1 ; Select column and row
0D48 D0E0       959            pop acc
0D4A C083       960            push dph
0D4C C082       960            push dpl
0D4E C0E0       960            push acc
0D50 9004D3     960            mov dptr, #CURRENT_TEMP
0D53 1200B2     960            lcall ?Send_Constant_String
0D56 D0E0       960            pop acc
0D58 D082       960            pop dpl
0D5A D083       960            pop dph
0D5C 1203F7     961       lcall Read_ADC
0D5F C0E0       962            push acc
0D61 7408       962            mov a, #8
0D63 14         962            dec a
0D64 1200BF     962            lcall ?Set_Cursor_1 ; Select column and row
0D67 D0E0       962            pop acc
0D69 C000       962            push ar0
0D6B A83C       962            mov r0, bcd+1
0D6D 1200C4     962            lcall ?Display_BCD
0D70 D000       962            pop ar0
0D72 C000       962            push ar0
0D74 A83B       962            mov r0, bcd+0
0D76 1200C4     962            lcall ?Display_BCD
0D79 D000       962            pop ar0
0D7B            962            ; Replace all the zeros to the left with blanks
0D7B C0E0       962            push acc
0D7D 7408       962            mov a, #8
0D7F 14         962            dec a
0D80 1200BF     962            lcall ?Set_Cursor_1 ; Select column and row
0D83 D0E0       962            pop acc
0D85 12034A     962            lcall replace_zeros
0D88 020781     963       ljmp State_0
0D8B            964   
0D8B            965       ;-------------------------------------------------- SOUND ----------------------------------------------------
0D8B            966   ; NEED TO FIGURE OUT INDEX AND BYTES OF SOUNDS
0D8B            967   Play_Sound_Using_Index:
0D8B C28E       968   clr TR1 ; Stop Timer 1 ISR from playing previous request
0D8D D2A5       969            setb FLASH_CE
0D8F C2A6       970            clr SPEAKER ; Turn off speaker.
0D91            971            
0D91 C2A5       972            clr FLASH_CE ; Enable SPI Flash
0D93 7403       973       mov a, #READ_BYTES
0D95 12063C     974            lcall Send_SPI
0D98            975   
0D98 900506     976   mov dptr, #sound_index ; The beginning of the index (3 bytes per entry)
0D9B            977   
0D9B            978   ; multiply R0 by 3 and add it to the dptr
0D9B E8         979   mov a, R0
0D9C 75F003     980   mov b, #3
0D9F A4         981   mul ab
0DA0 2582       982   add a, dpl
0DA2 F582       983   mov dpl, a
0DA4 E5F0       984   mov a, b
0DA6 3583       985   addc a, dph
0DA8 F583       986   mov dph, a
0DAA            987   
0DAA            988   ; dptr is pointing to the MSB of the 24-bit flash memory address
0DAA E4         989   clr a
0DAB 93         990   movc a, @a+dptr
0DAC 12063C     991   lcall Send_SPI
0DAF            992   
0DAF A3         993   inc dptr
0DB0 E4         994   clr a
0DB1 93         995   movc a, @a+dptr
0DB2 12063C     996   lcall Send_SPI
0DB5            997   
0DB5 A3         998   inc dptr
0DB6 E4         999   clr a
0DB7 93        1000   movc a, @a+dptr
0DB8 12063C    1001   lcall Send_SPI
0DBB           1002   
0DBB           1003   ; Now set how many bytes to play
0DBB 900575    1004            mov dptr, #Size_sound
0DBE           1005     ; multiply R0 by 3 and add it to the dptr
0DBE E8        1006   mov a, R0
0DBF 75F003    1007   mov b, #3
0DC2 A4        1008   mul ab
0DC3 2582      1009   add a, dpl
0DC5 F582      1010   mov dpl, a
0DC7 E5F0      1011   mov a, b
0DC9 3583      1012   addc a, dph
0DCB F583      1013   mov dph, a
0DCD           1014   
0DCD E4        1015   clr a
0DCE 93        1016   movc a, @a+dptr
0DCF F548      1017   mov w+2,a
0DD1           1018   
0DD1 A3        1019   inc dptr
0DD2 E4        1020   clr a
0DD3 93        1021   movc a, @a+dptr
0DD4 F547      1022   mov w+1,a
0DD6           1023   
0DD6 A3        1024   inc dptr
0DD7 E4        1025   clr a
0DD8 93        1026   movc a, @a+dptr
0DD9 F546      1027   mov w+0,a
0DDB           1028   
0DDB           1029   
0DDB           1030   
0DDB           1031   
0DDB D2A6      1032   setb SPEAKER ; Turn on speaker.
0DDD D28E      1033   setb TR1 ; Start playback by enabling Timer 1
0DDF 22        1034   ret
0DE0           1035   
0DE0           1036   play_temp: 
0DE0 E549      1037       mov a, temp_sound_state
0DE2           1038      ; clr c 
0DE2           1039      ; mov a, temp
0DE2           1040      ; subb a, #201 
0DE2           1041       ;jnc gt_200
0DE2           1042       ; mov a, temp
0DE2           1043       ;subb a, #101
0DE2           1044        ;jnc gt_100
0DE2           1045   
0DE2           1046   ;gt_200:
0DE2           1047     ;ljmp Sound_200 
0DE2           1048   
0DE2           1049   ;gt_100:
0DE2           1050     ;ljmp
0DE2           1051   
0DE2           1052   
0DE2           1053   
0DE2           1054   
0DE2           1055   
0DE2           1056   temp_sound_state0:
0DE2 B40006    1057     cjne a, #0, temp_sound_state1 ;check if state is not 0, if yes go to state 1 
0DE5 300502    1058      jnb  playstart_flag, temp_sound_state0_done
0DE8 8001      1059      sjmp temp_sound_state1
0DEA           1060   
0DEA           1061   temp_sound_state0_done:
0DEA 22        1062       ret
0DEB           1063   
0DEB           1064   temp_sound_state1:
0DEB B4010F    1065       cjne a, #1, temp_sound_state2
0DEE C3        1066       clr c
0DEF E544      1067            mov a, temp_reading
0DF1 9465      1068       subb a, #101 
0DF3 5005      1069       jnc  temp_gt_100 ;if T>=100, mov temp_sound_state, #2
0DF5           1070       
0DF5 754905    1071       mov temp_sound_state, #5 ;else if T<100, mov temp_sound_state, #5
0DF8 8015      1072       sjmp temp_sound_state5
0DFA           1073   
0DFA           1074   
0DFA           1075   temp_gt_100:
0DFA 754902    1076       mov temp_sound_state, #2
0DFD           1077   
0DFD           1078   temp_sound_state2:
0DFD B4020F    1079       cjne a, #2, temp_sound_state3
0E00 E544      1080       mov a, temp_reading
0E02 94C9      1081       subb a, #201
0E04 5006      1082       jnc temp_gt_200 ;if T>=200, lcall Play_Sound_Using_Index for 200
0E06 120D8B    1083       lcall Play_Sound_Using_Index ;if T<200,  lcall Play_Sound_Using_Index for 100
0E09 754903    1084       mov temp_sound_state, #3
0E0C           1085   
0E0C           1086   temp_gt_200:
0E0C 120D8B    1087       lcall Play_Sound_Using_Index
0E0F           1088   
0E0F           1089   temp_sound_state3:
0E0F           1090       ;if PLAYDONE=0, mov temp_sound_state, #3
0E0F           1091       ;if PLAYDONE=1, mov temp_sound_state, #5
0E0F           1092   
0E0F           1093   temp_sound_state5:
0E0F B4050C    1094       cjne a, #5, temp_sound_state6
0E12 7444      1095       mov a, #(temp_reading%0x100)
0E14 9414      1096       subb a, #20
0E16 5003      1097       jnc temp_mod_gt_20 ;if (T%100)>=20, temp_sound_state, #8
0E18 754906    1098       mov temp_sound_state, #6 ;else if (T%100)<20, temp_sound_state, #6
0E1B           1099   
0E1B           1100   temp_mod_gt_20:
0E1B 754908    1101       mov temp_sound_state, #8
0E1E           1102   
0E1E           1103   temp_sound_state6:
0E1E B40603    1104       cjne a, #6, temp_sound_state7
0E21           1105       ;play(T%100)
0E21 754907    1106       mov temp_sound_state, #7
0E24           1107   
0E24           1108   temp_sound_state7:
0E24 B40700    1109      cjne a, #7, temp_sound_state8
0E27           1110      ; if PLAYDONE=0, mov temp_sound_state, #7
0E27           1111      ; if PLAYDONE=1, mov temp_sound_state, #0
0E27           1112   
0E27           1113   temp_sound_state8:
0E27 B40803    1114       cjne a, #8, temp_sound_state9
0E2A           1115       ;play '20', '30', '40'....
0E2A 754909    1116       mov temp_sound_state, #9
0E2D           1117   
0E2D           1118   temp_sound_state9:
0E2D B40900    1119      cjne a, #9, temp_sound_state10
0E30           1120       ;if PLAYDONE=0, mov temp_sound_state, #9
0E30           1121     ; if PLAYDONE=1, mov temp_sound_state, #10
0E30           1122   
0E30           1123       temp_sound_state10:
0E30 B40AF1    1124       cjne a, #10, temp_sound_state7
0E33           1125       ;play '1', '2', '3'...
0E33           1126       ;mov temp_sound_state, #7
0E33           1127        
0E33           1128   Sound_Idle:
0E33 C28E      1129       clr TR1 ; Stop Timer 1 ISR from playing previous request
0E35 D2A5      1130            setb FLASH_CE
0E37 C2A6      1131            clr SPEAKER ; Turn off speaker.
0E39           1132            
0E39 C2A5      1133            clr FLASH_CE ; Enable SPI Flash
0E3B 7403      1134            mov a, #READ_BYTES
0E3D 12063C    1135            lcall Send_SPI
0E40           1136            ; Set the initial position in memory where to start playing
0E40 7413      1137            mov a, #0x13
0E42 12063C    1138            lcall Send_SPI
0E45 74D0      1139            mov a, #0xd0
0E47 12063C    1140            lcall Send_SPI
0E4A 74C0      1141            mov a, #0xc0
0E4C 12063C    1142            lcall Send_SPI
0E4F 7413      1143            mov a, #0x13 ; Request first byte to send to DAC
0E51 12063C    1144            lcall Send_SPI
0E54           1145            
0E54 754800    1146            mov w+2, #0x00
0E57 7547A6    1147            mov w+1, #0xa6
0E5A 754665    1148            mov w+0, #0x65
0E5D           1149            
0E5D D2A6      1150            setb SPEAKER ; Turn on speaker.
0E5F D28E      1151            setb TR1 ; Start playback by enabling Timer 1
0E61 22        1152       ret
0E62           1153   
0E62           1154        
0E62           1155   Sound_Heating_To_Soak:
0E62 C28E      1156            clr TR1 ; Stop Timer 1 ISR from playing previous request
0E64 D2A5      1157            setb FLASH_CE
0E66 C2A6      1158            clr SPEAKER ; Turn off speaker.
0E68           1159            
0E68 C2A5      1160            clr FLASH_CE ; Enable SPI Flash
0E6A 7403      1161            mov a, #READ_BYTES
0E6C 12063C    1162            lcall Send_SPI
0E6F           1163            ; Set the initial position in memory where to start playing
0E6F 7414      1164            mov a, #0x14
0E71 12063C    1165            lcall Send_SPI
0E74 7477      1166            mov a, #0x77
0E76 12063C    1167            lcall Send_SPI
0E79 7425      1168            mov a, #0x25
0E7B 12063C    1169            lcall Send_SPI
0E7E 7414      1170            mov a, #0x14 ; Request first byte to send to DAC
0E80 12063C    1171            lcall Send_SPI
0E83           1172            
0E83 754800    1173            mov w+2, #0x00
0E86 7547BE    1174            mov w+1, #0xbe
0E89 75462C    1175            mov w+0, #0x2c
0E8C           1176            
0E8C D2A6      1177            setb SPEAKER ; Turn on speaker.
0E8E D28E      1178            setb TR1 ; Start playback by enabling Timer 1
0E90 22        1179       ret
0E91           1180   
0E91           1181   Sound_Soaking:
0E91 C28E      1182            clr TR1 ; Stop Timer 1 ISR from playing previous request
0E93 D2A5      1183            setb FLASH_CE
0E95 C2A6      1184            clr SPEAKER ; Turn off speaker.
0E97           1185            
0E97 C2A5      1186            clr FLASH_CE ; Enable SPI Flash
0E99 7403      1187            mov a, #READ_BYTES
0E9B 12063C    1188            lcall Send_SPI
0E9E           1189            ; Set the initial position in memory where to start playing
0E9E 7415      1190            mov a, #0x15
0EA0 12063C    1191            lcall Send_SPI
0EA3 7435      1192            mov a, #0x35
0EA5 12063C    1193            lcall Send_SPI
0EA8 7451      1194            mov a, #0x51
0EAA 12063C    1195            lcall Send_SPI
0EAD 7415      1196            mov a, #0x15 ; Request first byte to send to DAC
0EAF 12063C    1197            lcall Send_SPI
0EB2           1198            
0EB2 754800    1199            mov w+2, #0x00
0EB5 754798    1200            mov w+1, #0x98
0EB8 754621    1201            mov w+0, #0x21
0EBB           1202            
0EBB D2A6      1203            setb SPEAKER ; Turn on speaker.
0EBD D28E      1204            setb TR1 ; Start playback by enabling Timer 1
0EBF 22        1205       ret
0EC0           1206   
0EC0           1207   Sound_Heating_To_Reflow:
0EC0 C28E      1208            clr TR1 ; Stop Timer 1 ISR from playing previous request
0EC2 D2A5      1209            setb FLASH_CE
0EC4 C2A6      1210            clr SPEAKER ; Turn off speaker.
0EC6           1211            
0EC6 C2A5      1212            clr FLASH_CE ; Enable SPI Flash
0EC8 7403      1213            mov a, #READ_BYTES
0ECA 12063C    1214            lcall Send_SPI
0ECD           1215            ; Set the initial position in memory where to start playing
0ECD 7415      1216            mov a, #0x15
0ECF 12063C    1217            lcall Send_SPI
0ED2 74CD      1218            mov a, #0xcd
0ED4 12063C    1219            lcall Send_SPI
0ED7 7472      1220            mov a, #0x72
0ED9 12063C    1221            lcall Send_SPI
0EDC 7415      1222            mov a, #0x15 ; Request first byte to send to DAC
0EDE 12063C    1223            lcall Send_SPI
0EE1           1224            
0EE1 754800    1225            mov w+2, #0x00
0EE4 7547BE    1226            mov w+1, #0xbe
0EE7 754619    1227            mov w+0, #0x19
0EEA           1228            
0EEA D2A6      1229            setb SPEAKER ; Turn on speaker.
0EEC D28E      1230            setb TR1 ; Start playback by enabling Timer 1
0EEE 22        1231       ret
0EEF           1232   
0EEF           1233   Sound_Reflowing:
0EEF C28E      1234            clr TR1 ; Stop Timer 1 ISR from playing previous request
0EF1 D2A5      1235            setb FLASH_CE
0EF3 C2A6      1236            clr SPEAKER ; Turn off speaker.
0EF5           1237            
0EF5 C2A5      1238            clr FLASH_CE ; Enable SPI Flash
0EF7 7403      1239            mov a, #READ_BYTES
0EF9 12063C    1240            lcall Send_SPI
0EFC           1241            ; Set the initial position in memory where to start playing
0EFC           1242            ;40
0EFC 7416      1243            mov a, #0x16
0EFE 12063C    1244            lcall Send_SPI
0F01 748B      1245            mov a, #0x8b
0F03 12063C    1246            lcall Send_SPI
0F06 748B      1247            mov a, #0x8b
0F08 12063C    1248            lcall Send_SPI
0F0B 7416      1249            mov a, #0x16 ; Request first byte to send to DAC
0F0D 12063C    1250            lcall Send_SPI
0F10           1251            
0F10 754800    1252            mov w+2, #0x00
0F13 75479F    1253            mov w+1, #0x9f
0F16 754653    1254            mov w+0, #0x53
0F19           1255            
0F19 D2A6      1256            setb SPEAKER ; Turn on speaker.
0F1B D28E      1257            setb TR1 ; Start playback by enabling Timer 1
0F1D 22        1258       ret
0F1E           1259   
0F1E           1260   Sound_Cooldown:
0F1E C28E      1261            clr TR1 ; Stop Timer 1 ISR from playing previous request
0F20 D2A5      1262            setb FLASH_CE
0F22 C2A6      1263            clr SPEAKER ; Turn off speaker.
0F24           1264            
0F24 C2A5      1265            clr FLASH_CE ; Enable SPI Flash
0F26 7403      1266            mov a, #READ_BYTES
0F28 12063C    1267            lcall Send_SPI
0F2B           1268            ; Set the initial position in memory where to start playing
0F2B           1269            ;41
0F2B 7417      1270            mov a, #0x17
0F2D 12063C    1271            lcall Send_SPI
0F30 742A      1272            mov a, #0x2a
0F32 12063C    1273            lcall Send_SPI
0F35 74DE      1274            mov a, #0xde
0F37 12063C    1275            lcall Send_SPI
0F3A 7417      1276            mov a, #0x17 ; Request first byte to send to DAC
0F3C 12063C    1277            lcall Send_SPI
0F3F           1278            
0F3F 754800    1279            mov w+2, #0x00
0F42 7547AB    1280            mov w+1, #0xab
0F45 754627    1281            mov w+0, #0x27
0F48           1282            
0F48 D2A6      1283            setb SPEAKER ; Turn on speaker.
0F4A D28E      1284            setb TR1 ; Start playback by enabling Timer 1
0F4C 22        1285       ret
0F4D           1286   
0F4D           1287   Sound_Error:
0F4D C28E      1288            clr TR1 ; Stop Timer 1 ISR from playing previous request
0F4F D2A5      1289            setb FLASH_CE
0F51 C2A6      1290            clr SPEAKER ; Turn off speaker.
0F53           1291            
0F53 C2A5      1292            clr FLASH_CE ; Enable SPI Flash
0F55 7403      1293            mov a, #READ_BYTES
0F57 12063C    1294            lcall Send_SPI
0F5A           1295            ; Set the initial position in memory where to start playing
0F5A 7417      1296            mov a, #0x17
0F5C 12063C    1297            lcall Send_SPI
0F5F 74D6      1298            mov a, #0xd6
0F61 12063C    1299            lcall Send_SPI
0F64 7405      1300            mov a, #0x05
0F66 12063C    1301            lcall Send_SPI
0F69 7417      1302            mov a, #0x17 ; Request first byte to send to DAC
0F6B 12063C    1303            lcall Send_SPI
0F6E           1304            
0F6E 754800    1305            mov w+2, #0x00
0F71 7547A8    1306            mov w+1, #0xa8
0F74 7546C7    1307            mov w+0, #0xc7
0F77           1308            
0F77 D2A6      1309            setb SPEAKER ; Turn on speaker.
0F79 D28E      1310            setb TR1 ; Start playback by enabling Timer 1
0F7B 22        1311       ret
0F7C           1312       
