                  2   $LIST
0000              4   
0000              5   CLK  EQU 22118400
0000              6   BAUD equ 115200
0000              7   BRG_VAL equ (0x100-(CLK/(16*BAUD)))
0000              8   
0000              9   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             10   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             11   
0000             12   BOOT_BUTTON   equ P4.5
0000             13   UP            equ P0.5
0000             14   DOWN               equ P0.7
0000             15   ; Input 3 bit binary state from TIME/FSM MCU
0000             16   STATE_bit0      equ P2.1
0000             17   STATE_bit1      equ P2.2
0000             18   STATE_bit2      equ P2.3
0000             19   STATE_STABLE    equ P2.4
0000             20   ; Outputs to Time/FSM MCU
0000             21    TEMP_OK        equ P2.3
0000             22    TEMP_50        equ P2.4
0000             23    OVEN_CTL_PIN   equ P1.5
0000             24   
0000             25   org 0000H
0000 020523      26      ljmp MainProgram
0003             27   
0003             28   ; External interrupt 0 vector (not used in this code)
0003             29   org 0x0003
0003 32          30            reti
0004             31   
0004             32   ; Timer/Counter 0 overflow interrupt vector (not used in this code)
000B             33   org 0x000B
000B 32          34            reti
000C             35   
000C             36   ; External interrupt 1 vector (not used in this code)
0013             37   org 0x0013
0013 32          38            reti
0014             39   
0014             40   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             41   org 0x001B
001B 32          42            reti
001C             43   
001C             44   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             45   org 0x0023 
0023 32          46            reti
0024             47            
0024             48   ; Timer/Counter 2 overflow interrupt vector
002B             49   org 0x002B
002B 0204F1      50            ljmp Timer2_ISR
002E             51   
0030             52   DSEG at 30H
0030             53   Count1ms:           ds 2
0032             54   Count5s:            ds 1 
0033             55   x:                  ds 4 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file
0037             56   y:                  ds 4 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file
003B             57   bcd:                ds 5 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file 
0040             58   soaktemp:           ds 1
0041             59   reflowtemp:         ds 1
0042             60   volt_reading:       ds 2 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file
0044             61   temp_reading:       ds 1
0045             62   fsm_state:          ds 1 
0046             63   
0000             64   BSEG
0000             65   seconds_flag:       dbit 1
0001             66   five_seconds_flag:  dbit 1
0002             67   mf:                 dbit 1 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file
0003             68   hold_button:        dbit 1
0004             69   
002E             70   CSEG
002E             71   ; These ’EQU’ must match the wiring between the microcontroller and ADC (used in the INC file)
002E             72   CE_ADC EQU P2.0 
002E             73   MY_MOSI EQU P2.1
002E             74   MY_MISO EQU P2.2
002E             75   MY_SCLK EQU P2.3
002E             76   ; These 'equ' must match the hardware wiring
002E             77   ; They are used by 'LCD_4bit.inc'
002E             78   LCD_RS equ P3.2
002E             79   ; LCD_RW equ Px.x ; Always grounded
002E             80   LCD_E  equ P3.3
002E             81   LCD_D4 equ P3.4
002E             82   LCD_D5 equ P3.5
002E             83   LCD_D6 equ P3.6
002E             84   LCD_D7 equ P3.7
002E             85   
                553   $LIST
                 89   $LIST
0464             91   
0464             92   ;                   1234567890123456
0464 536F616B    93   SOAK_TEMP:      db 'Soak:   xxx', 0xDF, 'C   ', 0
     3A202020
     787878DF
     43202020
     00
0475 5265666C    94   REFLOW_TEMP:    db 'Reflow: xxx', 0xDF, 'C   ', 0
     6F773A20
     787878DF
     43202020
     00
0486 54656D70    95   CURRENT_TEMP:   db 'Temp:   xxx', 0xDF, 'C   ', 0
     3A202020
     787878DF
     43202020
     00
0497 54617267    96   TARGET_TEMP:    db 'Target: xxx', 0xDF, 'C   ', 0
     65743A20
     787878DF
     43202020
     00
04A8 4F56454E    97   OVEN_OFF:       db 'OVEN OFF        ', 0
     204F4646
     20202020
     20202020
     00
04B9             98   
04B9             99   ;---------------------------------;
04B9            100   ; Routine to initialize the ISR   ;
04B9            101   ; for timer 2                     ;
04B9            102   ;---------------------------------;
04B9            103   Timer2_Init:
04B9 75C800     104            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
04BC 75CDA9     105            mov TH2, #high(TIMER2_RELOAD)
04BF 75CC9A     106            mov TL2, #low(TIMER2_RELOAD)
04C2            107            ; Set the reload value
04C2 75CBA9     108            mov RCAP2H, #high(TIMER2_RELOAD)
04C5 75CA9A     109            mov RCAP2L, #low(TIMER2_RELOAD)
04C8            110            ; Init one millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
04C8 E4         111            clr a
04C9 F530       112            mov Count1ms+0, a
04CB F531       113            mov Count1ms+1, a
04CD            114       ; Init five second interrupt counter
04CD F532       115       mov Count5s, a
04CF            116            ; Enable the timer and interrupts
04CF D2AD       117       setb ET2  ; Enable timer 2 interrupt
04D1 D2CA       118       setb TR2  ; Enable timer 2
04D3 22         119            ret
04D4            120   
04D4            121   ; Configure the serial port and baud rate
04D4            122   InitSerialPort:
04D4            123       ; Since the reset button bounces, we need to wait a bit before
04D4            124       ; sending messages, otherwise we risk displaying gibberish!
04D4 79DE       125       mov R1, #222
04D6 78A6       126       mov R0, #166
04D8 D8FE       127       djnz R0, $   ; 3 cycles->3*45.21123ns*166=22.51519us
04DA D9FA       128       djnz R1, $-4 ; 22.51519us*222=4.998ms
04DC            129       ; Now we can proceed with the configuration
04DC 438780     130            orl     PCON,#0x80
04DF 759852     131            mov     SCON,#0x52
04E2 759B00     132            mov     BDRCON,#0x00
04E5 759AF4     133            mov     BRL,#BRG_VAL
04E8 759B1E     134            mov     BDRCON,#0x1E ; BDRCON=BRR|TBCK|RBCK|SPD;
04EB 22         135       ret
04EC            136   
04EC            137   INIT_SPI:
04EC D2A2       138       setb MY_MISO    ; Make MISO an input pin
04EE C2A3       139       clr MY_SCLK     ; For mode (0,0) SCLK is zero
04F0 22         140       ret
04F1            141   
04F1            142   ;---------------------------------;
04F1            143   ; ISR for timer 2                 ;
04F1            144   ;---------------------------------;
04F1            145   Timer2_ISR:
04F1 C2CF       146            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
04F3 B290       147            cpl P1.0 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
04F5            148            
04F5            149            ; The two registers used in the ISR must be saved in the stack
04F5 C0E0       150            push acc
04F7 C0D0       151            push psw
04F9            152            
04F9            153            ; Increment the 16-bit one mili second counter
04F9 0530       154            inc Count1ms+0    ; Increment the low 8-bits first
04FB E530       155            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
04FD 7002       156            jnz Inc_Done
04FF 0531       157            inc Count1ms+1
0501            158   
0501            159   Inc_Done:
0501            160            ; Check if 1 second has passed
0501 E530       161            mov a, Count1ms+0
0503 B4FA18     162            cjne a, #low(250), Timer2_ISR_done ; Warning: this instruction high_low_flags the carry flag!
0506 E531       163            mov a, Count1ms+1
0508 B40013     164            cjne a, #high(250), Timer2_ISR_done
050B            165            
050B            166            ; 1 second has passed. Set a flag so the main program knows
050B D200       167            setb seconds_flag ; Let the main program know 1 second has passed
050D E4         168            clr a
050E F530       169            mov Count1ms+0, a
0510 F531       170            mov Count1ms+1, a
0512 0532       171       inc Count5s
0514            172   
0514            173   Inc_Done_a:
0514            174       ; Check if 5 seconds has passed
0514 E532       175       mov a, Count5s
0516 B40505     176       cjne a, #5, Timer2_ISR_done
0519            177       
0519            178       ; 5 seconds have passed. Set a flag so the main program knows
0519 D201       179       setb five_seconds_flag
051B 753200     180       mov Count5s, #0
051E            181   
051E            182   Timer2_ISR_done:
051E D0D0       183            pop psw
0520 D0E0       184            pop acc
0522 32         185            reti
0523            186   
0523            187   ;---------------------------------;
0523            188   ; Main Program                    ;
0523            189   ;---------------------------------;
0523            190   MainProgram:
0523 75817F     191       mov SP, #7FH ; Set the stack pointer to the begining of idata
0526 D2AF       192       setb EA   ; Enable Global interrupts
0528 75E600     193       mov P0M0, #0
052B 75E700     194       mov P0M1, #0
052E 75CE00     195       mov P2M0, #0
0531 75CF00     196       mov P2M1, #0
0534            197       
0534 1204D4     198       lcall InitSerialPort
0537 1204EC     199       lcall INIT_SPI
053A            200   
053A 120088     201       lcall LCD_4BIT
053D 1204B9     202       lcall Timer2_Init
0540            203   
0540 C200       204       clr seconds_flag
0542            205   
0542 753000     206       mov count1ms+0, #0
0545 753000     207       mov count1ms+0, #0
0548            208       ; defualt soaktemp = 150
0548 754096     209       mov soaktemp, #0x96
054B            210       ; default reflowtemp = 240
054B 7541F0     211       mov reflowtemp, #0xF0
054E            212   
054E 020821     213       ljmp setup ; jump to setup after reset
0551            214   
0551            215   ;-------------------------------------------------- STATE 0 --------------------------------------------------
0551            216   ; idle state, reflow oven is off
0551            217   State_0:
0551            218       ; check state
0551 30A4FD     219       jnb STATE_STABLE, $ ; wait for state to be stable
0554 120415     220       lcall read_state
0557 B4004C     221       cjne a, #0, State_1
055A            222   
055A            223       ; turn off the oven
055A C295       224       clr OVEN_CTL_PIN
055C            225   
055C            226       ; temperature is set, TEMP_OK = 1
055C D2A3       227       setb TEMP_OK
055E            228   
055E            229       ; display "OVEN OFF" message
055E C0E0       230            push acc
0560 7401       230            mov a, #1
0562 14         230            dec a
0563 1200BD     230            lcall ?Set_Cursor_2 ; Select column and row
0566 D0E0       230            pop acc
0568 C083       231            push dph
056A C082       231            push dpl
056C C0E0       231            push acc
056E 9004A8     231            mov dptr, #OVEN_OFF
0571 1200B2     231            lcall ?Send_Constant_String
0574 D0E0       231            pop acc
0576 D082       231            pop dpl
0578 D083       231            pop dph
057A            232   
057A            233       ; [sound saying the current state "Idle"]
057A            234   
057A            235       ; if BOOT_BUTTON is being pressed, wait for release
057A 30C5FD     236       jnb BOOT_BUTTON, $
057D            237       
057D            238   Idle:
057D            239       ; check state
057D 30A4FD     240       jnb STATE_STABLE, $ ; wait for state to be stable
0580 120415     241       lcall read_state
0583 B40020     242       cjne a, #0, State_1
0586            243       ; Read tempurature every second
0586 30000B     244       jnb seconds_flag, Idle_a
0589 C200       245       clr seconds_flag
058B 1203CE     246       lcall Read_ADC
058E 120421     247       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0591 120396     248       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
0594            249   Idle_a:
0594            250       ; if BOOT_BUTTON is pressed, jump to setup
0594 20C5E6     251       jb BOOT_BUTTON, Idle
0597 C002       252            push AR2
0599 7A32       252            mov R2, #50
059B 120039     252            lcall ?Wait_Milli_Seconds
059E D002       252            pop AR2 ; debounce time
05A0 20C5DA     253       jb BOOT_BUTTON, Idle
05A3 020821     254       ljmp setup
05A6            255   
05A6            256   ;-------------------------------------------------- STATE 1 --------------------------------------------------
05A6            257   ; heating to soak temperature
05A6            258   State_1:
05A6            259       ; check state
05A6 30A4FD     260       jnb STATE_STABLE, $ ; wait for state to be stable
05A9 120415     261       lcall read_state
05AC B4015B     262       cjne a, #1, Jump_State_2 ; offset was too large for cjne to jump to State_2, branching to a ljmp
05AF            263   
05AF            264       ; turn on the oven
05AF D295       265       setb OVEN_CTL_PIN
05B1            266   
05B1            267       ; display target temperature
05B1 C0E0       268            push acc
05B3 7401       268            mov a, #1
05B5 14         268            dec a
05B6 1200BD     268            lcall ?Set_Cursor_2 ; Select column and row
05B9 D0E0       268            pop acc
05BB C083       269            push dph
05BD C082       269            push dpl
05BF C0E0       269            push acc
05C1 900497     269            mov dptr, #TARGET_TEMP
05C4 1200B2     269            lcall ?Send_Constant_String
05C7 D0E0       269            pop acc
05C9 D082       269            pop dpl
05CB D083       269            pop dph
05CD 753300     270            mov x+0, #low (0 % 0x10000) 
05D0 753400     270            mov x+1, #high(0 % 0x10000) 
05D3 753500     270            mov x+2, #low (0 / 0x10000) 
05D6 753600     270            mov x+3, #high(0 / 0x10000) 
05D9 854033     271       mov x+0, soaktemp
05DC 1200DA     272       lcall hex2bcd
05DF C0E0       273            push acc
05E1 7408       273            mov a, #8
05E3 14         273            dec a
05E4 1200BD     273            lcall ?Set_Cursor_2 ; Select column and row
05E7 D0E0       273            pop acc
05E9 C000       273            push ar0
05EB A83C       273            mov r0, bcd+1
05ED 1200C4     273            lcall ?Display_BCD
05F0 D000       273            pop ar0
05F2 C000       273            push ar0
05F4 A83B       273            mov r0, bcd+0
05F6 1200C4     273            lcall ?Display_BCD
05F9 D000       273            pop ar0
05FB            273            ; Replace all the zeros to the left with blanks
05FB C0E0       273            push acc
05FD 7408       273            mov a, #8
05FF 14         273            dec a
0600 1200BD     273            lcall ?Set_Cursor_2 ; Select column and row
0603 D0E0       273            pop acc
0605 12034A     273            lcall replace_zeros
0608            274   
0608            275       ; [Sound for saying the current state "Heating to soak"]
0608 8003       276       sjmp Heating_To_Soak
060A            277   
060A            278   Jump_State_2:   ; ljmp to state 2
060A 020652     279       ljmp State_2
060D            280   
060D            281   Heating_To_Soak:
060D            282       ; read temperature every second
060D 30000B     283       jnb seconds_flag, Heating_To_Soak_a
0610 C200       284       clr seconds_flag
0612 1203CE     285       lcall Read_ADC
0615 120421     286       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0618 120396     287       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
061B            288   Heating_To_Soak_a:
061B            289       ; play sound every five seconds
061B 300102     290       jnb five_seconds_flag, Heating_To_Soak_b
061E C201       291       clr five_seconds_flag
0620            292       ; [function to play sound here]
0620            293   Heating_To_Soak_b:
0620            294       ; if temperature >= reflow temperature, TEMP_OK = 0
0620            295       ; else 1
0620 753300     296            mov x+0, #low (0 % 0x10000) 
0623 753400     296            mov x+1, #high(0 % 0x10000) 
0626 753500     296            mov x+2, #low (0 / 0x10000) 
0629 753600     296            mov x+3, #high(0 / 0x10000) 
062C 753700     297            mov y+0, #low (0 % 0x10000) 
062F 753800     297            mov y+1, #high(0 % 0x10000) 
0632 753900     297            mov y+2, #low (0 / 0x10000) 
0635 753A00     297            mov y+3, #high(0 / 0x10000) 
0638 854433     298       mov x+0, temp_reading
063B 854037     299       mov y+0, soaktemp
063E 120240     300       lcall x_gteq_y
0641 300202     301       jnb mf, Heating_To_Soak_c
0644 C2A3       302       clr TEMP_OK
0646            303   Heating_To_Soak_c:
0646            304       ; check state
0646 30A4FD     305       jnb STATE_STABLE, $ ; wait for state to be stable
0649 120415     306       lcall read_state
064C B40103     307       cjne a, #1, State_2
064F 02060D     308       ljmp Heating_To_Soak
0652            309   
0652            310   ;-------------------------------------------------- STATE 2 --------------------------------------------------
0652            311   ; soak temperature has been reached, temperature is held for [soaktime]
0652            312   State_2:
0652            313       ; check state
0652 30A4FD     314       jnb STATE_STABLE, $ ; wait for state to be stable
0655 120415     315       lcall read_state
0658 B40248     316       cjne a, #2, State_3
065B            317   
065B            318       ; [sound saying the current state "Soaking"]
065B            319   
065B            320   Soaking:
065B            321       ; read temperature every second
065B 30000B     322       jnb seconds_flag, Soaking_a
065E C200       323       clr seconds_flag
0660 1203CE     324       lcall Read_ADC
0663 120421     325       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0666 120396     326       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
0669            327   Soaking_a:
0669            328       ; play sound every five seconds
0669 300102     329       jnb five_seconds_flag, Soaking_b
066C C201       330       clr five_seconds_flag
066E            331       ; [function to play sound here]
066E            332   Soaking_b:
066E            333       ; compare temperature to soaktemp
066E 753300     334            mov x+0, #low (0 % 0x10000) 
0671 753400     334            mov x+1, #high(0 % 0x10000) 
0674 753500     334            mov x+2, #low (0 / 0x10000) 
0677 753600     334            mov x+3, #high(0 / 0x10000) 
067A 753700     335            mov y+0, #low (0 % 0x10000) 
067D 753800     335            mov y+1, #high(0 % 0x10000) 
0680 753900     335            mov y+2, #low (0 / 0x10000) 
0683 753A00     335            mov y+3, #high(0 / 0x10000) 
0686 854433     336       mov x+0, temp_reading
0689 854037     337       mov y+0, soaktemp
068C 120240     338       lcall x_gteq_y
068F            339       ; if temperature >= soaktemp, turn off the oven
068F 20020D     340       jb mf, Soaking_too_high
0692            341       ; else, turn on the oven
0692 D295       342       setb OVEN_CTL_PIN
0694            343   Soaking_d:
0694            344       ; check state
0694 30A4FD     345       jnb STATE_STABLE, $ ; wait for state to be stable
0697 120415     346       lcall read_state
069A B40206     347       cjne a, #2, State_3
069D 80BC       348       sjmp Soaking
069F            349   
069F            350   Soaking_too_high:
069F C295       351       clr OVEN_CTL_PIN ; turn off the oven
06A1 80F1       352       sjmp Soaking_d
06A3            353   
06A3            354   ;-------------------------------------------------- STATE 3 --------------------------------------------------
06A3            355   ; heating to reflow temperature
06A3            356   State_3:
06A3            357       ; check state
06A3 30A4FD     358       jnb STATE_STABLE, $ ; wait for state to be stable
06A6 120415     359       lcall read_state
06A9 B4033F     360       cjne a, #3, Jump_State_4
06AC            361   
06AC            362       ; turn on the oven
06AC D295       363       setb OVEN_CTL_PIN
06AE            364   
06AE            365       ; display target temperature
06AE 753300     366            mov x+0, #low (0 % 0x10000) 
06B1 753400     366            mov x+1, #high(0 % 0x10000) 
06B4 753500     366            mov x+2, #low (0 / 0x10000) 
06B7 753600     366            mov x+3, #high(0 / 0x10000) 
06BA 854133     367       mov x+0, reflowtemp
06BD 1200DA     368       lcall hex2bcd
06C0 C0E0       369            push acc
06C2 7408       369            mov a, #8
06C4 14         369            dec a
06C5 1200BD     369            lcall ?Set_Cursor_2 ; Select column and row
06C8 D0E0       369            pop acc
06CA C000       369            push ar0
06CC A83C       369            mov r0, bcd+1
06CE 1200C4     369            lcall ?Display_BCD
06D1 D000       369            pop ar0
06D3 C000       369            push ar0
06D5 A83B       369            mov r0, bcd+0
06D7 1200C4     369            lcall ?Display_BCD
06DA D000       369            pop ar0
06DC            369            ; Replace all the zeros to the left with blanks
06DC C0E0       369            push acc
06DE 7408       369            mov a, #8
06E0 14         369            dec a
06E1 1200BD     369            lcall ?Set_Cursor_2 ; Select column and row
06E4 D0E0       369            pop acc
06E6 12034A     369            lcall replace_zeros
06E9            370   
06E9            371       ; [sound saying the current state "Heating to reflow"]
06E9 8003       372       sjmp Heating_To_Reflow
06EB            373   
06EB            374   Jump_State_4:   ; ljmp to state 4
06EB 020732     375       ljmp State_4
06EE            376   
06EE            377   Heating_To_Reflow:
06EE            378       ; read temperature every second
06EE 30000B     379       jnb seconds_flag, Heating_To_Reflow_a
06F1 C200       380       clr seconds_flag
06F3 1203CE     381       lcall Read_ADC
06F6 120421     382       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
06F9 120396     383       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
06FC            384   Heating_To_Reflow_a:
06FC            385       ; play sound every five seconds
06FC 300102     386       jnb five_seconds_flag, Heating_To_Reflow_b
06FF C201       387       clr five_seconds_flag
0701            388       ; [function to play sound here]
0701            389   Heating_To_Reflow_b:
0701 753300     390            mov x+0, #low (0 % 0x10000) 
0704 753400     390            mov x+1, #high(0 % 0x10000) 
0707 753500     390            mov x+2, #low (0 / 0x10000) 
070A 753600     390            mov x+3, #high(0 / 0x10000) 
070D 753700     391            mov y+0, #low (0 % 0x10000) 
0710 753800     391            mov y+1, #high(0 % 0x10000) 
0713 753900     391            mov y+2, #low (0 / 0x10000) 
0716 753A00     391            mov y+3, #high(0 / 0x10000) 
0719 854433     392       mov x+0, temp_reading
071C 854037     393       mov y+0, soaktemp
071F 120240     394       lcall x_gteq_y
0722 300202     395       jnb mf, Heating_To_Reflow_c
0725 D2A3       396       setb TEMP_OK
0727            397   Heating_To_Reflow_c:
0727            398       ; check state
0727 30A4FD     399       jnb STATE_STABLE, $ ; wait for state to be stable
072A 120415     400       lcall read_state
072D B40302     401       cjne a, #3, State_4
0730 80BC       402       sjmp Heating_To_Reflow
0732            403   
0732            404   ;-------------------------------------------------- STATE 4 --------------------------------------------------
0732            405   ; reflow temperature has been reached, temperature is held for [reflowtime]
0732            406   State_4:
0732            407       ; check state
0732 30A4FD     408       jnb STATE_STABLE, $ ; wait for state to be stable
0735 120415     409       lcall read_state
0738 B4044B     410       cjne a, #4, State_5
073B            411   
073B            412       ; [Sound saying the current state "Reflowing"]
073B            413   
073B            414   Reflowing:
073B            415       ; read temperature every second
073B 30000B     416       jnb seconds_flag, Reflowing_a
073E C200       417       clr seconds_flag
0740 1203CE     418       lcall Read_ADC
0743 120421     419       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0746 120396     420       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
0749            421   Reflowing_a:
0749            422       ; play sound every five seconds
0749 300102     423       jnb five_seconds_flag, Reflowing_b
074C C201       424       clr five_seconds_flag
074E            425       ; [function to play sound here]
074E            426   Reflowing_b:
074E 753300     427            mov x+0, #low (0 % 0x10000) 
0751 753400     427            mov x+1, #high(0 % 0x10000) 
0754 753500     427            mov x+2, #low (0 / 0x10000) 
0757 753600     427            mov x+3, #high(0 / 0x10000) 
075A 753700     428            mov y+0, #low (0 % 0x10000) 
075D 753800     428            mov y+1, #high(0 % 0x10000) 
0760 753900     428            mov y+2, #low (0 / 0x10000) 
0763 753A00     428            mov y+3, #high(0 / 0x10000) 
0766 854433     429       mov x+0, temp_reading
0769 854037     430       mov y+0, soaktemp
076C 120240     431       lcall x_gteq_y
076F 200210     432       jb mf, Reflowing_too_high
0772            433       ; if temperature >= soaktemp, turn off the oven
0772 20020D     434       jb mf, Reflowing_too_high
0775            435       ; else, turn on the oven
0775 D295       436       setb OVEN_CTL_PIN
0777            437   Reflowing_d:
0777            438       ; check state
0777 30A4FD     439       jnb STATE_STABLE, $ ; wait for state to be stable
077A 120415     440       lcall read_state
077D B40406     441       cjne a, #4, State_5
0780 80B9       442       sjmp Reflowing
0782            443   
0782            444   Reflowing_too_high:
0782 C295       445       clr OVEN_CTL_PIN ; turn off the oven
0784 80F1       446       sjmp Reflowing_d
0786            447   
0786            448   ;------------------------------------------------- STATE 5/6 -------------------------------------------------
0786            449   ; cooldown/error
0786            450   State_5:
0786            451       ; check state
0786 30A4FD     452       jnb STATE_STABLE, $ ; wait for state to be stable
0789 120415     453       lcall read_state
078C B40520     454       cjne a, #5, State_6
078F            455   
078F            456       ; turn off the oven
078F C295       457       clr OVEN_CTL_PIN
0791            458   
0791            459       ; display "OVEN OFF" message
0791 C0E0       460            push acc
0793 7401       460            mov a, #1
0795 14         460            dec a
0796 1200BD     460            lcall ?Set_Cursor_2 ; Select column and row
0799 D0E0       460            pop acc
079B C083       461            push dph
079D C082       461            push dpl
079F C0E0       461            push acc
07A1 9004A8     461            mov dptr, #OVEN_OFF
07A4 1200B2     461            lcall ?Send_Constant_String
07A7 D0E0       461            pop acc
07A9 D082       461            pop dpl
07AB D083       461            pop dph
07AD            462   
07AD            463       ; [Sound saying current state "Cooldown"]
07AD 802C       464       sjmp Cooldown
07AF            465   
07AF            466   State_6:
07AF            467       ; check state
07AF 30A4FD     468       jnb STATE_STABLE, $ ; wait for state to be stable
07B2 120415     469       lcall read_state
07B5 B40620     470       cjne a, #6, Jump_State_0
07B8            471   
07B8            472       ; turn off the oven
07B8 C295       473       clr OVEN_CTL_PIN
07BA            474   
07BA            475       ; display "OVEN OFF" message
07BA C0E0       476            push acc
07BC 7401       476            mov a, #1
07BE 14         476            dec a
07BF 1200BD     476            lcall ?Set_Cursor_2 ; Select column and row
07C2 D0E0       476            pop acc
07C4 C083       477            push dph
07C6 C082       477            push dpl
07C8 C0E0       477            push acc
07CA 9004A8     477            mov dptr, #OVEN_OFF
07CD 1200B2     477            lcall ?Send_Constant_String
07D0 D0E0       477            pop acc
07D2 D082       477            pop dpl
07D4 D083       477            pop dph
07D6            478   
07D6            479       ; [Sound saying current state "Error"]
07D6 8003       480       sjmp Cooldown
07D8            481   
07D8            482   Jump_State_0:
07D8 020551     483       ljmp State_0
07DB            484   
07DB            485   Cooldown:
07DB            486       ; read temperature every second
07DB 30000B     487       jnb seconds_flag, Cooldown_a
07DE C200       488       clr seconds_flag
07E0 1203CE     489       lcall Read_ADC
07E3 120421     490       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
07E6 120396     491       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
07E9            492   Cooldown_a:
07E9            493       ; play sound every five seconds
07E9 300102     494       jnb five_seconds_flag, Cooldown_b
07EC C201       495       clr five_seconds_flag
07EE            496       ; [function to play sound here]
07EE            497   Cooldown_b:
07EE 753300     498            mov x+0, #low (0 % 0x10000) 
07F1 753400     498            mov x+1, #high(0 % 0x10000) 
07F4 753500     498            mov x+2, #low (0 / 0x10000) 
07F7 753600     498            mov x+3, #high(0 / 0x10000) 
07FA 753732     499            mov y+0, #low (50 % 0x10000) 
07FD 753800     499            mov y+1, #high(50 % 0x10000) 
0800 753900     499            mov y+2, #low (50 / 0x10000) 
0803 753A00     499            mov y+3, #high(50 / 0x10000) 
0806 854433     500       mov x+0, temp_reading
0809 120240     501       lcall x_gteq_y
080C 200202     502       jb mf, Cooldown_c
080F C2A4       503       clr TEMP_50
0811            504   Cooldown_c:
0811            505       ; check state
0811 30A4FD     506       jnb STATE_STABLE, $ ; wait for state to be stable
0814 120415     507       lcall read_state
0817 B40502     508       cjne a, #5, Cooldown_d
081A 80BF       509       sjmp Cooldown
081C            510   Cooldown_d:
081C B406B9     511       cjne a, #6, Jump_State_0
081F 80BA       512       sjmp Cooldown
0821            513   
0821            514   ;-------------------------------------------------- SETUP ----------------------------------------------------
0821            515   setup:
0821            516       ; temperature not set, TEMP_OK = 0
0821 C2A3       517       clr TEMP_OK
0823            518       ; prints "SOAK" left aligned in the top row
0823 C0E0       519            push acc
0825 7401       519            mov a, #1
0827 14         519            dec a
0828 1200BF     519            lcall ?Set_Cursor_1 ; Select column and row
082B D0E0       519            pop acc
082D C083       520            push dph
082F C082       520            push dpl
0831 C0E0       520            push acc
0833 900464     520            mov dptr, #SOAK_TEMP
0836 1200B2     520            lcall ?Send_Constant_String
0839 D0E0       520            pop acc
083B D082       520            pop dpl
083D D083       520            pop dph
083F            521       ; prints "REFLOW" left aligned in the bottom row
083F C0E0       522            push acc
0841 7401       522            mov a, #1
0843 14         522            dec a
0844 1200BD     522            lcall ?Set_Cursor_2 ; Select column and row
0847 D0E0       522            pop acc
0849 C083       523            push dph
084B C082       523            push dpl
084D C0E0       523            push acc
084F 900475     523            mov dptr, #REFLOW_TEMP
0852 1200B2     523            lcall ?Send_Constant_String
0855 D0E0       523            pop acc
0857 D082       523            pop dpl
0859 D083       523            pop dph
085B            524       ; display soak temperature
085B 753300     525            mov x+0, #low (0 % 0x10000) 
085E 753400     525            mov x+1, #high(0 % 0x10000) 
0861 753500     525            mov x+2, #low (0 / 0x10000) 
0864 753600     525            mov x+3, #high(0 / 0x10000) 
0867 854033     526       mov x+0, soaktemp
086A 1200DA     527       lcall hex2bcd
086D C0E0       528            push acc
086F 7408       528            mov a, #8
0871 14         528            dec a
0872 1200BF     528            lcall ?Set_Cursor_1 ; Select column and row
0875 D0E0       528            pop acc
0877 C000       528            push ar0
0879 A83C       528            mov r0, bcd+1
087B 1200C4     528            lcall ?Display_BCD
087E D000       528            pop ar0
0880 C000       528            push ar0
0882 A83B       528            mov r0, bcd+0
0884 1200C4     528            lcall ?Display_BCD
0887 D000       528            pop ar0
0889            528            ; Replace all the zeros to the left with blanks
0889 C0E0       528            push acc
088B 7408       528            mov a, #8
088D 14         528            dec a
088E 1200BF     528            lcall ?Set_Cursor_1 ; Select column and row
0891 D0E0       528            pop acc
0893 12034A     528            lcall replace_zeros
0896            529       ; display reflow temperature
0896 854133     530       mov x+0, reflowtemp+0
0899 1200DA     531       lcall hex2bcd
089C C0E0       532            push acc
089E 7408       532            mov a, #8
08A0 14         532            dec a
08A1 1200BD     532            lcall ?Set_Cursor_2 ; Select column and row
08A4 D0E0       532            pop acc
08A6 C000       532            push ar0
08A8 A83C       532            mov r0, bcd+1
08AA 1200C4     532            lcall ?Display_BCD
08AD D000       532            pop ar0
08AF C000       532            push ar0
08B1 A83B       532            mov r0, bcd+0
08B3 1200C4     532            lcall ?Display_BCD
08B6 D000       532            pop ar0
08B8            532            ; Replace all the zeros to the left with blanks
08B8 C0E0       532            push acc
08BA 7408       532            mov a, #8
08BC 14         532            dec a
08BD 1200BD     532            lcall ?Set_Cursor_2 ; Select column and row
08C0 D0E0       532            pop acc
08C2 12034A     532            lcall replace_zeros
08C5            533   
08C5            534   ; set soak temperature
08C5            535   ; MAX: 240
08C5            536   ; MIN: 120
08C5            537   set_soak_temp:
08C5 854033     538       mov x+0, soaktemp
08C8 C0E0       539            push acc
08CA 740B       539            mov a, #11
08CC 14         539            dec a
08CD 1200BF     539            lcall ?Set_Cursor_1 ; Select column and row
08D0 D0E0       539            pop acc
08D2 C0E0       540            push acc
08D4 740E       540            mov a, #0xE
08D6 120083     540            lcall ?WriteCommand
08D9 D0E0       540            pop acc
08DB            541       ; if BOOT_BUTTON is being pressed, wait for release
08DB 30C5FD     542       jnb BOOT_BUTTON, $
08DE            543   set_soak_temp_a:
08DE            544       ; if UP is pressed, increment temperature
08DE 208505     545       jb UP, set_soak_temp_b
08E1 E533       546       mov a, x+0
08E3            547       ; if temperature < 240, increment temperature
08E3 B4F032     548       cjne a, #0xF0, set_soak_temp_d
08E6            549   set_soak_temp_b:
08E6            550       ; if DOWN button is pressed, increment temperature  
08E6 208705     551       jb DOWN, set_soak_temp_c
08E9 E533       552       mov a, x+0
08EB            553       ; if temperature > 120, decrement temperature
08EB B4783A     554       cjne a, #0x78, set_soak_temp_e
08EE            555   set_soak_temp_c:  
08EE C203       556       clr hold_button
08F0 C0E0       557            push acc
08F2 740B       557            mov a, #11
08F4 14         557            dec a
08F5 1200BF     557            lcall ?Set_Cursor_1 ; Select column and row
08F8 D0E0       557            pop acc
08FA C0E0       558            push acc
08FC 740E       558            mov a, #0xE
08FE 120083     558            lcall ?WriteCommand
0901 D0E0       558            pop acc
0903            559       ; if BOOT_BUTTON is pressed, set reflow time
0903 20C5D8     560       jb BOOT_BUTTON, set_soak_temp_a
0906 C002       561            push AR2
0908 7A32       561            mov R2, #50
090A 120039     561            lcall ?Wait_Milli_Seconds
090D D002       561            pop AR2 ; debounce time
090F 20C5CC     562       jb BOOT_BUTTON, set_soak_temp_a
0912 853340     563       mov soaktemp, x+0
0915 0209D0     564       ljmp set_reflow_temp
0918            565   set_soak_temp_d:
0918            566       ; increment soak temperature
0918 C0E0       567            push acc
091A 740C       567            mov a, #0xC
091C 120083     567            lcall ?WriteCommand
091F D0E0       567            pop acc
0921 0533       568       inc x+0
0923            569       ; if UP is held, increment temperature rapidly
0923 200312     570       jb hold_button, set_soak_temp_f
0926 804D       571       sjmp set_soak_temp_g
0928            572   set_soak_temp_e:
0928            573       ; decrement soak temperature
0928 C0E0       574            push acc
092A 740C       574            mov a, #0xC
092C 120083     574            lcall ?WriteCommand
092F D0E0       574            pop acc
0931 1533       575       dec x+0
0933            576       ; if DOWN button is held, decrement temperature rapidly
0933 200302     577       jb hold_button, set_soak_temp_f
0936 803D       578       sjmp set_soak_temp_g
0938            579   set_soak_temp_f:
0938            580       ; update display and wait 25 ms
0938 1200DA     581       lcall hex2bcd
093B C0E0       582            push acc
093D 7408       582            mov a, #8
093F 14         582            dec a
0940 1200BF     582            lcall ?Set_Cursor_1 ; Select column and row
0943 D0E0       582            pop acc
0945 C000       582            push ar0
0947 A83C       582            mov r0, bcd+1
0949 1200C4     582            lcall ?Display_BCD
094C D000       582            pop ar0
094E C000       582            push ar0
0950 A83B       582            mov r0, bcd+0
0952 1200C4     582            lcall ?Display_BCD
0955 D000       582            pop ar0
0957            582            ; Replace all the zeros to the left with blanks
0957 C0E0       582            push acc
0959 7408       582            mov a, #8
095B 14         582            dec a
095C 1200BF     582            lcall ?Set_Cursor_1 ; Select column and row
095F D0E0       582            pop acc
0961 12034A     582            lcall replace_zeros
0964 C002       583            push AR2
0966 7A19       583            mov R2, #25
0968 120039     583            lcall ?Wait_Milli_Seconds
096B D002       583            pop AR2
096D            584       ; if UP is held, increment temperature
096D 308556     585       jnb UP, set_soak_temp_h
0970            586       ; if DOWN button is held, decrement temperature
0970 308758     587       jnb DOWN, set_soak_temp_i
0973 C203       588       clr hold_button
0975            589   set_soak_temp_g:
0975            590       ; update display and wait 250 ms
0975 1200DA     591       lcall hex2bcd
0978 C0E0       592            push acc
097A 7408       592            mov a, #8
097C 14         592            dec a
097D 1200BF     592            lcall ?Set_Cursor_1 ; Select column and row
0980 D0E0       592            pop acc
0982 C000       592            push ar0
0984 A83C       592            mov r0, bcd+1
0986 1200C4     592            lcall ?Display_BCD
0989 D000       592            pop ar0
098B C000       592            push ar0
098D A83B       592            mov r0, bcd+0
098F 1200C4     592            lcall ?Display_BCD
0992 D000       592            pop ar0
0994            592            ; Replace all the zeros to the left with blanks
0994 C0E0       592            push acc
0996 7408       592            mov a, #8
0998 14         592            dec a
0999 1200BF     592            lcall ?Set_Cursor_1 ; Select column and row
099C D0E0       592            pop acc
099E 12034A     592            lcall replace_zeros
09A1 C0E0       593            push acc
09A3 740B       593            mov a, #11
09A5 14         593            dec a
09A6 1200BF     593            lcall ?Set_Cursor_1 ; Select column and row
09A9 D0E0       593            pop acc
09AB C0E0       594            push acc
09AD 740E       594            mov a, #0xE
09AF 120083     594            lcall ?WriteCommand
09B2 D0E0       594            pop acc
09B4 C002       595            push AR2
09B6 7AFA       595            mov R2, #250
09B8 120039     595            lcall ?Wait_Milli_Seconds
09BB D002       595            pop AR2
09BD            596       ; if UP is held, set a flag so the program knows
09BD 308506     597       jnb UP, set_soak_temp_h
09C0            598       ; if DOWN button is held, set a flag so the program knows 
09C0 308708     599       jnb DOWN, set_soak_temp_i
09C3 0208DE     600       ljmp set_soak_temp_a
09C6            601   set_soak_temp_h:
09C6 D203       602       setb hold_button
09C8 0208DE     603       ljmp set_soak_temp_a
09CB            604   set_soak_temp_i:
09CB D203       605       setb hold_button
09CD 0208E6     606       ljmp set_soak_temp_b
09D0            607   
09D0            608   ; set reflow temp
09D0            609   ; MAX: 240
09D0            610   ; MIN: 120
09D0            611   set_reflow_temp:
09D0 854133     612       mov x+0, reflowtemp
09D3 C0E0       613            push acc
09D5 740B       613            mov a, #11
09D7 14         613            dec a
09D8 1200BD     613            lcall ?Set_Cursor_2 ; Select column and row
09DB D0E0       613            pop acc
09DD C0E0       614            push acc
09DF 740E       614            mov a, #0xE
09E1 120083     614            lcall ?WriteCommand
09E4 D0E0       614            pop acc
09E6            615       ; if BOOT_BUTTON is being pressed, wait for release
09E6 30C5FD     616       jnb BOOT_BUTTON, $
09E9            617   set_reflow_temp_a:
09E9            618       ; if UP is pressed, increment temperature
09E9 208505     619       jb UP, set_reflow_temp_b
09EC E533       620       mov a, x+0
09EE            621       ; if temperature < 240, increment temperature
09EE B4F032     622       cjne a, #0xF0, set_reflow_temp_d
09F1            623   set_reflow_temp_b:
09F1            624       ; if DOWN button is pressed, increment temperature  
09F1 208705     625       jb DOWN, set_reflow_temp_c
09F4 E533       626       mov a, x+0
09F6            627       ; if temperature > 0, decrement temperature
09F6 B4783A     628       cjne a, #0x78, set_reflow_temp_e
09F9            629   set_reflow_temp_c:  
09F9 C203       630       clr hold_button
09FB C0E0       631            push acc
09FD 740B       631            mov a, #11
09FF 14         631            dec a
0A00 1200BD     631            lcall ?Set_Cursor_2 ; Select column and row
0A03 D0E0       631            pop acc
0A05 C0E0       632            push acc
0A07 740E       632            mov a, #0xE
0A09 120083     632            lcall ?WriteCommand
0A0C D0E0       632            pop acc
0A0E            633       ; if BOOT_BUTTON is pressed, set reflow time
0A0E 20C5D8     634       jb BOOT_BUTTON, set_reflow_temp_a
0A11 C002       635            push AR2
0A13 7A32       635            mov R2, #50
0A15 120039     635            lcall ?Wait_Milli_Seconds
0A18 D002       635            pop AR2 ; debounce time
0A1A 20C5CC     636       jb BOOT_BUTTON, set_reflow_temp_a
0A1D 853341     637       mov reflowtemp, x+0
0A20 020ADB     638       ljmp setup_done
0A23            639   set_reflow_temp_d:
0A23            640       ; increment reflow temperature
0A23 C0E0       641            push acc
0A25 740C       641            mov a, #0xC
0A27 120083     641            lcall ?WriteCommand
0A2A D0E0       641            pop acc
0A2C 0533       642       inc x+0
0A2E            643       ; if UP is held, increment temperature rapidly
0A2E 200312     644       jb hold_button, set_reflow_temp_f
0A31 804D       645       sjmp set_reflow_temp_g
0A33            646   set_reflow_temp_e:
0A33            647       ; decrement reflow temperature
0A33 C0E0       648            push acc
0A35 740C       648            mov a, #0xC
0A37 120083     648            lcall ?WriteCommand
0A3A D0E0       648            pop acc
0A3C 1533       649       dec x+0
0A3E            650       ; if DOWN button is held, decrement temperature rapidly
0A3E 200302     651       jb hold_button, set_reflow_temp_f
0A41 803D       652       sjmp set_reflow_temp_g
0A43            653   set_reflow_temp_f:
0A43            654       ; update display and wait 25 ms
0A43 1200DA     655       lcall hex2bcd
0A46 C0E0       656            push acc
0A48 7408       656            mov a, #8
0A4A 14         656            dec a
0A4B 1200BD     656            lcall ?Set_Cursor_2 ; Select column and row
0A4E D0E0       656            pop acc
0A50 C000       656            push ar0
0A52 A83C       656            mov r0, bcd+1
0A54 1200C4     656            lcall ?Display_BCD
0A57 D000       656            pop ar0
0A59 C000       656            push ar0
0A5B A83B       656            mov r0, bcd+0
0A5D 1200C4     656            lcall ?Display_BCD
0A60 D000       656            pop ar0
0A62            656            ; Replace all the zeros to the left with blanks
0A62 C0E0       656            push acc
0A64 7408       656            mov a, #8
0A66 14         656            dec a
0A67 1200BD     656            lcall ?Set_Cursor_2 ; Select column and row
0A6A D0E0       656            pop acc
0A6C 12034A     656            lcall replace_zeros
0A6F C002       657            push AR2
0A71 7A19       657            mov R2, #25
0A73 120039     657            lcall ?Wait_Milli_Seconds
0A76 D002       657            pop AR2
0A78            658       ; if UP is held, increment temperature
0A78 308556     659       jnb UP, set_reflow_temp_h
0A7B            660       ; if DOWN button is held, decrement temperature
0A7B 308758     661       jnb DOWN, set_reflow_temp_i
0A7E C203       662       clr hold_button
0A80            663   set_reflow_temp_g:
0A80            664       ; update display and wait 250 ms
0A80 1200DA     665       lcall hex2bcd
0A83 C0E0       666            push acc
0A85 7408       666            mov a, #8
0A87 14         666            dec a
0A88 1200BD     666            lcall ?Set_Cursor_2 ; Select column and row
0A8B D0E0       666            pop acc
0A8D C000       666            push ar0
0A8F A83C       666            mov r0, bcd+1
0A91 1200C4     666            lcall ?Display_BCD
0A94 D000       666            pop ar0
0A96 C000       666            push ar0
0A98 A83B       666            mov r0, bcd+0
0A9A 1200C4     666            lcall ?Display_BCD
0A9D D000       666            pop ar0
0A9F            666            ; Replace all the zeros to the left with blanks
0A9F C0E0       666            push acc
0AA1 7408       666            mov a, #8
0AA3 14         666            dec a
0AA4 1200BD     666            lcall ?Set_Cursor_2 ; Select column and row
0AA7 D0E0       666            pop acc
0AA9 12034A     666            lcall replace_zeros
0AAC C0E0       667            push acc
0AAE 740B       667            mov a, #11
0AB0 14         667            dec a
0AB1 1200BD     667            lcall ?Set_Cursor_2 ; Select column and row
0AB4 D0E0       667            pop acc
0AB6 C0E0       668            push acc
0AB8 740E       668            mov a, #0xE
0ABA 120083     668            lcall ?WriteCommand
0ABD D0E0       668            pop acc
0ABF C002       669            push AR2
0AC1 7AFA       669            mov R2, #250
0AC3 120039     669            lcall ?Wait_Milli_Seconds
0AC6 D002       669            pop AR2
0AC8            670       ; if UP is held, set a flag so the program knows
0AC8 308506     671       jnb UP, set_reflow_temp_h
0ACB            672       ; if DOWN button is held, set a flag so the program knows 
0ACB 308708     673       jnb DOWN, set_reflow_temp_i
0ACE 0209E9     674       ljmp set_reflow_temp_a
0AD1            675   set_reflow_temp_h:
0AD1 D203       676       setb hold_button
0AD3 0209E9     677       ljmp set_reflow_temp_a
0AD6            678   set_reflow_temp_i:
0AD6 D203       679       setb hold_button
0AD8 0209F1     680       ljmp set_reflow_temp_b
0ADB            681   
0ADB            682   setup_done:
0ADB C0E0       683            push acc
0ADD 740C       683            mov a, #0xC
0ADF 120083     683            lcall ?WriteCommand
0AE2 D0E0       683            pop acc
0AE4            684       ; display current temperature
0AE4 C0E0       685            push acc
0AE6 7401       685            mov a, #1
0AE8 14         685            dec a
0AE9 1200BF     685            lcall ?Set_Cursor_1 ; Select column and row
0AEC D0E0       685            pop acc
0AEE C083       686            push dph
0AF0 C082       686            push dpl
0AF2 C0E0       686            push acc
0AF4 900486     686            mov dptr, #CURRENT_TEMP
0AF7 1200B2     686            lcall ?Send_Constant_String
0AFA D0E0       686            pop acc
0AFC D082       686            pop dpl
0AFE D083       686            pop dph
0B00 1203CE     687       lcall Read_ADC
0B03 120421     688       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0B06 120396     689       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
0B09 020551     690       ljmp State_0
