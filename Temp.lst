                  2   $LIST
0000              4   
0000              5   CLK  EQU 22118400
0000              6   BAUD equ 115200
0000              7   BRG_VAL equ (0x100-(CLK/(16*BAUD)))
0000              8   
0000              9   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             10   TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
0000             11   TIMER1_RATE    EQU 22050     ; 22050Hz is the sampling rate of the wav file we are playing
0000             12   TIMER1_RELOAD  EQU 0x10000-(CLK/TIMER1_RATE)
0000             13   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             14   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             15   
0000             16   ; The pins used for SPI
0000             17   FLASH_CE  EQU  P2.5
0000             18   PIN_TWO_FOUR   EQU  P2.4 
0000             19   PIN_TWO_ONE   EQU  P2.1
0000             20   PIN_TWO_ZERO   EQU  P2.0 
0000             21   
0000             22   BOOT_BUTTON   equ P4.5
0000             23   SPEAKER  EQU P2.6 ; Used with a MOSFET to turn off speaker when not in use
0000             24   UP            equ P0.7
0000             25   DOWN               equ P0.5
0000             26   ; Input 3 bit binary state from TIME/FSM MCU
0000             27   STATE_bit0      equ P1.2
0000             28   STATE_bit1      equ P1.3
0000             29   STATE_bit2      equ P1.4
0000             30   STATE_STABLE    equ P1.5
0000             31   ; Outputs to Time/FSM MCU
0000             32    TEMP_OK        equ P1.0
0000             33    TEMP_50        equ P1.1
0000             34    OVEN_CTL_PIN   equ P1.6
0000             35   
0000             36    ; Commands supported by the SPI flash memory according to the datasheet
0000             37   WRITE_ENABLE     EQU 0x06  ; Address:0 Dummy:0 Num:0
0000             38   WRITE_DISABLE    EQU 0x04  ; Address:0 Dummy:0 Num:0
0000             39   READ_STATUS      EQU 0x05  ; Address:0 Dummy:0 Num:1 to infinite
0000             40   READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
0000             41   READ_SILICON_ID  EQU 0xab  ; Address:0 Dummy:3 Num:1 to infinite
0000             42   FAST_READ        EQU 0x0b  ; Address:3 Dummy:1 Num:1 to infinite
0000             43   WRITE_STATUS     EQU 0x01  ; Address:0 Dummy:0 Num:1
0000             44   WRITE_BYTES      EQU 0x02  ; Address:3 Dummy:0 Num:1 to 256
0000             45   ERASE_ALL        EQU 0xc7  ; Address:0 Dummy:0 Num:0
0000             46   ERASE_BLOCK      EQU 0xd8  ; Address:3 Dummy:0 Num:0
0000             47   READ_DEVICE_ID   EQU 0x9f  ; Address:0 Dummy:2 Num:1 to infinite
0000             48   
0000             49   org 0000H
0000 02065A      50      ljmp MainProgram
0003             51   
0003             52   ; External interrupt 0 vector (not used in this code)
0003             53   org 0x0003
0003 32          54            reti
0004             55   
0004             56   ; Timer/Counter 0 overflow interrupt vector (not used in this code)
000B             57   org 0x000B
000B 32          58            reti
000C             59   
000C             60   ; External interrupt 1 vector (not used in this code)
0013             61   org 0x0013
0013 32          62            reti
0014             63   
0014             64   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             65   org 0x001B
001B 020526      66            ljmp Timer1_ISR
001E             67   
001E             68   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             69   org 0x0023 
0023 32          70            reti
0024             71            
0024             72   ; Timer/Counter 2 overflow interrupt vector
002B             73   org 0x002B
002B 02062A      74            ljmp Timer2_ISR
002E             75   
0030             76   DSEG at 30H
0030             77   Count1ms:           ds 2
0032             78   Count5s:            ds 1 
0033             79   x:                  ds 4 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file
0037             80   y:                  ds 4 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file
003B             81   bcd:                ds 5 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file 
0040             82   soaktemp:           ds 1
0041             83   reflowtemp:         ds 1
0042             84   volt_reading:       ds 2 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file
0044             85   temp_reading:       ds 1
0045             86   fsm_state:          ds 1 
0046             87   w:                               ds 3 ; 24-bit play counter.  Decremented in Timer 1 ISR.
0049             88   temp_sound_state:     ds 1 
004A             89   
004A             90   
0000             91   BSEG
0000             92   seconds_flag:       dbit 1
0001             93   five_seconds_flag:  dbit 1
0002             94   mf:                 dbit 1 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file
0003             95   hold_button:        dbit 1
0004             96   sound_flag:         dbit 1
0005             97   playstart_flag:      dbit 1 ;used in play temp
0006             98   
002E             99   CSEG
002E            100   ; These ’EQU’ must match the wiring between the microcontroller and ADC (used in the INC file)
002E            101   CE_ADC  EQU P0.4
002E            102   MY_MOSI EQU P0.3
002E            103   MY_MISO EQU P0.2
002E            104   MY_SCLK EQU P0.1
002E            105   ; These 'equ' must match the hardware wiring
002E            106   ; They are used by 'LCD_4bit.inc'
002E            107   LCD_RS equ P3.2
002E            108   ; LCD_RW equ Px.x ; Always grounded
002E            109   LCD_E  equ P3.3
002E            110   LCD_D4 equ P3.4
002E            111   LCD_D5 equ P3.5
002E            112   LCD_D6 equ P3.6
002E            113   LCD_D7 equ P3.7
002E            114   
                553   $LIST
                118   $LIST
04B1            120   
04B1            121   ;                   1234567890123456
04B1 536F616B   122   SOAK_TEMP:      db 'Soak:   xxx', 0xDF, 'C   ', 0
     3A202020
     787878DF
     43202020
     00
04C2 5265666C   123   REFLOW_TEMP:    db 'Reflow: xxx', 0xDF, 'C   ', 0
     6F773A20
     787878DF
     43202020
     00
04D3 54656D70   124   CURRENT_TEMP:   db 'Temp:   xxx', 0xDF, 'C   ', 0
     3A202020
     787878DF
     43202020
     00
04E4 54617267   125   TARGET_TEMP:    db 'Target: xxx', 0xDF, 'C   ', 0
     65743A20
     787878DF
     43202020
     00
04F5 4F56454E   126   OVEN_OFF:       db 'OVEN OFF        ', 0
     204F4646
     20202020
     20202020
     00
0506            127   
0506            128   
0506            129   ;---------------------------------;
0506            130   ; Routine to initialize the ISR   ;
0506            131   ; for timer 0                     ;
0506            132   ;---------------------------------;
0506            133   Timer0_Init:
0506 E589       134            mov a, TMOD
0508 54F0       135            anl a, #0xf0 ; 11110000 Clear the bits for timer 0
050A 4401       136            orl a, #0x01 ; 00000001 Configure timer 0 as 16-timer
050C F589       137            mov TMOD, a
050E 758CEA     138            mov TH0, #high(TIMER0_RELOAD)
0511 758AE8     139            mov TL0, #low(TIMER0_RELOAD)
0514            140            ; Set autoreload value
0514 75F4EA     141            mov RH0, #high(TIMER0_RELOAD)
0517 75F2E8     142            mov RL0, #low(TIMER0_RELOAD)
051A            143            ; Enable the timer and interrupts
051A D2A9       144       setb ET0  ; Enable timer 0 interrupt
051C D28C       145       setb TR0  ; Start timer 0
051E 22         146            ret
051F            147            
051F            148   ;---------------------------------;
051F            149   ; ISR for timer 0                 ;
051F            150   ;---------------------------------;
051F            151   Timer0_ISR:
051F 200401     152            jb sound_flag, Start_Chirping
0522 32         153            reti
0523            154   
0523            155   Start_Chirping:
0523 B2A6       156            cpl SPEAKER 
0525 32         157            reti
0526            158   ;-------------------------------------;
0526            159   ; ISR for Timer 1.  Used to playback  ;
0526            160   ; the WAV file stored in the SPI      ;
0526            161   ; flash memory.                       ;
0526            162   ;-------------------------------------;
0526            163   Timer1_ISR:
0526            164            ; The registers used in the ISR must be saved in the stack
0526 C0E0       165            push acc
0528 C0D0       166            push psw
052A            167            
052A            168            ; Check if the play counter is zero.  If so, stop playing sound.
052A E546       169            mov a, w+0
052C 4547       170            orl a, w+1
052E 4548       171            orl a, w+2
0530 601E       172            jz stop_playing
0532            173            
0532            174            ; Decrement play counter 'w'.  In this implementation 'w' is a 24-bit counter.
0532 74FF       175            mov a, #0xff
0534 1546       176            dec w+0
0536 B54607     177            cjne a, w+0, keep_playing
0539 1547       178            dec w+1
053B B54702     179            cjne a, w+1, keep_playing
053E 1548       180            dec w+2
0540            181            
0540            182   keep_playing:
0540 D2A6       183            setb SPEAKER
0542 120561     184            lcall Send_SPI ; Read the next byte from the SPI Flash...
0545 F580       185            mov P0, a ; WARNING: Remove this if not using an external DAC to use the pins of P0 as GPIO
0547 2480       186            add a, #0x80
0549 F5AD       187            mov DADH, a ; Output to DAC. DAC output is pin P2.3
054B 43A440     188            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
054E 800C       189            sjmp Timer1_ISR_Done
0550            190   
0550            191   stop_playing:
0550 C28E       192            clr TR1 ; Stop timer 1
0552 D2A5       193            setb FLASH_CE  ; Disable SPI Flash
0554 C2A6       194            clr SPEAKER ; Turn off speaker.  Removes hissing noise when not playing sound.
0556 75AD80     195            mov DADH, #0x80 ; middle of range
0559 43A440     196            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
055C            197   
055C            198   Timer1_ISR_Done:         
055C D0D0       199            pop psw
055E D0E0       200            pop acc
0560 32         201            reti
0561            202   
0561            203   ;---------------------------------;
0561            204   ; Sends AND receives a byte via   ;
0561            205   ; SPI.                            ;
0561            206   ;---------------------------------;
0561            207   Send_SPI:
                208   	SPIBIT MAC
                209   	    ; Send/Receive bit %0
                210   		rlc a
                211   		mov PIN_TWO_FOUR, c
                212   		setb PIN_TWO_ZERO
                213   		mov c, PIN_TWO_ONE
                214   		clr PIN_TWO_ZERO
                215   		mov acc.0, c
                216   	ENDMAC
0561            217            
0561            218                ; Send/Receive bit 7
0561 33         218                    rlc a
0562 92A4       218                    mov PIN_TWO_FOUR, c
0564 D2A0       218                    setb PIN_TWO_ZERO
0566 A2A1       218                    mov c, PIN_TWO_ONE
0568 C2A0       218                    clr PIN_TWO_ZERO
056A 92E0       218                    mov acc.0, c
056C            219                ; Send/Receive bit 6
056C 33         219                    rlc a
056D 92A4       219                    mov PIN_TWO_FOUR, c
056F D2A0       219                    setb PIN_TWO_ZERO
0571 A2A1       219                    mov c, PIN_TWO_ONE
0573 C2A0       219                    clr PIN_TWO_ZERO
0575 92E0       219                    mov acc.0, c
0577            220                ; Send/Receive bit 5
0577 33         220                    rlc a
0578 92A4       220                    mov PIN_TWO_FOUR, c
057A D2A0       220                    setb PIN_TWO_ZERO
057C A2A1       220                    mov c, PIN_TWO_ONE
057E C2A0       220                    clr PIN_TWO_ZERO
0580 92E0       220                    mov acc.0, c
0582            221                ; Send/Receive bit 4
0582 33         221                    rlc a
0583 92A4       221                    mov PIN_TWO_FOUR, c
0585 D2A0       221                    setb PIN_TWO_ZERO
0587 A2A1       221                    mov c, PIN_TWO_ONE
0589 C2A0       221                    clr PIN_TWO_ZERO
058B 92E0       221                    mov acc.0, c
058D            222                ; Send/Receive bit 3
058D 33         222                    rlc a
058E 92A4       222                    mov PIN_TWO_FOUR, c
0590 D2A0       222                    setb PIN_TWO_ZERO
0592 A2A1       222                    mov c, PIN_TWO_ONE
0594 C2A0       222                    clr PIN_TWO_ZERO
0596 92E0       222                    mov acc.0, c
0598            223                ; Send/Receive bit 2
0598 33         223                    rlc a
0599 92A4       223                    mov PIN_TWO_FOUR, c
059B D2A0       223                    setb PIN_TWO_ZERO
059D A2A1       223                    mov c, PIN_TWO_ONE
059F C2A0       223                    clr PIN_TWO_ZERO
05A1 92E0       223                    mov acc.0, c
05A3            224                ; Send/Receive bit 1
05A3 33         224                    rlc a
05A4 92A4       224                    mov PIN_TWO_FOUR, c
05A6 D2A0       224                    setb PIN_TWO_ZERO
05A8 A2A1       224                    mov c, PIN_TWO_ONE
05AA C2A0       224                    clr PIN_TWO_ZERO
05AC 92E0       224                    mov acc.0, c
05AE            225                ; Send/Receive bit 0
05AE 33         225                    rlc a
05AF 92A4       225                    mov PIN_TWO_FOUR, c
05B1 D2A0       225                    setb PIN_TWO_ZERO
05B3 A2A1       225                    mov c, PIN_TWO_ONE
05B5 C2A0       225                    clr PIN_TWO_ZERO
05B7 92E0       225                    mov acc.0, c
05B9            226   
05B9 22         227            ret
05BA            228   
05BA            229   Timer1_Init:
05BA            230            ; Configure P2.0, P2.4, P2.5 as open drain outputs
05BA 43CE31     231            orl P2M0, #0b_0011_0001
05BD 43CF31     232            orl P2M1, #0b_0011_0001
05C0 D2A1       233            setb PIN_TWO_ONE  ; Configured as input
05C2 D2A5       234            setb FLASH_CE ; CS=1 for SPI flash memory
05C4 C2A0       235            clr PIN_TWO_ZERO   ; Rest state of SCLK=0
05C6 C2A6       236            clr SPEAKER   ; Turn off speaker.
05C8            237            
05C8            238            ; Configure timer 1
05C8 53890F     239            anl     TMOD, #0x0F ; Clear the bits of timer 1 in TMOD
05CB 438910     240            orl     TMOD, #0x10 ; Set timer 1 in 16-bit timer mode.  Don't change the bits of timer 0
05CE 758DFC     241            mov TH1, #high(TIMER1_RELOAD)
05D1 758B15     242            mov TL1, #low(TIMER1_RELOAD)
05D4            243            ; Set autoreload value
05D4 75F5FC     244            mov RH1, #high(TIMER1_RELOAD)
05D7 75F315     245            mov RL1, #low(TIMER1_RELOAD)
05DA            246   
05DA            247            ; Enable the timer and interrupts
05DA D2AB       248       setb ET1  ; Enable timer 1 interrupt
05DC            249            ; setb TR1 ; Timer 1 is only enabled to play stored sound
05DC            250   
05DC            251            ; Configure the DAC.  The DAC output we are using is P2.3, but P2.2 is also reserved.
05DC 75A5A0     252            mov DADI, #0b_1010_0000 ; ACON=1
05DF 75A43A     253            mov DADC, #0b_0011_1010 ; Enabled, DAC mode, Left adjusted, CLK/4
05E2 75AD80     254            mov DADH, #0x80 ; Middle of scale
05E5 75AC00     255            mov DADL, #0
05E8 43A440     256            orl DADC, #0b_0100_0000 ; Start DAC by GO/BSY=1
05EB            257   
05EB            258   check_DAC_init:
05EB E5A4       259            mov a, DADC
05ED 20E6FB     260            jb acc.6, check_DAC_init ; Wait for DAC to finish
05F0 D2AF       261            setb EA ; Enable interrupts
05F2            262   
05F2            263   ;---------------------------------;
05F2            264   ; Routine to initialize the ISR   ;
05F2            265   ; for timer 2                     ;
05F2            266   ;---------------------------------;
05F2            267   Timer2_Init:
05F2 75C800     268            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
05F5 75CDA9     269            mov TH2, #high(TIMER2_RELOAD)
05F8 75CC9A     270            mov TL2, #low(TIMER2_RELOAD)
05FB            271            ; Set the reload value
05FB 75CBA9     272            mov RCAP2H, #high(TIMER2_RELOAD)
05FE 75CA9A     273            mov RCAP2L, #low(TIMER2_RELOAD)
0601            274            ; Init one millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
0601 E4         275            clr a
0602 F530       276            mov Count1ms+0, a
0604 F531       277            mov Count1ms+1, a
0606            278       ; Init five second interrupt counter
0606 F532       279       mov Count5s, a
0608            280            ; Enable the timer and interrupts
0608 D2AD       281       setb ET2  ; Enable timer 2 interrupt
060A D2CA       282       setb TR2  ; Enable timer 2
060C 22         283            ret
060D            284   
060D            285   ; Configure the serial port and baud rate
060D            286   InitSerialPort:
060D            287       ; Since the reset button bounces, we need to wait a bit before
060D            288       ; sending messages, otherwise we risk displaying gibberish!
060D 79DE       289       mov R1, #222
060F 78A6       290       mov R0, #166
0611 D8FE       291       djnz R0, $   ; 3 cycles->3*45.21123ns*166=22.51519us
0613 D9FA       292       djnz R1, $-4 ; 22.51519us*222=4.998ms
0615            293       ; Now we can proceed with the configuration
0615 438780     294            orl     PCON,#0x80
0618 759852     295            mov     SCON,#0x52
061B 759B00     296            mov     BDRCON,#0x00
061E 759AF4     297            mov     BRL,#BRG_VAL
0621 759B1E     298            mov     BDRCON,#0x1E ; BDRCON=BRR|TBCK|RBCK|SPD;
0624 22         299       ret
0625            300   
0625            301   INIT_SPI:
0625 D282       302       setb MY_MISO    ; Make MISO an input pin
0627 C281       303       clr MY_SCLK     ; For mode (0,0) SCLK is zero
0629 22         304       ret
062A            305   
062A            306   ;---------------------------------;
062A            307   ; ISR for timer 2                 ;
062A            308   ;---------------------------------;
062A            309   Timer2_ISR:
062A C2CF       310            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
062C            311            ;cpl P1.0 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
062C            312            
062C            313            ; The two registers used in the ISR must be saved in the stack
062C C0E0       314            push acc
062E C0D0       315            push psw
0630            316            
0630            317            ; Increment the 16-bit one mili second counter
0630 0530       318            inc Count1ms+0    ; Increment the low 8-bits first
0632 E530       319            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0634 7002       320            jnz Inc_Done
0636 0531       321            inc Count1ms+1
0638            322   
0638            323   Inc_Done:
0638            324            ; Check if 1 second has passed
0638 E530       325            mov a, Count1ms+0
063A B4FA18     326            cjne a, #low(250), Timer2_ISR_done ; Warning: this instruction high_low_flags the carry flag!
063D E531       327            mov a, Count1ms+1
063F B40013     328            cjne a, #high(250), Timer2_ISR_done
0642            329            
0642            330            ; 1 second has passed. Set a flag so the main program knows
0642 D200       331            setb seconds_flag ; Let the main program know 1 second has passed
0644 E4         332            clr a
0645 F530       333            mov Count1ms+0, a
0647 F531       334            mov Count1ms+1, a
0649 0532       335       inc Count5s
064B            336   
064B            337   Inc_Done_a:
064B            338       ; Check if 5 seconds has passed
064B E532       339       mov a, Count5s
064D B40505     340       cjne a, #5, Timer2_ISR_done
0650            341       
0650            342       ; 5 seconds have passed. Set a flag so the main program knows
0650 D201       343       setb five_seconds_flag
0652 753200     344       mov Count5s, #0
0655            345   
0655            346   Timer2_ISR_done:
0655 D0D0       347            pop psw
0657 D0E0       348            pop acc
0659 32         349            reti
065A            350   
065A            351   ;---------------------------------;
065A            352   ; Main Program                    ;
065A            353   ;---------------------------------;
065A            354   MainProgram:
065A 75817F     355       mov SP, #7FH ; Set the stack pointer to the begining of idata
065D D2AF       356       setb EA   ; Enable Global interrupts
065F 75E600     357       mov P0M0, #0
0662 75E700     358       mov P0M1, #0
0665 75D600     359       mov P1M0, #0
0668 75D700     360       mov P1M1, #0
066B 75CE00     361       mov P2M0, #0
066E 75CF00     362       mov P2M1, #0
0671            363       
0671 12060D     364       lcall InitSerialPort
0674 120625     365       lcall INIT_SPI
0677 120506     366       lcall Timer0_Init
067A 1205BA     367       lcall Timer1_Init
067D            368   
067D 120088     369       lcall LCD_4BIT
0680 1205F2     370       lcall Timer2_Init
0683            371   
0683 D292       372       setb STATE_bit0
0685 D293       373       setb STATE_bit1
0687 D294       374       setb STATE_bit2
0689 D295       375       setb STATE_STABLE
068B            376   
068B C290       377       clr TEMP_OK
068D C291       378       clr TEMP_50
068F C296       379       clr OVEN_CTL_PIN
0691            380   
0691 C200       381       clr seconds_flag
0693 C201       382       clr five_seconds_flag
0695 C203       383       clr hold_button
0697            384   
0697 753000     385       mov count1ms+0, #0
069A 753000     386       mov count1ms+0, #0
069D            387       ; defualt soaktemp = 150
069D 754096     388       mov soaktemp, #0x96
06A0            389       ; default reflowtemp = 240
06A0 7541F0     390       mov reflowtemp, #0xF0
06A3            391   
06A3 02097F     392       ljmp setup ; jump to setup after reset
06A6            393   
06A6            394   ;-------------------------------------------------- STATE 0 --------------------------------------------------
06A6            395   ; idle state, reflow oven is off
06A6            396   State_0:
06A6            397       ; check state
06A6 3095FD     398       jnb STATE_STABLE, $ ; wait for state to be stable
06A9 12043E     399       lcall read_state 
06AC B4004F     400       cjne a, #0, State_1
06AF            401   
06AF            402       ; turn off the oven
06AF C296       403       clr OVEN_CTL_PIN
06B1            404   
06B1            405       ; temperature is set, TEMP_OK = 1
06B1 D290       406       setb TEMP_OK
06B3            407   
06B3            408       ; display "OVEN OFF" message
06B3 C0E0       409            push acc
06B5 7401       409            mov a, #1
06B7 14         409            dec a
06B8 1200BD     409            lcall ?Set_Cursor_2 ; Select column and row
06BB D0E0       409            pop acc
06BD C083       410            push dph
06BF C082       410            push dpl
06C1 C0E0       410            push acc
06C3 9004F5     410            mov dptr, #OVEN_OFF
06C6 1200B2     410            lcall ?Send_Constant_String
06C9 D0E0       410            pop acc
06CB D082       410            pop dpl
06CD D083       410            pop dph
06CF            411   
06CF 120C8F     412       lcall Sound_Heating_To_Soak; [sound saying the current state "Idle"]
06D2            413   
06D2            414       ; if BOOT_BUTTON is being pressed, wait for release
06D2 30C5FD     415       jnb BOOT_BUTTON, $
06D5            416       
06D5            417   Idle:
06D5            418       ; check state
06D5 3095FD     419       jnb STATE_STABLE, $ ; wait for state to be stable
06D8 12043E     420       lcall read_state
06DB B40020     421       cjne a, #0, State_1
06DE            422       ; Read tempurature every second
06DE 30000B     423       jnb seconds_flag, Idle_a
06E1 C200       424       clr seconds_flag
06E3 1203F7     425       lcall Read_ADC
06E6 12044A     426       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
06E9 120396     427       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
06EC            428   Idle_a:
06EC            429       ; if BOOT_BUTTON is pressed, jump to setup
06EC 20C5E6     430       jb BOOT_BUTTON, Idle
06EF C002       431            push AR2
06F1 7A32       431            mov R2, #50
06F3 120039     431            lcall ?Wait_Milli_Seconds
06F6 D002       431            pop AR2 ; debounce time
06F8 20C5DA     432       jb BOOT_BUTTON, Idle
06FB 02097F     433       ljmp setup
06FE            434   
06FE            435   ;-------------------------------------------------- STATE 1 --------------------------------------------------
06FE            436   ; heating to soak temperature
06FE            437   State_1:
06FE            438       ; check state
06FE 3095FD     439       jnb STATE_STABLE, $ ; wait for state to be stable
0701 12043E     440       lcall read_state
0704 B4015B     441       cjne a, #1, Jump_State_2 ; offset was too large for cjne to jump to State_2, branching to a ljmp
0707            442   
0707            443       ; turn on the oven
0707 D296       444       setb OVEN_CTL_PIN
0709            445   
0709            446       ; display target temperature
0709 C0E0       447            push acc
070B 7401       447            mov a, #1
070D 14         447            dec a
070E 1200BD     447            lcall ?Set_Cursor_2 ; Select column and row
0711 D0E0       447            pop acc
0713 C083       448            push dph
0715 C082       448            push dpl
0717 C0E0       448            push acc
0719 9004E4     448            mov dptr, #TARGET_TEMP
071C 1200B2     448            lcall ?Send_Constant_String
071F D0E0       448            pop acc
0721 D082       448            pop dpl
0723 D083       448            pop dph
0725 753300     449            mov x+0, #low (0 % 0x10000) 
0728 753400     449            mov x+1, #high(0 % 0x10000) 
072B 753500     449            mov x+2, #low (0 / 0x10000) 
072E 753600     449            mov x+3, #high(0 / 0x10000) 
0731 854033     450       mov x+0, soaktemp
0734 1200DA     451       lcall hex2bcd
0737 C0E0       452            push acc
0739 7408       452            mov a, #8
073B 14         452            dec a
073C 1200BD     452            lcall ?Set_Cursor_2 ; Select column and row
073F D0E0       452            pop acc
0741 C000       452            push ar0
0743 A83C       452            mov r0, bcd+1
0745 1200C4     452            lcall ?Display_BCD
0748 D000       452            pop ar0
074A C000       452            push ar0
074C A83B       452            mov r0, bcd+0
074E 1200C4     452            lcall ?Display_BCD
0751 D000       452            pop ar0
0753            452            ; Replace all the zeros to the left with blanks
0753 C0E0       452            push acc
0755 7408       452            mov a, #8
0757 14         452            dec a
0758 1200BD     452            lcall ?Set_Cursor_2 ; Select column and row
075B D0E0       452            pop acc
075D 12034A     452            lcall replace_zeros
0760            453   
0760            454       ; [Sound for saying the current state "Heating to soak"]
0760 8003       455       sjmp Heating_To_Soak
0762            456   
0762            457   Jump_State_2:   ; ljmp to state 2
0762 0207AD     458       ljmp State_2
0765            459   
0765            460   Heating_To_Soak:
0765            461       ; read temperature every second
0765 30000B     462       jnb seconds_flag, Heating_To_Soak_a
0768 C200       463       clr seconds_flag
076A 1203F7     464       lcall Read_ADC
076D 12044A     465       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0770 120396     466       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
0773            467   Heating_To_Soak_a:
0773            468       ; play sound every five seconds
0773 300102     469       jnb five_seconds_flag, Heating_To_Soak_b
0776 C201       470       clr five_seconds_flag
0778            471       ; [function to play sound here]
0778            472   Heating_To_Soak_b:
0778            473       ; if temperature >= reflow temperature, TEMP_OK = 0
0778            474       ; else 1
0778 753300     475            mov x+0, #low (0 % 0x10000) 
077B 753400     475            mov x+1, #high(0 % 0x10000) 
077E 753500     475            mov x+2, #low (0 / 0x10000) 
0781 753600     475            mov x+3, #high(0 / 0x10000) 
0784 753700     476            mov y+0, #low (0 % 0x10000) 
0787 753800     476            mov y+1, #high(0 % 0x10000) 
078A 753900     476            mov y+2, #low (0 / 0x10000) 
078D 753A00     476            mov y+3, #high(0 / 0x10000) 
0790 854433     477       mov x+0, temp_reading
0793 854037     478       mov y+0, soaktemp
0796 120240     479       lcall x_gteq_y
0799 300202     480       jnb mf, Heating_To_Soak_c
079C C290       481       clr TEMP_OK
079E            482   Heating_To_Soak_c:
079E            483       ; if temperature >= 50, TEMP_50 = 1
079E            484       ; else, TEMP_50 = 0
079E 12048A     485       lcall Check_50
07A1            486       ; check state
07A1 3095FD     487       jnb STATE_STABLE, $ ; wait for state to be stable
07A4 12043E     488       lcall read_state
07A7 B40103     489       cjne a, #1, State_2
07AA 020765     490       ljmp Heating_To_Soak
07AD            491   
07AD            492   ;-------------------------------------------------- STATE 2 --------------------------------------------------
07AD            493   ; soak temperature has been reached, temperature is held for [soaktime]
07AD            494   State_2:
07AD            495       ; check state
07AD 3095FD     496       jnb STATE_STABLE, $ ; wait for state to be stable
07B0 12043E     497       lcall read_state
07B3 B40248     498       cjne a, #2, State_3
07B6            499   
07B6            500       ; [sound saying the current state "Soaking"]
07B6            501   
07B6            502   Soaking:
07B6            503       ; read temperature every second
07B6 30000B     504       jnb seconds_flag, Soaking_a
07B9 C200       505       clr seconds_flag
07BB 1203F7     506       lcall Read_ADC
07BE 12044A     507       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
07C1 120396     508       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
07C4            509   Soaking_a:
07C4            510       ; play sound every five seconds
07C4 300102     511       jnb five_seconds_flag, Soaking_b
07C7 C201       512       clr five_seconds_flag
07C9            513       ; [function to play sound here]
07C9            514   Soaking_b:
07C9            515       ; compare temperature to soaktemp
07C9 753300     516            mov x+0, #low (0 % 0x10000) 
07CC 753400     516            mov x+1, #high(0 % 0x10000) 
07CF 753500     516            mov x+2, #low (0 / 0x10000) 
07D2 753600     516            mov x+3, #high(0 / 0x10000) 
07D5 753700     517            mov y+0, #low (0 % 0x10000) 
07D8 753800     517            mov y+1, #high(0 % 0x10000) 
07DB 753900     517            mov y+2, #low (0 / 0x10000) 
07DE 753A00     517            mov y+3, #high(0 / 0x10000) 
07E1 854433     518       mov x+0, temp_reading
07E4 854037     519       mov y+0, soaktemp
07E7 120240     520       lcall x_gteq_y
07EA            521       ; if temperature >= soaktemp, turn off the oven
07EA 20020D     522       jb mf, Soaking_too_high
07ED            523       ; else, turn on the oven
07ED D296       524       setb OVEN_CTL_PIN
07EF            525   Soaking_d:
07EF            526       ; check state
07EF 3095FD     527       jnb STATE_STABLE, $ ; wait for state to be stable
07F2 12043E     528       lcall read_state
07F5 B40206     529       cjne a, #2, State_3
07F8 80BC       530       sjmp Soaking
07FA            531   
07FA            532   Soaking_too_high:
07FA C296       533       clr OVEN_CTL_PIN ; turn off the oven
07FC 80F1       534       sjmp Soaking_d
07FE            535   
07FE            536   ;-------------------------------------------------- STATE 3 --------------------------------------------------
07FE            537   ; heating to reflow temperature
07FE            538   State_3:
07FE            539       ; check state
07FE 3095FD     540       jnb STATE_STABLE, $ ; wait for state to be stable
0801 12043E     541       lcall read_state
0804 B4033F     542       cjne a, #3, Jump_State_4
0807            543   
0807            544       ; turn on the oven
0807 D296       545       setb OVEN_CTL_PIN
0809            546   
0809            547       ; display target temperature
0809 753300     548            mov x+0, #low (0 % 0x10000) 
080C 753400     548            mov x+1, #high(0 % 0x10000) 
080F 753500     548            mov x+2, #low (0 / 0x10000) 
0812 753600     548            mov x+3, #high(0 / 0x10000) 
0815 854133     549       mov x+0, reflowtemp
0818 1200DA     550       lcall hex2bcd
081B C0E0       551            push acc
081D 7408       551            mov a, #8
081F 14         551            dec a
0820 1200BD     551            lcall ?Set_Cursor_2 ; Select column and row
0823 D0E0       551            pop acc
0825 C000       551            push ar0
0827 A83C       551            mov r0, bcd+1
0829 1200C4     551            lcall ?Display_BCD
082C D000       551            pop ar0
082E C000       551            push ar0
0830 A83B       551            mov r0, bcd+0
0832 1200C4     551            lcall ?Display_BCD
0835 D000       551            pop ar0
0837            551            ; Replace all the zeros to the left with blanks
0837 C0E0       551            push acc
0839 7408       551            mov a, #8
083B 14         551            dec a
083C 1200BD     551            lcall ?Set_Cursor_2 ; Select column and row
083F D0E0       551            pop acc
0841 12034A     551            lcall replace_zeros
0844            552   
0844            553       ; [sound saying the current state "Heating to reflow"]
0844 8003       554       sjmp Heating_To_Reflow
0846            555   
0846            556   Jump_State_4:   ; ljmp to state 4
0846 02088D     557       ljmp State_4
0849            558   
0849            559   Heating_To_Reflow:
0849            560       ; read temperature every second
0849 30000B     561       jnb seconds_flag, Heating_To_Reflow_a
084C C200       562       clr seconds_flag
084E 1203F7     563       lcall Read_ADC
0851 12044A     564       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0854 120396     565       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
0857            566   Heating_To_Reflow_a:
0857            567       ; play sound every five seconds
0857 300102     568       jnb five_seconds_flag, Heating_To_Reflow_b
085A C201       569       clr five_seconds_flag
085C            570       ; [function to play sound here]
085C            571   Heating_To_Reflow_b:
085C 753300     572            mov x+0, #low (0 % 0x10000) 
085F 753400     572            mov x+1, #high(0 % 0x10000) 
0862 753500     572            mov x+2, #low (0 / 0x10000) 
0865 753600     572            mov x+3, #high(0 / 0x10000) 
0868 753700     573            mov y+0, #low (0 % 0x10000) 
086B 753800     573            mov y+1, #high(0 % 0x10000) 
086E 753900     573            mov y+2, #low (0 / 0x10000) 
0871 753A00     573            mov y+3, #high(0 / 0x10000) 
0874 854433     574       mov x+0, temp_reading
0877 854137     575       mov y+0, reflowtemp
087A 120240     576       lcall x_gteq_y
087D 300202     577       jnb mf, Heating_To_Reflow_c
0880 D290       578       setb TEMP_OK
0882            579   Heating_To_Reflow_c:
0882            580       ; check state
0882 3095FD     581       jnb STATE_STABLE, $ ; wait for state to be stable
0885 12043E     582       lcall read_state
0888 B40302     583       cjne a, #3, State_4
088B 80BC       584       sjmp Heating_To_Reflow
088D            585   
088D            586   ;-------------------------------------------------- STATE 4 --------------------------------------------------
088D            587   ; reflow temperature has been reached, temperature is held for [reflowtime]
088D            588   State_4:
088D            589       ; check state
088D 3095FD     590       jnb STATE_STABLE, $ ; wait for state to be stable
0890 12043E     591       lcall read_state
0893 B4044B     592       cjne a, #4, State_5
0896            593   
0896            594       ; [Sound saying the current state "Reflowing"]
0896            595   
0896            596   Reflowing:
0896            597       ; read temperature every second
0896 30000B     598       jnb seconds_flag, Reflowing_a
0899 C200       599       clr seconds_flag
089B 1203F7     600       lcall Read_ADC
089E 12044A     601       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
08A1 120396     602       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
08A4            603   Reflowing_a:
08A4            604       ; play sound every five seconds
08A4 300102     605       jnb five_seconds_flag, Reflowing_b
08A7 C201       606       clr five_seconds_flag
08A9            607       ; [function to play sound here]
08A9            608   Reflowing_b:
08A9 753300     609            mov x+0, #low (0 % 0x10000) 
08AC 753400     609            mov x+1, #high(0 % 0x10000) 
08AF 753500     609            mov x+2, #low (0 / 0x10000) 
08B2 753600     609            mov x+3, #high(0 / 0x10000) 
08B5 753700     610            mov y+0, #low (0 % 0x10000) 
08B8 753800     610            mov y+1, #high(0 % 0x10000) 
08BB 753900     610            mov y+2, #low (0 / 0x10000) 
08BE 753A00     610            mov y+3, #high(0 / 0x10000) 
08C1 854433     611       mov x+0, temp_reading
08C4 854137     612       mov y+0, reflowtemp
08C7 120240     613       lcall x_gteq_y
08CA 200210     614       jb mf, Reflowing_too_high
08CD            615       ; if temperature >= soaktemp, turn off the oven
08CD 20020D     616       jb mf, Reflowing_too_high
08D0            617       ; else, turn on the oven
08D0 D296       618       setb OVEN_CTL_PIN
08D2            619   Reflowing_d:
08D2            620       ; check state
08D2 3095FD     621       jnb STATE_STABLE, $ ; wait for state to be stable
08D5 12043E     622       lcall read_state
08D8 B40406     623       cjne a, #4, State_5
08DB 80B9       624       sjmp Reflowing
08DD            625   
08DD            626   Reflowing_too_high:
08DD C296       627       clr OVEN_CTL_PIN ; turn off the oven
08DF 80F1       628       sjmp Reflowing_d
08E1            629   
08E1            630   ;------------------------------------------------- STATE 5/6 -------------------------------------------------
08E1            631   ; cooldown/error
08E1            632   State_5:
08E1            633       ; check state
08E1 3095FD     634       jnb STATE_STABLE, $ ; wait for state to be stable
08E4 12043E     635       lcall read_state
08E7 B40520     636       cjne a, #5, State_6
08EA            637   
08EA            638       ; turn off the oven
08EA C296       639       clr OVEN_CTL_PIN
08EC            640   
08EC            641       ; display "OVEN OFF" message
08EC C0E0       642            push acc
08EE 7401       642            mov a, #1
08F0 14         642            dec a
08F1 1200BD     642            lcall ?Set_Cursor_2 ; Select column and row
08F4 D0E0       642            pop acc
08F6 C083       643            push dph
08F8 C082       643            push dpl
08FA C0E0       643            push acc
08FC 9004F5     643            mov dptr, #OVEN_OFF
08FF 1200B2     643            lcall ?Send_Constant_String
0902 D0E0       643            pop acc
0904 D082       643            pop dpl
0906 D083       643            pop dph
0908            644   
0908            645       ; [Sound saying current state "Cooldown"]
0908 802C       646       sjmp Cooldown
090A            647   
090A            648   State_6:
090A            649       ; check state
090A 3095FD     650       jnb STATE_STABLE, $ ; wait for state to be stable
090D 12043E     651       lcall read_state
0910 B40620     652       cjne a, #6, Jump_State_0
0913            653   
0913            654       ; turn off the oven
0913 C296       655       clr OVEN_CTL_PIN
0915            656   
0915            657       ; display "OVEN OFF" message
0915 C0E0       658            push acc
0917 7401       658            mov a, #1
0919 14         658            dec a
091A 1200BD     658            lcall ?Set_Cursor_2 ; Select column and row
091D D0E0       658            pop acc
091F C083       659            push dph
0921 C082       659            push dpl
0923 C0E0       659            push acc
0925 9004F5     659            mov dptr, #OVEN_OFF
0928 1200B2     659            lcall ?Send_Constant_String
092B D0E0       659            pop acc
092D D082       659            pop dpl
092F D083       659            pop dph
0931            660   
0931            661       ; [Sound saying current state "Error"]
0931 8003       662       sjmp Cooldown
0933            663   
0933            664   Jump_State_0:
0933 0206A6     665       ljmp State_0
0936            666   
0936            667   Cooldown:
0936            668       ; read temperature every second
0936 30000B     669       jnb seconds_flag, Cooldown_a
0939 C200       670       clr seconds_flag
093B 1203F7     671       lcall Read_ADC
093E 12044A     672       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0941 120396     673       lcall Send_10_digit_BCD ; display/send temperature to LCD/PuTTY
0944            674   Cooldown_a:
0944            675       ; play sound every five seconds
0944 300102     676       jnb five_seconds_flag, Cooldown_b
0947 C201       677       clr five_seconds_flag
0949            678       ; [function to play sound here]
0949            679   Cooldown_b:
0949 753300     680            mov x+0, #low (0 % 0x10000) 
094C 753400     680            mov x+1, #high(0 % 0x10000) 
094F 753500     680            mov x+2, #low (0 / 0x10000) 
0952 753600     680            mov x+3, #high(0 / 0x10000) 
0955 753732     681            mov y+0, #low (50 % 0x10000) 
0958 753800     681            mov y+1, #high(50 % 0x10000) 
095B 753900     681            mov y+2, #low (50 / 0x10000) 
095E 753A00     681            mov y+3, #high(50 / 0x10000) 
0961 854433     682       mov x+0, temp_reading
0964 120240     683       lcall x_gteq_y
0967 200202     684       jb mf, Cooldown_c
096A C291       685       clr TEMP_50
096C            686   Cooldown_c:
096C            687       ; if temperature >= 50, TEMP_50 = 1
096C            688       ; else, TEMP_50 = 0
096C 12048A     689       lcall Check_50
096F            690       ; check state
096F 3095FD     691       jnb STATE_STABLE, $ ; wait for state to be stable
0972 12043E     692       lcall read_state
0975 B40502     693       cjne a, #5, Cooldown_d
0978 80BC       694       sjmp Cooldown
097A            695   Cooldown_d:
097A B406B6     696       cjne a, #6, Jump_State_0
097D 80B7       697       sjmp Cooldown
097F            698   
097F            699   ;-------------------------------------------------- SETUP ----------------------------------------------------
097F            700   setup:
097F            701       ; temperature not set, TEMP_OK = 0
097F C290       702       clr TEMP_OK
0981            703       ; prints "SOAK" left aligned in the top row
0981 C0E0       704            push acc
0983 7401       704            mov a, #1
0985 14         704            dec a
0986 1200BF     704            lcall ?Set_Cursor_1 ; Select column and row
0989 D0E0       704            pop acc
098B C083       705            push dph
098D C082       705            push dpl
098F C0E0       705            push acc
0991 9004B1     705            mov dptr, #SOAK_TEMP
0994 1200B2     705            lcall ?Send_Constant_String
0997 D0E0       705            pop acc
0999 D082       705            pop dpl
099B D083       705            pop dph
099D            706       ; prints "REFLOW" left aligned in the bottom row
099D C0E0       707            push acc
099F 7401       707            mov a, #1
09A1 14         707            dec a
09A2 1200BD     707            lcall ?Set_Cursor_2 ; Select column and row
09A5 D0E0       707            pop acc
09A7 C083       708            push dph
09A9 C082       708            push dpl
09AB C0E0       708            push acc
09AD 9004C2     708            mov dptr, #REFLOW_TEMP
09B0 1200B2     708            lcall ?Send_Constant_String
09B3 D0E0       708            pop acc
09B5 D082       708            pop dpl
09B7 D083       708            pop dph
09B9            709       ; display soak temperature
09B9 753300     710            mov x+0, #low (0 % 0x10000) 
09BC 753400     710            mov x+1, #high(0 % 0x10000) 
09BF 753500     710            mov x+2, #low (0 / 0x10000) 
09C2 753600     710            mov x+3, #high(0 / 0x10000) 
09C5 854033     711       mov x+0, soaktemp
09C8 1200DA     712       lcall hex2bcd
09CB C0E0       713            push acc
09CD 7408       713            mov a, #8
09CF 14         713            dec a
09D0 1200BF     713            lcall ?Set_Cursor_1 ; Select column and row
09D3 D0E0       713            pop acc
09D5 C000       713            push ar0
09D7 A83C       713            mov r0, bcd+1
09D9 1200C4     713            lcall ?Display_BCD
09DC D000       713            pop ar0
09DE C000       713            push ar0
09E0 A83B       713            mov r0, bcd+0
09E2 1200C4     713            lcall ?Display_BCD
09E5 D000       713            pop ar0
09E7            713            ; Replace all the zeros to the left with blanks
09E7 C0E0       713            push acc
09E9 7408       713            mov a, #8
09EB 14         713            dec a
09EC 1200BF     713            lcall ?Set_Cursor_1 ; Select column and row
09EF D0E0       713            pop acc
09F1 12034A     713            lcall replace_zeros
09F4            714       ; display reflow temperature
09F4 854133     715       mov x+0, reflowtemp+0
09F7 1200DA     716       lcall hex2bcd
09FA C0E0       717            push acc
09FC 7408       717            mov a, #8
09FE 14         717            dec a
09FF 1200BD     717            lcall ?Set_Cursor_2 ; Select column and row
0A02 D0E0       717            pop acc
0A04 C000       717            push ar0
0A06 A83C       717            mov r0, bcd+1
0A08 1200C4     717            lcall ?Display_BCD
0A0B D000       717            pop ar0
0A0D C000       717            push ar0
0A0F A83B       717            mov r0, bcd+0
0A11 1200C4     717            lcall ?Display_BCD
0A14 D000       717            pop ar0
0A16            717            ; Replace all the zeros to the left with blanks
0A16 C0E0       717            push acc
0A18 7408       717            mov a, #8
0A1A 14         717            dec a
0A1B 1200BD     717            lcall ?Set_Cursor_2 ; Select column and row
0A1E D0E0       717            pop acc
0A20 12034A     717            lcall replace_zeros
0A23            718   
0A23            719   ; set soak temperature
0A23            720   ; MAX: 240
0A23            721   ; MIN: 120
0A23            722   set_soak_temp:
0A23 854033     723       mov x+0, soaktemp
0A26 C0E0       724            push acc
0A28 740B       724            mov a, #11
0A2A 14         724            dec a
0A2B 1200BF     724            lcall ?Set_Cursor_1 ; Select column and row
0A2E D0E0       724            pop acc
0A30 C0E0       725            push acc
0A32 740E       725            mov a, #0xE
0A34 120083     725            lcall ?WriteCommand
0A37 D0E0       725            pop acc
0A39            726       ; if BOOT_BUTTON is being pressed, wait for release
0A39 30C5FD     727       jnb BOOT_BUTTON, $
0A3C            728   set_soak_temp_a:
0A3C            729       ; if UP is pressed, increment temperature
0A3C 208705     730       jb UP, set_soak_temp_b
0A3F E533       731       mov a, x+0
0A41            732       ; if temperature < 240, increment temperature
0A41 B4F032     733       cjne a, #0xF0, set_soak_temp_d
0A44            734   set_soak_temp_b:
0A44            735       ; if DOWN button is pressed, increment temperature  
0A44 208505     736       jb DOWN, set_soak_temp_c
0A47 E533       737       mov a, x+0
0A49            738       ; if temperature > 120, decrement temperature
0A49 B4783A     739       cjne a, #0x78, set_soak_temp_e
0A4C            740   set_soak_temp_c:  
0A4C C203       741       clr hold_button
0A4E C0E0       742            push acc
0A50 740B       742            mov a, #11
0A52 14         742            dec a
0A53 1200BF     742            lcall ?Set_Cursor_1 ; Select column and row
0A56 D0E0       742            pop acc
0A58 C0E0       743            push acc
0A5A 740E       743            mov a, #0xE
0A5C 120083     743            lcall ?WriteCommand
0A5F D0E0       743            pop acc
0A61            744       ; if BOOT_BUTTON is pressed, set reflow time
0A61 20C5D8     745       jb BOOT_BUTTON, set_soak_temp_a
0A64 C002       746            push AR2
0A66 7A32       746            mov R2, #50
0A68 120039     746            lcall ?Wait_Milli_Seconds
0A6B D002       746            pop AR2 ; debounce time
0A6D 20C5CC     747       jb BOOT_BUTTON, set_soak_temp_a
0A70 853340     748       mov soaktemp, x+0
0A73 020B2E     749       ljmp set_reflow_temp
0A76            750   set_soak_temp_d:
0A76            751       ; increment soak temperature
0A76 C0E0       752            push acc
0A78 740C       752            mov a, #0xC
0A7A 120083     752            lcall ?WriteCommand
0A7D D0E0       752            pop acc
0A7F 0533       753       inc x+0
0A81            754       ; if UP is held, increment temperature rapidly
0A81 200312     755       jb hold_button, set_soak_temp_f
0A84 804D       756       sjmp set_soak_temp_g
0A86            757   set_soak_temp_e:
0A86            758       ; decrement soak temperature
0A86 C0E0       759            push acc
0A88 740C       759            mov a, #0xC
0A8A 120083     759            lcall ?WriteCommand
0A8D D0E0       759            pop acc
0A8F 1533       760       dec x+0
0A91            761       ; if DOWN button is held, decrement temperature rapidly
0A91 200302     762       jb hold_button, set_soak_temp_f
0A94 803D       763       sjmp set_soak_temp_g
0A96            764   set_soak_temp_f:
0A96            765       ; update display and wait 25 ms
0A96 1200DA     766       lcall hex2bcd
0A99 C0E0       767            push acc
0A9B 7408       767            mov a, #8
0A9D 14         767            dec a
0A9E 1200BF     767            lcall ?Set_Cursor_1 ; Select column and row
0AA1 D0E0       767            pop acc
0AA3 C000       767            push ar0
0AA5 A83C       767            mov r0, bcd+1
0AA7 1200C4     767            lcall ?Display_BCD
0AAA D000       767            pop ar0
0AAC C000       767            push ar0
0AAE A83B       767            mov r0, bcd+0
0AB0 1200C4     767            lcall ?Display_BCD
0AB3 D000       767            pop ar0
0AB5            767            ; Replace all the zeros to the left with blanks
0AB5 C0E0       767            push acc
0AB7 7408       767            mov a, #8
0AB9 14         767            dec a
0ABA 1200BF     767            lcall ?Set_Cursor_1 ; Select column and row
0ABD D0E0       767            pop acc
0ABF 12034A     767            lcall replace_zeros
0AC2 C002       768            push AR2
0AC4 7A19       768            mov R2, #25
0AC6 120039     768            lcall ?Wait_Milli_Seconds
0AC9 D002       768            pop AR2
0ACB            769       ; if UP is held, increment temperature
0ACB 308756     770       jnb UP, set_soak_temp_h
0ACE            771       ; if DOWN button is held, decrement temperature
0ACE 308558     772       jnb DOWN, set_soak_temp_i
0AD1 C203       773       clr hold_button
0AD3            774   set_soak_temp_g:
0AD3            775       ; update display and wait 250 ms
0AD3 1200DA     776       lcall hex2bcd
0AD6 C0E0       777            push acc
0AD8 7408       777            mov a, #8
0ADA 14         777            dec a
0ADB 1200BF     777            lcall ?Set_Cursor_1 ; Select column and row
0ADE D0E0       777            pop acc
0AE0 C000       777            push ar0
0AE2 A83C       777            mov r0, bcd+1
0AE4 1200C4     777            lcall ?Display_BCD
0AE7 D000       777            pop ar0
0AE9 C000       777            push ar0
0AEB A83B       777            mov r0, bcd+0
0AED 1200C4     777            lcall ?Display_BCD
0AF0 D000       777            pop ar0
0AF2            777            ; Replace all the zeros to the left with blanks
0AF2 C0E0       777            push acc
0AF4 7408       777            mov a, #8
0AF6 14         777            dec a
0AF7 1200BF     777            lcall ?Set_Cursor_1 ; Select column and row
0AFA D0E0       777            pop acc
0AFC 12034A     777            lcall replace_zeros
0AFF C0E0       778            push acc
0B01 740B       778            mov a, #11
0B03 14         778            dec a
0B04 1200BF     778            lcall ?Set_Cursor_1 ; Select column and row
0B07 D0E0       778            pop acc
0B09 C0E0       779            push acc
0B0B 740E       779            mov a, #0xE
0B0D 120083     779            lcall ?WriteCommand
0B10 D0E0       779            pop acc
0B12 C002       780            push AR2
0B14 7AFA       780            mov R2, #250
0B16 120039     780            lcall ?Wait_Milli_Seconds
0B19 D002       780            pop AR2
0B1B            781       ; if UP is held, set a flag so the program knows
0B1B 308706     782       jnb UP, set_soak_temp_h
0B1E            783       ; if DOWN button is held, set a flag so the program knows 
0B1E 308508     784       jnb DOWN, set_soak_temp_i
0B21 020A3C     785       ljmp set_soak_temp_a
0B24            786   set_soak_temp_h:
0B24 D203       787       setb hold_button
0B26 020A3C     788       ljmp set_soak_temp_a
0B29            789   set_soak_temp_i:
0B29 D203       790       setb hold_button
0B2B 020A44     791       ljmp set_soak_temp_b
0B2E            792   
0B2E            793   ; set reflow temp
0B2E            794   ; MAX: 240
0B2E            795   ; MIN: 120
0B2E            796   set_reflow_temp:
0B2E 854133     797       mov x+0, reflowtemp
0B31 C0E0       798            push acc
0B33 740B       798            mov a, #11
0B35 14         798            dec a
0B36 1200BD     798            lcall ?Set_Cursor_2 ; Select column and row
0B39 D0E0       798            pop acc
0B3B C0E0       799            push acc
0B3D 740E       799            mov a, #0xE
0B3F 120083     799            lcall ?WriteCommand
0B42 D0E0       799            pop acc
0B44            800       ; if BOOT_BUTTON is being pressed, wait for release
0B44 30C5FD     801       jnb BOOT_BUTTON, $
0B47            802   set_reflow_temp_a:
0B47            803       ; if UP is pressed, increment temperature
0B47 208705     804       jb UP, set_reflow_temp_b
0B4A E533       805       mov a, x+0
0B4C            806       ; if temperature < 240, increment temperature
0B4C B4F032     807       cjne a, #0xF0, set_reflow_temp_d
0B4F            808   set_reflow_temp_b:
0B4F            809       ; if DOWN button is pressed, increment temperature  
0B4F 208505     810       jb DOWN, set_reflow_temp_c
0B52 E533       811       mov a, x+0
0B54            812       ; if temperature > 0, decrement temperature
0B54 B4783A     813       cjne a, #0x78, set_reflow_temp_e
0B57            814   set_reflow_temp_c:  
0B57 C203       815       clr hold_button
0B59 C0E0       816            push acc
0B5B 740B       816            mov a, #11
0B5D 14         816            dec a
0B5E 1200BD     816            lcall ?Set_Cursor_2 ; Select column and row
0B61 D0E0       816            pop acc
0B63 C0E0       817            push acc
0B65 740E       817            mov a, #0xE
0B67 120083     817            lcall ?WriteCommand
0B6A D0E0       817            pop acc
0B6C            818       ; if BOOT_BUTTON is pressed, set reflow time
0B6C 20C5D8     819       jb BOOT_BUTTON, set_reflow_temp_a
0B6F C002       820            push AR2
0B71 7A32       820            mov R2, #50
0B73 120039     820            lcall ?Wait_Milli_Seconds
0B76 D002       820            pop AR2 ; debounce time
0B78 20C5CC     821       jb BOOT_BUTTON, set_reflow_temp_a
0B7B 853341     822       mov reflowtemp, x+0
0B7E 020C39     823       ljmp setup_done
0B81            824   set_reflow_temp_d:
0B81            825       ; increment reflow temperature
0B81 C0E0       826            push acc
0B83 740C       826            mov a, #0xC
0B85 120083     826            lcall ?WriteCommand
0B88 D0E0       826            pop acc
0B8A 0533       827       inc x+0
0B8C            828       ; if UP is held, increment temperature rapidly
0B8C 200312     829       jb hold_button, set_reflow_temp_f
0B8F 804D       830       sjmp set_reflow_temp_g
0B91            831   set_reflow_temp_e:
0B91            832       ; decrement reflow temperature
0B91 C0E0       833            push acc
0B93 740C       833            mov a, #0xC
0B95 120083     833            lcall ?WriteCommand
0B98 D0E0       833            pop acc
0B9A 1533       834       dec x+0
0B9C            835       ; if DOWN button is held, decrement temperature rapidly
0B9C 200302     836       jb hold_button, set_reflow_temp_f
0B9F 803D       837       sjmp set_reflow_temp_g
0BA1            838   set_reflow_temp_f:
0BA1            839       ; update display and wait 25 ms
0BA1 1200DA     840       lcall hex2bcd
0BA4 C0E0       841            push acc
0BA6 7408       841            mov a, #8
0BA8 14         841            dec a
0BA9 1200BD     841            lcall ?Set_Cursor_2 ; Select column and row
0BAC D0E0       841            pop acc
0BAE C000       841            push ar0
0BB0 A83C       841            mov r0, bcd+1
0BB2 1200C4     841            lcall ?Display_BCD
0BB5 D000       841            pop ar0
0BB7 C000       841            push ar0
0BB9 A83B       841            mov r0, bcd+0
0BBB 1200C4     841            lcall ?Display_BCD
0BBE D000       841            pop ar0
0BC0            841            ; Replace all the zeros to the left with blanks
0BC0 C0E0       841            push acc
0BC2 7408       841            mov a, #8
0BC4 14         841            dec a
0BC5 1200BD     841            lcall ?Set_Cursor_2 ; Select column and row
0BC8 D0E0       841            pop acc
0BCA 12034A     841            lcall replace_zeros
0BCD C002       842            push AR2
0BCF 7A19       842            mov R2, #25
0BD1 120039     842            lcall ?Wait_Milli_Seconds
0BD4 D002       842            pop AR2
0BD6            843       ; if UP is held, increment temperature
0BD6 308756     844       jnb UP, set_reflow_temp_h
0BD9            845       ; if DOWN button is held, decrement temperature
0BD9 308558     846       jnb DOWN, set_reflow_temp_i
0BDC C203       847       clr hold_button
0BDE            848   set_reflow_temp_g:
0BDE            849       ; update display and wait 250 ms
0BDE 1200DA     850       lcall hex2bcd
0BE1 C0E0       851            push acc
0BE3 7408       851            mov a, #8
0BE5 14         851            dec a
0BE6 1200BD     851            lcall ?Set_Cursor_2 ; Select column and row
0BE9 D0E0       851            pop acc
0BEB C000       851            push ar0
0BED A83C       851            mov r0, bcd+1
0BEF 1200C4     851            lcall ?Display_BCD
0BF2 D000       851            pop ar0
0BF4 C000       851            push ar0
0BF6 A83B       851            mov r0, bcd+0
0BF8 1200C4     851            lcall ?Display_BCD
0BFB D000       851            pop ar0
0BFD            851            ; Replace all the zeros to the left with blanks
0BFD C0E0       851            push acc
0BFF 7408       851            mov a, #8
0C01 14         851            dec a
0C02 1200BD     851            lcall ?Set_Cursor_2 ; Select column and row
0C05 D0E0       851            pop acc
0C07 12034A     851            lcall replace_zeros
0C0A C0E0       852            push acc
0C0C 740B       852            mov a, #11
0C0E 14         852            dec a
0C0F 1200BD     852            lcall ?Set_Cursor_2 ; Select column and row
0C12 D0E0       852            pop acc
0C14 C0E0       853            push acc
0C16 740E       853            mov a, #0xE
0C18 120083     853            lcall ?WriteCommand
0C1B D0E0       853            pop acc
0C1D C002       854            push AR2
0C1F 7AFA       854            mov R2, #250
0C21 120039     854            lcall ?Wait_Milli_Seconds
0C24 D002       854            pop AR2
0C26            855       ; if UP is held, set a flag so the program knows
0C26 308706     856       jnb UP, set_reflow_temp_h
0C29            857       ; if DOWN button is held, set a flag so the program knows 
0C29 308508     858       jnb DOWN, set_reflow_temp_i
0C2C 020B47     859       ljmp set_reflow_temp_a
0C2F            860   set_reflow_temp_h:
0C2F D203       861       setb hold_button
0C31 020B47     862       ljmp set_reflow_temp_a
0C34            863   set_reflow_temp_i:
0C34 D203       864       setb hold_button
0C36 020B4F     865       ljmp set_reflow_temp_b
0C39            866   
0C39            867   setup_done:
0C39 C0E0       868            push acc
0C3B 740C       868            mov a, #0xC
0C3D 120083     868            lcall ?WriteCommand
0C40 D0E0       868            pop acc
0C42            869       ; display current temperature
0C42 C0E0       870            push acc
0C44 7401       870            mov a, #1
0C46 14         870            dec a
0C47 1200BF     870            lcall ?Set_Cursor_1 ; Select column and row
0C4A D0E0       870            pop acc
0C4C C083       871            push dph
0C4E C082       871            push dpl
0C50 C0E0       871            push acc
0C52 9004D3     871            mov dptr, #CURRENT_TEMP
0C55 1200B2     871            lcall ?Send_Constant_String
0C58 D0E0       871            pop acc
0C5A D082       871            pop dpl
0C5C D083       871            pop dph
0C5E 1203F7     872       lcall Read_ADC
0C61 C0E0       873            push acc
0C63 7408       873            mov a, #8
0C65 14         873            dec a
0C66 1200BF     873            lcall ?Set_Cursor_1 ; Select column and row
0C69 D0E0       873            pop acc
0C6B C000       873            push ar0
0C6D A83C       873            mov r0, bcd+1
0C6F 1200C4     873            lcall ?Display_BCD
0C72 D000       873            pop ar0
0C74 C000       873            push ar0
0C76 A83B       873            mov r0, bcd+0
0C78 1200C4     873            lcall ?Display_BCD
0C7B D000       873            pop ar0
0C7D            873            ; Replace all the zeros to the left with blanks
0C7D C0E0       873            push acc
0C7F 7408       873            mov a, #8
0C81 14         873            dec a
0C82 1200BF     873            lcall ?Set_Cursor_1 ; Select column and row
0C85 D0E0       873            pop acc
0C87 12034A     873            lcall replace_zeros
0C8A 0206A6     874       ljmp State_0
0C8D            875   
0C8D            876       ;-------------------------------------------------- SOUND ----------------------------------------------------
0C8D            877   ; NEED TO FIGURE OUT INDEX AND BYTES OF SOUNDS
0C8D            878   
0C8D            879   play_temp: 
0C8D E549       880         mov a, temp_sound_state
0C8F            881   
0C8F            882   ;temp_sound_state0:
0C8F            883   ;      cjne a, #0, temp_sound_state1 ;check if state is not 0, if yes go to state 1 
0C8F            884   ;      jnb  playstart_flag, temp_sound_state0_done
0C8F            885   ;      clr C
0C8F            886   ;      mov a,  
0C8F            887        
0C8F            888   Sound_Heating_To_Soak:
0C8F C28E       889            clr TR1 ; Stop Timer 1 ISR from playing previous request
0C91 D2A5       890            setb FLASH_CE
0C93 C2A6       891            clr SPEAKER ; Turn off speaker.
0C95            892            
0C95 C2A5       893            clr FLASH_CE ; Enable SPI Flash
0C97 7403       894            mov a, #READ_BYTES
0C99 120561     895            lcall Send_SPI
0C9C            896            ; Set the initial position in memory where to start playing
0C9C 7400       897            mov a, #0x00
0C9E 120561     898            lcall Send_SPI
0CA1 7400       899            mov a, #0x00
0CA3 120561     900            lcall Send_SPI
0CA6 7400       901            mov a, #0x00
0CA8 120561     902            lcall Send_SPI
0CAB 7400       903            mov a, #0x00 ; Request first byte to send to DAC
0CAD 120561     904            lcall Send_SPI
0CB0            905            
0CB0 754800     906            mov w+2, #0x00
0CB3 754766     907            mov w+1, #0x66
0CB6 754641     908            mov w+0, #0x41
0CB9            909            
0CB9 D2A6       910            setb SPEAKER ; Turn on speaker.
0CBB D28E       911            setb TR1 ; Start playback by enabling Timer 1
0CBD 22         912       ret
0CBE            913   
0CBE            914   Sound_Soaking:
0CBE C28E       915            clr TR1 ; Stop Timer 1 ISR from playing previous request
0CC0 D2A5       916            setb FLASH_CE
0CC2 C2A6       917            clr SPEAKER ; Turn off speaker.
0CC4            918            
0CC4 C2A5       919            clr FLASH_CE ; Enable SPI Flash
0CC6 7403       920            mov a, #READ_BYTES
0CC8 120561     921            lcall Send_SPI
0CCB            922            ; Set the initial position in memory where to start playing
0CCB 7401       923            mov a, #0x01
0CCD 120561     924            lcall Send_SPI
0CD0 740F       925            mov a, #0x0f
0CD2 120561     926            lcall Send_SPI
0CD5 7421       927            mov a, #0x21
0CD7 120561     928            lcall Send_SPI
0CDA 7400       929            mov a, #0x00 ; Request first byte to send to DAC
0CDC 120561     930            lcall Send_SPI
0CDF            931            
0CDF 754801     932            mov w+2, #0x01
0CE2 75474B     933            mov w+1, #0x4b
0CE5 7546E7     934            mov w+0, #0xe7
0CE8            935            
0CE8 D2A6       936            setb SPEAKER ; Turn on speaker.
0CEA D28E       937            setb TR1 ; Start playback by enabling Timer 1
0CEC 22         938       ret
0CED            939   
0CED            940   Sound_Heating_To_Reflow:
0CED C28E       941            clr TR1 ; Stop Timer 1 ISR from playing previous request
0CEF D2A5       942            setb FLASH_CE
0CF1 C2A6       943            clr SPEAKER ; Turn off speaker.
0CF3            944            
0CF3 C2A5       945            clr FLASH_CE ; Enable SPI Flash
0CF5 7403       946            mov a, #READ_BYTES
0CF7 120561     947            lcall Send_SPI
0CFA            948            ; Set the initial position in memory where to start playing
0CFA 7402       949            mov a, #0x02
0CFC 120561     950            lcall Send_SPI
0CFF 745B       951            mov a, #0x5b
0D01 120561     952            lcall Send_SPI
0D04 7408       953            mov a, #0x08
0D06 120561     954            lcall Send_SPI
0D09 7400       955            mov a, #0x00 ; Request first byte to send to DAC
0D0B 120561     956            lcall Send_SPI
0D0E            957            
0D0E 754800     958            mov w+2, #0x
0D11 754747     959            mov w+1, #0x47
0D14 75465A     960            mov w+0, #0x5a
0D17            961            
0D17 D2A6       962            setb SPEAKER ; Turn on speaker.
0D19 D28E       963            setb TR1 ; Start playback by enabling Timer 1
0D1B 22         964       ret
0D1C            965   
0D1C            966   Sound_Reflowing:
0D1C C28E       967            clr TR1 ; Stop Timer 1 ISR from playing previous request
0D1E D2A5       968            setb FLASH_CE
0D20 C2A6       969            clr SPEAKER ; Turn off speaker.
0D22            970            
0D22 C2A5       971            clr FLASH_CE ; Enable SPI Flash
0D24 7403       972            mov a, #READ_BYTES
0D26 120561     973            lcall Send_SPI
0D29            974            ; Set the initial position in memory where to start playing
0D29 7401       975            mov a, #0x01
0D2B 120561     976            lcall Send_SPI
0D2E 7428       977            mov a, #0x28
0D30 120561     978            lcall Send_SPI
0D33 7407       979            mov a, #0x07
0D35 120561     980            lcall Send_SPI
0D38 7401       981            mov a, #0x01 ; Request first byte to send to DAC
0D3A 120561     982            lcall Send_SPI
0D3D            983            
0D3D 754800     984            mov w+2, #0x00
0D40 7547A5     985            mov w+1, #0xa5
0D43 7546F4     986            mov w+0, #0xf4
0D46            987            
0D46 D2A6       988            setb SPEAKER ; Turn on speaker.
0D48 D28E       989            setb TR1 ; Start playback by enabling Timer 1
0D4A 22         990       ret
0D4B            991   
0D4B            992   Sound_Cooldown:
0D4B C28E       993            clr TR1 ; Stop Timer 1 ISR from playing previous request
0D4D D2A5       994            setb FLASH_CE
0D4F C2A6       995            clr SPEAKER ; Turn off speaker.
0D51            996            
0D51 C2A5       997            clr FLASH_CE ; Enable SPI Flash
0D53 7403       998            mov a, #READ_BYTES
0D55 120561     999            lcall Send_SPI
0D58           1000            ; Set the initial position in memory where to start playing
0D58 7401      1001            mov a, #0x01
0D5A 120561    1002            lcall Send_SPI
0D5D 7447      1003            mov a, #0x47
0D5F 120561    1004            lcall Send_SPI
0D62 7432      1005            mov a, #0x32
0D64 120561    1006            lcall Send_SPI
0D67 7401      1007            mov a, #0x01 ; Request first byte to send to DAC
0D69 120561    1008            lcall Send_SPI
0D6C           1009            
0D6C 754800    1010            mov w+2, #0x00
0D6F 7547C3    1011            mov w+1, #0xc3
0D72 754635    1012            mov w+0, #0x35
0D75           1013            
0D75 D2A6      1014            setb SPEAKER ; Turn on speaker.
0D77 D28E      1015            setb TR1 ; Start playback by enabling Timer 1
0D79 22        1016       ret
0D7A           1017   
0D7A           1018   Sound_Error:
0D7A C28E      1019            clr TR1 ; Stop Timer 1 ISR from playing previous request
0D7C D2A5      1020            setb FLASH_CE
0D7E C2A6      1021            clr SPEAKER ; Turn off speaker.
0D80           1022            
0D80 C2A5      1023            clr FLASH_CE ; Enable SPI Flash
0D82 7403      1024            mov a, #READ_BYTES
0D84 120561    1025            lcall Send_SPI
0D87           1026            ; Set the initial position in memory where to start playing
0D87 7402      1027            mov a, #0x02
0D89 120561    1028            lcall Send_SPI
0D8C 740B      1029            mov a, #0x0b
0D8E 120561    1030            lcall Send_SPI
0D91 7467      1031            mov a, #0x67
0D93 120561    1032            lcall Send_SPI
0D96 7402      1033            mov a, #0x02 ; Request first byte to send to DAC
0D98 120561    1034            lcall Send_SPI
0D9B           1035            
0D9B 754800    1036            mov w+2, #0x00
0D9E 7547F5    1037            mov w+1, #0xf5
0DA1 754628    1038            mov w+0, #0x28
0DA4           1039            
0DA4 D2A6      1040            setb SPEAKER ; Turn on speaker.
0DA6 D28E      1041            setb TR1 ; Start playback by enabling Timer 1
0DA8 22        1042       ret
0DA9           1043       
0DA9           1044   
0DA9           1045       
