                  2   $LIST
0000              4   
0000              5   CLK  EQU 22118400
0000              6   BAUD equ 115200
0000              7   BRG_VAL equ (0x100-(CLK/(16*BAUD)))
0000              8   
0000              9   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             10   TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
0000             11   TIMER1_RATE    EQU 22050     ; 22050Hz is the sampling rate of the wav file we are playing
0000             12   TIMER1_RELOAD  EQU 0x10000-(CLK/TIMER1_RATE)
0000             13   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             14   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             15   
0000             16   ; The pins used for SPI
0000             17   FLASH_CE  EQU  P2.5
0000             18   PIN_TWO_FOUR   EQU  P2.4 
0000             19   PIN_TWO_ONE   EQU  P2.1
0000             20   PIN_TWO_ZERO   EQU  P2.0 
0000             21   
0000             22   BOOT_BUTTON   equ P4.5
0000             23   SPEAKER  EQU P2.6 ; Used with a MOSFET to turn off speaker when not in use
0000             24   UP            equ P0.7
0000             25   DOWN               equ P0.5
0000             26   ; Input 3 bit binary state from TIME/FSM MCU
0000             27   STATE_bit0      equ P1.2
0000             28   STATE_bit1      equ P1.3
0000             29   STATE_bit2      equ P1.4
0000             30   STATE_STABLE    equ P1.5
0000             31   ; Outputs to Time/FSM MCU
0000             32    TEMP_OK        equ P1.0
0000             33    TEMP_50        equ P1.1
0000             34    OVEN_CTL_PIN   equ P1.6
0000             35   
0000             36    ; Commands supported by the SPI flash memory according to the datasheet
0000             37   WRITE_ENABLE     EQU 0x06  ; Address:0 Dummy:0 Num:0
0000             38   WRITE_DISABLE    EQU 0x04  ; Address:0 Dummy:0 Num:0
0000             39   READ_STATUS      EQU 0x05  ; Address:0 Dummy:0 Num:1 to infinite
0000             40   READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
0000             41   READ_SILICON_ID  EQU 0xab  ; Address:0 Dummy:3 Num:1 to infinite
0000             42   FAST_READ        EQU 0x0b  ; Address:3 Dummy:1 Num:1 to infinite
0000             43   WRITE_STATUS     EQU 0x01  ; Address:0 Dummy:0 Num:1
0000             44   WRITE_BYTES      EQU 0x02  ; Address:3 Dummy:0 Num:1 to 256
0000             45   ERASE_ALL        EQU 0xc7  ; Address:0 Dummy:0 Num:0
0000             46   ERASE_BLOCK      EQU 0xd8  ; Address:3 Dummy:0 Num:0
0000             47   READ_DEVICE_ID   EQU 0x9f  ; Address:0 Dummy:2 Num:1 to infinite
0000             48   
0000             49   org 0000H
0000 020AE7      50      ljmp MainProgram
0003             51   
0003             52   ; External interrupt 0 vector (not used in this code)
0003             53   org 0x0003
0003 32          54            reti
0004             55   
0004             56   ; Timer/Counter 0 overflow interrupt vector (not used in this code)
000B             57   org 0x000B
000B 32          58            reti
000C             59   
000C             60   ; External interrupt 1 vector (not used in this code)
0013             61   org 0x0013
0013 32          62            reti
0014             63   
0014             64   ; Timer/Counter 1 overflow interrupt vector
001B             65   org 0x001B
001B 020A78      66            ljmp Timer1_ISR
001E             67   
001E             68   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             69   org 0x0023 
0023 32          70            reti
0024             71            
0024             72   ; Timer/Counter 2 overflow interrupt vector
002B             73   org 0x002B
002B 020AB7      74            ljmp Timer2_ISR
002E             75   
0030             76   DSEG at 30H
0030             77   Count1ms:           ds 2
0032             78   Count5s:            ds 1 
0033             79   x:                  ds 4 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file
0037             80   y:                  ds 4 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file
003B             81   bcd:                ds 5 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file 
0040             82   soaktemp:           ds 1
0041             83   reflowtemp:         ds 1
0042             84   volt_reading:       ds 2 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file
0044             85   temp_reading:       ds 1
0045             86   fsm_state:          ds 1 
0046             87   w:                               ds 3 ; 24-bit play counter.  Decremented in Timer 1 ISR.
0049             88   temp_sound_state:   ds 1 
004A             89   
004A             90   
0000             91   BSEG
0000             92   seconds_flag:       dbit 1
0001             93   five_seconds_flag:  dbit 1
0002             94   mf:                 dbit 1 ; this dseg is used in the INC file, any changes to name need to also be updated in INC file
0003             95   hold_button:        dbit 1
0004             96   sound_flag:         dbit 1
0005             97   play_done:          dbit 1
0006             98   
002E             99   CSEG
002E            100   ; These ’EQU’ must match the wiring between the microcontroller and ADC (used in the INC file)
002E            101   CE_ADC  EQU P0.4
002E            102   MY_MOSI EQU P0.3
002E            103   MY_MISO EQU P0.2
002E            104   MY_SCLK EQU P0.1
002E            105   ; These 'equ' must match the hardware wiring
002E            106   ; They are used by 'LCD_4bit.inc'
002E            107   LCD_RS equ P3.2
002E            108   ; LCD_RW equ Px.x ; Always grounded
002E            109   LCD_E  equ P3.3
002E            110   LCD_D4 equ P3.4
002E            111   LCD_D5 equ P3.5
002E            112   LCD_D6 equ P3.6
002E            113   LCD_D7 equ P3.7
002E            114   
                553   $LIST
                119       $LIST
08B5            121   
08B5            122   ;                   1234567890123456
08B5 536F616B   123   SOAK_TEMP:      db 'Soak:   xxx', 0xDF, 'C   ', 0
     3A202020
     787878DF
     43202020
     00
08C6 5265666C   124   REFLOW_TEMP:    db 'Reflow: xxx', 0xDF, 'C   ', 0
     6F773A20
     787878DF
     43202020
     00
08D7 54656D70   125   CURRENT_TEMP:   db 'Temp:   xxx', 0xDF, 'C   ', 0
     3A202020
     787878DF
     43202020
     00
08E8 54617267   126   TARGET_TEMP:    db 'Target: xxx', 0xDF, 'C   ', 0
     65743A20
     787878DF
     43202020
     00
08F9 4F56454E   127   OVEN_OFF:       db 'OVEN OFF        ', 0
     204F4646
     20202020
     20202020
     00
090A            128   
090A            129   
090A            130   ; Approximate index of sounds in file 'nsound.wav'
090A            131   sound_index:       ; index | number
090A 003937     132       db 0x00, 0x39, 0x37 ; 0 1
090D 00E45D     133       db 0x00, 0xe4, 0x5d ; 1 2
0910 019444     134       db 0x01, 0x94, 0x44 ; 2 3
0913 024B4A     135       db 0x02, 0x4b, 0x4a ; 3 4
0916 02F671     136       db 0x02, 0xf6, 0x71 ; 4 5
0919 039CD6     137       db 0x03, 0x9c, 0xd6 ; 5 6
091C 04433C     138       db 0x04, 0x43, 0x3c ; 6 7
091F 04FCA1     139       db 0x04, 0xfc, 0xa1 ; 7 8
0922 05A7C8     140       db 0x05, 0xa7, 0xc8 ; 8 9
0925 066132     141       db 0x06, 0x61, 0x32 ; 9 10
0928 0702D5     142       db 0x07, 0x02, 0xd5 ; 10 11
092B 07ADF9     143       db 0x07, 0xad, 0xf9 ; 11 12
092E 085DE1     144       db 0x08, 0x5d, 0xe1 ; 12 13
0931 09174A     145       db 0x09, 0x17, 0x4a ; 13 14
0934 09B68A     146       db 0x09, 0xb6, 0x8a ; 14 15
0937 0A5F50     147       db 0x0a, 0x5f, 0x50 ; 15 16
093A 0B0CD6     148       db 0x0b, 0x0c, 0xd6 ; 16 17
093D 0BBA5C     149       db 0x0b, 0xba, 0x5c ; 17 18
0940 0C6CA5     150       db 0x0c, 0x6c, 0xa5 ; 18 19
0943 0CFDA3     151       db 0x0c, 0xfd, 0xa3 ; 19 20
0946 0DBBCC     152       db 0x0d, 0xbb, 0xcc ; 20 30
0949 0E6953     153       db 0x0e, 0x69, 0x53 ; 21 40
094C 0F03D2     154       db 0x0f, 0x03, 0xd2 ; 22 50
094F 0FC1FB     155       db 0x0f, 0xc1, 0xfb ; 23 60
0952 106AC2     156       db 0x10, 0x6a, 0xc2 ; 24 70
0955 1115E8     157       db 0x11, 0x15, 0xe8 ; 25 80
0958 11CA8E     158       db 0x11, 0xca, 0x8e ; 26 90
095B 127812     159       db 0x12, 0x78, 0x12 ; 27 100
095E 1327FB     160       db 0x13, 0x27, 0xfb ; 28 200
0961 13D0C0     161       db 0x13, 0xd0, 0xc0 ; 29 idle
0964 147725     162       db 0x14, 0x77, 0x25 ; 30 heating to soak
0967 153551     163       db 0x15, 0x35, 0x51 ; 31 soaking
096A 15CD72     164       db 0x15, 0xcd, 0x72 ; 32 heating to reflow
096D 168B8B     165       db 0x16, 0x8b, 0x8b ; 33 reflowing
0970 172ADE     166       db 0x17, 0x2a, 0xde ; 34 cooling 
0973 17D605     167       db 0x17, 0xd6, 0x05 ; 35 error
0976 187ECC     168       db 0x18, 0x7e, 0xcc 
0979            169   
0979            170   ; Size of each sound in 'sound_index'
0979            171   Size_sound:
0979 00AB26     172       db 0x00, 0xab, 0x26 ; 0 
097C 00AFE7     173       db 0x00, 0xaf, 0xe7 ; 1 
097F 00B706     174       db 0x00, 0xb7, 0x06 ; 2 
0982 00AB27     175       db 0x00, 0xab, 0x27 ; 3 
0985 00A665     176       db 0x00, 0xa6, 0x65 ; 4 
0988 00A666     177       db 0x00, 0xa6, 0x66 ; 5 
098B 00B965     178       db 0x00, 0xb9, 0x65 ; 6 
098E 00AB27     179       db 0x00, 0xab, 0x27 ; 7 
0991 00B96A     180       db 0x00, 0xb9, 0x6a ; 8 
0994 00A1A3     181       db 0x00, 0xa1, 0xa3 ; 9 
0997 00AB24     182       db 0x00, 0xab, 0x24 ; 10 
099A 00AFE8     183       db 0x00, 0xaf, 0xe8 ; 11 
099D 00B969     184       db 0x00, 0xb9, 0x69 ; 12 
09A0 009F40     185       db 0x00, 0x9f, 0x40 ; 13 
09A3 00A8C6     186       db 0x00, 0xa8, 0xc6 ; 14 
09A6 00AD86     187       db 0x00, 0xad, 0x86 ; 15 
09A9 00AD86     188       db 0x00, 0xad, 0x86 ; 16 
09AC 00B249     189       db 0x00, 0xb2, 0x49 ; 17 
09AF 0090FE     190       db 0x00, 0x90, 0xfe ; 18 
09B2 00BE29     191       db 0x00, 0xbe, 0x29 ; 19 
09B5 00AD87     192       db 0x00, 0xad, 0x87 ; 20 
09B8 009A7F     193       db 0x00, 0x9a, 0x7f ; 21 
09BB 00BE29     194       db 0x00, 0xbe, 0x29 ; 22 
09BE 00A8C7     195       db 0x00, 0xa8, 0xc7 ; 23 
09C1 00AB26     196       db 0x00, 0xab, 0x26 ; 24 
09C4 00B4A6     197       db 0x00, 0xb4, 0xa6 ; 25 
09C7 00AD84     198       db 0x00, 0xad, 0x84 ; 26 
09CA 00AFE9     199       db 0x00, 0xaf, 0xe9 ; 27 
09CD 00A8C5     200       db 0x00, 0xa8, 0xc5 ; 28 
09D0 00A665     201       db 0x00, 0xa6, 0x65 ; 29 
09D3 00BE2C     202       db 0x00, 0xbe, 0x2c ; 30 
09D6 009821     203       db 0x00, 0x98, 0x21 ; 31 
09D9 00BE19     204       db 0x00, 0xbe, 0x19 ; 32 
09DC 009F53     205       db 0x00, 0x9f, 0x53 ; 33 
09DF 00AB27     206       db 0x00, 0xab, 0x27 ; 34 
09E2 00A8C7     207       db 0x00, 0xa8, 0xc7 ; 35 
09E5            208   
09E5            209   
09E5            210   
09E5            211   
09E5            212   
09E5            213   
09E5            214   
09E5            215   
09E5            216   ;---------------------------------;
09E5            217   ; Routine to initialize the ISR   ;
09E5            218   ; for timer 0                     ;
09E5            219   ;---------------------------------;
09E5            220   Timer0_Init:
09E5 E589       221            mov a, TMOD
09E7 54F0       222            anl a, #0xf0 ; 11110000 Clear the bits for timer 0
09E9 4401       223            orl a, #0x01 ; 00000001 Configure timer 0 as 16-timer
09EB F589       224            mov TMOD, a
09ED 758CEA     225            mov TH0, #high(TIMER0_RELOAD)
09F0 758AE8     226            mov TL0, #low(TIMER0_RELOAD)
09F3            227            ; Set autoreload value
09F3 75F4EA     228            mov RH0, #high(TIMER0_RELOAD)
09F6 75F2E8     229            mov RL0, #low(TIMER0_RELOAD)
09F9            230            ; Enable the timer and interrupts
09F9 D2A9       231       setb ET0  ; Enable timer 0 interrupt
09FB D28C       232       setb TR0  ; Start timer 0
09FD 22         233            ret
09FE            234            
09FE            235   ;---------------------------------;
09FE            236   ; ISR for timer 0                 ;
09FE            237   ;---------------------------------;
09FE            238   Timer0_ISR:
09FE 200401     239            jb sound_flag, Start_Chirping
0A01 32         240            reti
0A02            241   
0A02            242   Start_Chirping:
0A02 B2A6       243            cpl SPEAKER 
0A04 32         244            reti
0A05            245   
0A05            246   ;---------------------------------;
0A05            247   ; Routine to initialize the ISR   ;
0A05            248   ; for timer 1                     ;
0A05            249   ;---------------------------------;
0A05            250   Timer1_Init:
0A05            251            ; Configure P2.0, P2.4, P2.5 as open drain outputs
0A05 43CE31     252            orl P2M0, #0b_0011_0001
0A08 43CF31     253            orl P2M1, #0b_0011_0001
0A0B D2A1       254            setb PIN_TWO_ONE  ; Configured as input
0A0D D2A5       255            setb FLASH_CE ; CS=1 for SPI flash memory
0A0F C2A0       256            clr PIN_TWO_ZERO   ; Rest state of SCLK=0
0A11 C2A6       257            clr SPEAKER   ; Turn off speaker.
0A13            258            
0A13            259            ; Configure timer 1
0A13 53890F     260            anl     TMOD, #0x0F ; Clear the bits of timer 1 in TMOD
0A16 438910     261            orl     TMOD, #0x10 ; Set timer 1 in 16-bit timer mode.  Don't change the bits of timer 0
0A19 758DFC     262            mov TH1, #high(TIMER1_RELOAD)
0A1C 758B15     263            mov TL1, #low(TIMER1_RELOAD)
0A1F            264            ; Set autoreload value
0A1F 75F5FC     265            mov RH1, #high(TIMER1_RELOAD)
0A22 75F315     266            mov RL1, #low(TIMER1_RELOAD)
0A25            267   
0A25            268            ; Enable the timer and interrupts
0A25 D2AB       269       setb ET1  ; Enable timer 1 interrupt
0A27 C28E       270            clr TR1 ; Timer 1 is only enabled to play stored sound
0A29            271   
0A29            272            ; Configure the DAC.  The DAC output we are using is P2.3, but P2.2 is also reserved.
0A29 75A5A0     273            mov DADI, #0b_1010_0000 ; ACON=1
0A2C 75A43A     274            mov DADC, #0b_0011_1010 ; Enabled, DAC mode, Left adjusted, CLK/4
0A2F 75AD80     275            mov DADH, #0x80 ; Middle of scale
0A32 75AC00     276            mov DADL, #0
0A35 43A440     277            orl DADC, #0b_0100_0000 ; Start DAC by GO/BSY=1
0A38            278   
0A38            279   check_DAC_init:
0A38 E5A4       280            mov a, DADC
0A3A 20E6FB     281            jb acc.6, check_DAC_init ; Wait for DAC to finish
0A3D D2AF       282            setb EA ; Enable interrupts
0A3F 22         283       ret
0A40            284   
0A40            285   ;---------------------------------;
0A40            286   ; Routine to initialize the ISR   ;
0A40            287   ; for timer 2                     ;
0A40            288   ;---------------------------------;
0A40            289   Timer2_Init:
0A40 75C800     290            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
0A43 75CDA9     291            mov TH2, #high(TIMER2_RELOAD)
0A46 75CC9A     292            mov TL2, #low(TIMER2_RELOAD)
0A49            293            ; Set the reload value
0A49 75CBA9     294            mov RCAP2H, #high(TIMER2_RELOAD)
0A4C 75CA9A     295            mov RCAP2L, #low(TIMER2_RELOAD)
0A4F            296            ; Init one millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
0A4F E4         297            clr a
0A50 F530       298            mov Count1ms+0, a
0A52 F531       299            mov Count1ms+1, a
0A54            300       ; Init five second interrupt counter
0A54 F532       301       mov Count5s, a
0A56            302            ; Enable the timer and interrupts
0A56 D2AD       303       setb ET2  ; Enable timer 2 interrupt
0A58 D2CA       304       setb TR2  ; Enable timer 2
0A5A 22         305            ret
0A5B            306   
0A5B            307   ; Configure the serial port and baud rate
0A5B            308   InitSerialPort:
0A5B            309       ; Since the reset button bounces, we need to wait a bit before
0A5B            310       ; sending messages, otherwise we risk displaying gibberish!
0A5B 79DE       311       mov R1, #222
0A5D 78A6       312       mov R0, #166
0A5F D8FE       313       djnz R0, $   ; 3 cycles->3*45.21123ns*166=22.51519us
0A61 D9FA       314       djnz R1, $-4 ; 22.51519us*222=4.998ms
0A63            315       ; Now we can proceed with the configuration
0A63 438780     316            orl     PCON,#0x80
0A66 759852     317            mov     SCON,#0x52
0A69 759B00     318            mov     BDRCON,#0x00
0A6C 759AF4     319            mov     BRL,#BRG_VAL
0A6F 759B1E     320            mov     BDRCON,#0x1E ; BDRCON=BRR|TBCK|RBCK|SPD;
0A72 22         321       ret
0A73            322   
0A73            323   INIT_SPI:
0A73 D282       324       setb MY_MISO    ; Make MISO an input pin
0A75 C281       325       clr MY_SCLK     ; For mode (0,0) SCLK is zero
0A77 22         326       ret
0A78            327   
0A78            328   ;-------------------------------------;
0A78            329   ; ISR for Timer 1.  Used to playback  ;
0A78            330   ; the WAV file stored in the SPI      ;
0A78            331   ; flash memory.                       ;
0A78            332   ;-------------------------------------;
0A78            333   Timer1_ISR:
0A78            334            ; The registers used in the ISR must be saved in the stack
0A78 C0E0       335            push acc
0A7A C0D0       336            push psw
0A7C            337   
0A7C            338       ; Timer 1 is playing a sound. Set a flag so the main program knows
0A7C C205       339            clr play_done
0A7E            340   
0A7E            341            ; Check if the play counter is zero.  If so, stop playing sound.
0A7E E546       342            mov a, w+0
0A80 4547       343            orl a, w+1
0A82 4548       344            orl a, w+2
0A84 601E       345            jz stop_playing
0A86            346            
0A86            347            ; Decrement play counter 'w'.  In this implementation 'w' is a 24-bit counter.
0A86 74FF       348            mov a, #0xff
0A88 1546       349            dec w+0
0A8A B54607     350            cjne a, w+0, keep_playing
0A8D 1547       351            dec w+1
0A8F B54702     352            cjne a, w+1, keep_playing
0A92 1548       353            dec w+2
0A94            354            
0A94            355   keep_playing:
0A94 D2A6       356            setb SPEAKER
0A96 12042B     357            lcall Send_SPI ; Read the next byte from the SPI Flash...
0A99 F580       358            mov P0, a ; WARNING: Remove this if not using an external DAC to use the pins of P0 as GPIO
0A9B 2480       359            add a, #0x80
0A9D F5AD       360            mov DADH, a ; Output to DAC. DAC output is pin P2.3
0A9F 43A440     361            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
0AA2 800E       362            sjmp Timer1_ISR_Done
0AA4            363   
0AA4            364   stop_playing:
0AA4 C28E       365            clr TR1 ; Stop timer 1
0AA6 D2A5       366            setb FLASH_CE  ; Disable SPI Flash
0AA8 C2A6       367            clr SPEAKER ; Turn off speaker.  Removes hissing noise when not playing sound.
0AAA 75AD80     368            mov DADH, #0x80 ; middle of range
0AAD 43A440     369            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
0AB0            370   
0AB0            371       ; Timer 1 has finished playing a sound. Set a flag so the main program knows         
0AB0 D205       372       setb play_done
0AB2            373   
0AB2            374   Timer1_ISR_Done:
0AB2 D0D0       375            pop psw
0AB4 D0E0       376            pop acc
0AB6 32         377            reti
0AB7            378   
0AB7            379   ;---------------------------------;
0AB7            380   ; ISR for timer 2                 ;
0AB7            381   ; Used to count Time              ;
0AB7            382   ;---------------------------------;
0AB7            383   Timer2_ISR:
0AB7 C2CF       384            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
0AB9            385            ;cpl P1.0 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
0AB9            386            
0AB9            387            ; The two registers used in the ISR must be saved in the stack
0AB9 C0E0       388            push acc
0ABB C0D0       389            push psw
0ABD            390            
0ABD            391            ; Increment the 16-bit one mili second counter
0ABD 0530       392            inc Count1ms+0    ; Increment the low 8-bits first
0ABF E530       393            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0AC1 7002       394            jnz Inc_Done
0AC3 0531       395            inc Count1ms+1
0AC5            396   
0AC5            397   Inc_Done:
0AC5            398            ; Check if 1 second has passed
0AC5 E530       399            mov a, Count1ms+0
0AC7 B4FA18     400            cjne a, #low(250), Timer2_ISR_done ; Warning: this instruction high_low_flags the carry flag!
0ACA E531       401            mov a, Count1ms+1
0ACC B40013     402            cjne a, #high(250), Timer2_ISR_done
0ACF            403            
0ACF            404            ; 1 second has passed. Set a flag so the main program knows
0ACF D200       405            setb seconds_flag ; Let the main program know 1 second has passed
0AD1 E4         406            clr a
0AD2 F530       407            mov Count1ms+0, a
0AD4 F531       408            mov Count1ms+1, a
0AD6 0532       409       inc Count5s
0AD8            410   
0AD8            411   Inc_Done_a:
0AD8            412       ; Check if 5 seconds has passed
0AD8 E532       413       mov a, Count5s
0ADA B40505     414       cjne a, #5, Timer2_ISR_done
0ADD            415       
0ADD            416       ; 5 seconds have passed. Set a flag so the main program knows
0ADD D201       417       setb five_seconds_flag
0ADF 753200     418       mov Count5s, #0
0AE2            419   
0AE2            420   Timer2_ISR_done:
0AE2 D0D0       421            pop psw
0AE4 D0E0       422            pop acc
0AE6 32         423            reti
0AE7            424   
0AE7            425   ;---------------------------------;
0AE7            426   ; Main Program                    ;
0AE7            427   ;---------------------------------;
0AE7            428   MainProgram:
0AE7 75817F     429       mov SP, #7FH ; Set the stack pointer to the begining of idata
0AEA D2AF       430       setb EA   ; Enable Global interrupts
0AEC 75E600     431       mov P0M0, #0
0AEF 75E700     432       mov P0M1, #0
0AF2 75D600     433       mov P1M0, #0
0AF5 75D700     434       mov P1M1, #0
0AF8 75CE00     435       mov P2M0, #0
0AFB 75CF00     436       mov P2M1, #0
0AFE            437       
0AFE 120A5B     438       lcall InitSerialPort
0B01 120A73     439       lcall INIT_SPI
0B04 1209E5     440       lcall Timer0_Init
0B07 120A05     441       lcall Timer1_Init
0B0A            442   
0B0A 120088     443       lcall LCD_4BIT
0B0D 120A40     444       lcall Timer2_Init
0B10            445   
0B10 D292       446       setb STATE_bit0
0B12 D293       447       setb STATE_bit1
0B14 D294       448       setb STATE_bit2
0B16 D295       449       setb STATE_STABLE
0B18            450   
0B18 C290       451       clr TEMP_OK
0B1A C291       452       clr TEMP_50
0B1C C296       453       clr OVEN_CTL_PIN
0B1E            454   
0B1E C200       455       clr seconds_flag
0B20 C201       456       clr five_seconds_flag
0B22 C203       457       clr hold_button
0B24            458   
0B24 753000     459       mov count1ms+0, #0
0B27 753000     460       mov count1ms+0, #0
0B2A            461       ; defualt soaktemp = 150
0B2A 754096     462       mov soaktemp, #0x96
0B2D            463       ; default reflowtemp = 240
0B2D 7541F0     464       mov reflowtemp, #0xF0
0B30            465   
0B30 020E35     466       ljmp setup ; jump to setup after reset
0B33            467   
0B33            468   ;-------------------------------------------------- STATE 0 --------------------------------------------------
0B33            469   ; idle state, reflow oven is off
0B33            470   State_0:
0B33            471       ; check state
0B33 3095FD     472       jnb STATE_STABLE, $ ; wait for state to be stable
0B36 120497     473       lcall read_state 
0B39 B40051     474       cjne a, #0, State_1
0B3C            475   
0B3C            476       ; turn off the oven
0B3C C296       477       clr OVEN_CTL_PIN
0B3E            478   
0B3E            479       ; temperature is set, TEMP_OK = 1
0B3E D290       480       setb TEMP_OK
0B40            481   
0B40            482       ; display "OVEN OFF" message
0B40 C0E0       483            push acc
0B42 7401       483            mov a, #1
0B44 14         483            dec a
0B45 1200BD     483            lcall ?Set_Cursor_2 ; Select column and row
0B48 D0E0       483            pop acc
0B4A C083       484            push dph
0B4C C082       484            push dpl
0B4E C0E0       484            push acc
0B50 9008F9     484            mov dptr, #OVEN_OFF
0B53 1200B2     484            lcall ?Send_Constant_String
0B56 D0E0       484            pop acc
0B58 D082       484            pop dpl
0B5A D083       484            pop dph
0B5C            485   
0B5C            486       ; play sound "Idle"
0B5C 781D       487       mov r0, #29
0B5E 12050A     488       lcall Play_Sound_Using_Index
0B61            489       ; if BOOT_BUTTON is being pressed, wait for release
0B61 30C5FD     490       jnb BOOT_BUTTON, $
0B64            491       
0B64            492   Idle:
0B64            493       ; check state
0B64 3095FD     494       jnb STATE_STABLE, $ ; wait for state to be stable
0B67 120497     495       lcall read_state
0B6A B40020     496       cjne a, #0, State_1
0B6D            497       ; Read tempurature every second
0B6D 30000B     498       jnb seconds_flag, Idle_a
0B70 C200       499       clr seconds_flag
0B72 1203F7     500       lcall Read_ADC
0B75 1204A3     501       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0B78 120396     502       lcall Send_temp_BCD ; display/send temperature to LCD/PuTTY
0B7B            503   Idle_a:
0B7B            504       ; if BOOT_BUTTON is pressed, jump to setup
0B7B 20C5E6     505       jb BOOT_BUTTON, Idle
0B7E C002       506            push AR2
0B80 7A32       506            mov R2, #50
0B82 120039     506            lcall ?Wait_Milli_Seconds
0B85 D002       506            pop AR2 ; debounce time
0B87 20C5DA     507       jb BOOT_BUTTON, Idle
0B8A 020E35     508       ljmp setup
0B8D            509   
0B8D            510   ;-------------------------------------------------- STATE 1 --------------------------------------------------
0B8D            511   ; heating to soak temperature
0B8D            512   State_1:
0B8D            513       ; check state
0B8D 3095FD     514       jnb STATE_STABLE, $ ; wait for state to be stable
0B90 120497     515       lcall read_state
0B93 B40160     516       cjne a, #1, Jump_State_2 ; offset was too large for cjne to jump to State_2, branching to a ljmp
0B96            517   
0B96            518       ; turn on the oven
0B96 D296       519       setb OVEN_CTL_PIN
0B98            520   
0B98            521       ; display target temperature
0B98 C0E0       522            push acc
0B9A 7401       522            mov a, #1
0B9C 14         522            dec a
0B9D 1200BD     522            lcall ?Set_Cursor_2 ; Select column and row
0BA0 D0E0       522            pop acc
0BA2 C083       523            push dph
0BA4 C082       523            push dpl
0BA6 C0E0       523            push acc
0BA8 9008E8     523            mov dptr, #TARGET_TEMP
0BAB 1200B2     523            lcall ?Send_Constant_String
0BAE D0E0       523            pop acc
0BB0 D082       523            pop dpl
0BB2 D083       523            pop dph
0BB4 753300     524            mov x+0, #low (0 % 0x10000) 
0BB7 753400     524            mov x+1, #high(0 % 0x10000) 
0BBA 753500     524            mov x+2, #low (0 / 0x10000) 
0BBD 753600     524            mov x+3, #high(0 / 0x10000) 
0BC0 854033     525       mov x+0, soaktemp
0BC3 1200DA     526       lcall hex2bcd
0BC6 C0E0       527            push acc
0BC8 7408       527            mov a, #8
0BCA 14         527            dec a
0BCB 1200BD     527            lcall ?Set_Cursor_2 ; Select column and row
0BCE D0E0       527            pop acc
0BD0 C000       527            push ar0
0BD2 A83C       527            mov r0, bcd+1
0BD4 1200C4     527            lcall ?Display_BCD
0BD7 D000       527            pop ar0
0BD9 C000       527            push ar0
0BDB A83B       527            mov r0, bcd+0
0BDD 1200C4     527            lcall ?Display_BCD
0BE0 D000       527            pop ar0
0BE2            527            ; Replace all the zeros to the left with blanks
0BE2 C0E0       527            push acc
0BE4 7408       527            mov a, #8
0BE6 14         527            dec a
0BE7 1200BD     527            lcall ?Set_Cursor_2 ; Select column and row
0BEA D0E0       527            pop acc
0BEC 12034A     527            lcall replace_zeros
0BEF            528   
0BEF            529       ; play sound "Heating to soak"
0BEF 781E       530       mov r0, #30
0BF1 12050A     531       lcall Play_Sound_Using_Index
0BF4 8003       532       sjmp Heating_To_Soak
0BF6            533   
0BF6            534   Jump_State_2:   ; ljmp to state 2
0BF6 020C44     535       ljmp State_2
0BF9            536   
0BF9            537   Heating_To_Soak:
0BF9            538       ; read temperature every second
0BF9 30000B     539       jnb seconds_flag, Heating_To_Soak_a
0BFC C200       540       clr seconds_flag
0BFE 1203F7     541       lcall Read_ADC
0C01 1204A3     542       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0C04 120396     543       lcall Send_temp_BCD ; display/send temperature to LCD/PuTTY
0C07            544   Heating_To_Soak_a:
0C07            545       ; play sound every five seconds
0C07 300105     546       jnb five_seconds_flag, Heating_To_Soak_b
0C0A C201       547       clr five_seconds_flag
0C0C 12055C     548       lcall Play_Temp_Sound; [function to play sound here]
0C0F            549   Heating_To_Soak_b:
0C0F            550       ; if temperature >= reflow temperature, TEMP_OK = 0
0C0F            551       ; else 1
0C0F 753300     552            mov x+0, #low (0 % 0x10000) 
0C12 753400     552            mov x+1, #high(0 % 0x10000) 
0C15 753500     552            mov x+2, #low (0 / 0x10000) 
0C18 753600     552            mov x+3, #high(0 / 0x10000) 
0C1B 753700     553            mov y+0, #low (0 % 0x10000) 
0C1E 753800     553            mov y+1, #high(0 % 0x10000) 
0C21 753900     553            mov y+2, #low (0 / 0x10000) 
0C24 753A00     553            mov y+3, #high(0 / 0x10000) 
0C27 854433     554       mov x+0, temp_reading
0C2A 854037     555       mov y+0, soaktemp
0C2D 120240     556       lcall x_gteq_y
0C30 300202     557       jnb mf, Heating_To_Soak_c
0C33 C290       558       clr TEMP_OK
0C35            559   Heating_To_Soak_c:
0C35            560       ; if temperature >= 50, TEMP_50 = 1
0C35            561       ; else, TEMP_50 = 0
0C35 1204E3     562       lcall Check_50
0C38            563       ; check state
0C38 3095FD     564       jnb STATE_STABLE, $ ; wait for state to be stable
0C3B 120497     565       lcall read_state
0C3E B40103     566       cjne a, #1, State_2
0C41 020BF9     567       ljmp Heating_To_Soak
0C44            568   
0C44            569   ;-------------------------------------------------- STATE 2 --------------------------------------------------
0C44            570   ; soak temperature has been reached, temperature is held for [soaktime]
0C44            571   State_2:
0C44            572       ; check state
0C44 3095FD     573       jnb STATE_STABLE, $ ; wait for state to be stable
0C47 120497     574       lcall read_state
0C4A B4024D     575       cjne a, #2, State_3
0C4D            576   
0C4D            577       ; play sound "Soaking"
0C4D 781F       578       mov r0, #31
0C4F 12050A     579       lcall Play_Sound_Using_Index
0C52            580   
0C52            581   Soaking:
0C52            582       ; read temperature every second
0C52 30000B     583       jnb seconds_flag, Soaking_a
0C55 C200       584       clr seconds_flag
0C57 1203F7     585       lcall Read_ADC
0C5A 1204A3     586       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0C5D 120396     587       lcall Send_temp_BCD ; display/send temperature to LCD/PuTTY
0C60            588   Soaking_a:
0C60            589       ; play sound every five seconds
0C60 300102     590       jnb five_seconds_flag, Soaking_b
0C63 C201       591       clr five_seconds_flag
0C65            592       ;lcall Play_Temp_Sound; [function to play sound here]
0C65            593   Soaking_b:
0C65            594       ; compare temperature to soaktemp
0C65 753300     595            mov x+0, #low (0 % 0x10000) 
0C68 753400     595            mov x+1, #high(0 % 0x10000) 
0C6B 753500     595            mov x+2, #low (0 / 0x10000) 
0C6E 753600     595            mov x+3, #high(0 / 0x10000) 
0C71 753700     596            mov y+0, #low (0 % 0x10000) 
0C74 753800     596            mov y+1, #high(0 % 0x10000) 
0C77 753900     596            mov y+2, #low (0 / 0x10000) 
0C7A 753A00     596            mov y+3, #high(0 / 0x10000) 
0C7D 854433     597       mov x+0, temp_reading
0C80 854037     598       mov y+0, soaktemp
0C83 120240     599       lcall x_gteq_y
0C86            600       ; if temperature >= soaktemp, turn off the oven
0C86 20020D     601       jb mf, Soaking_too_high
0C89            602       ; else, turn on the oven
0C89 D296       603       setb OVEN_CTL_PIN
0C8B            604   Soaking_d:
0C8B            605       ; check state
0C8B 3095FD     606       jnb STATE_STABLE, $ ; wait for state to be stable
0C8E 120497     607       lcall read_state
0C91 B40206     608       cjne a, #2, State_3
0C94 80BC       609       sjmp Soaking
0C96            610   
0C96            611   Soaking_too_high:
0C96 C296       612       clr OVEN_CTL_PIN ; turn off the oven
0C98 80F1       613       sjmp Soaking_d
0C9A            614   
0C9A            615   ;-------------------------------------------------- STATE 3 --------------------------------------------------
0C9A            616   ; heating to reflow temperature
0C9A            617   State_3:
0C9A            618       ; check state
0C9A 3095FD     619       jnb STATE_STABLE, $ ; wait for state to be stable
0C9D 120497     620       lcall read_state
0CA0 B40344     621       cjne a, #3, Jump_State_4
0CA3            622   
0CA3            623       ; turn on the oven
0CA3 D296       624       setb OVEN_CTL_PIN
0CA5            625   
0CA5            626       ; display target temperature
0CA5 753300     627            mov x+0, #low (0 % 0x10000) 
0CA8 753400     627            mov x+1, #high(0 % 0x10000) 
0CAB 753500     627            mov x+2, #low (0 / 0x10000) 
0CAE 753600     627            mov x+3, #high(0 / 0x10000) 
0CB1 854133     628       mov x+0, reflowtemp
0CB4 1200DA     629       lcall hex2bcd
0CB7 C0E0       630            push acc
0CB9 7408       630            mov a, #8
0CBB 14         630            dec a
0CBC 1200BD     630            lcall ?Set_Cursor_2 ; Select column and row
0CBF D0E0       630            pop acc
0CC1 C000       630            push ar0
0CC3 A83C       630            mov r0, bcd+1
0CC5 1200C4     630            lcall ?Display_BCD
0CC8 D000       630            pop ar0
0CCA C000       630            push ar0
0CCC A83B       630            mov r0, bcd+0
0CCE 1200C4     630            lcall ?Display_BCD
0CD1 D000       630            pop ar0
0CD3            630            ; Replace all the zeros to the left with blanks
0CD3 C0E0       630            push acc
0CD5 7408       630            mov a, #8
0CD7 14         630            dec a
0CD8 1200BD     630            lcall ?Set_Cursor_2 ; Select column and row
0CDB D0E0       630            pop acc
0CDD 12034A     630            lcall replace_zeros
0CE0            631   
0CE0            632       ; play sound "Heating to reflow"
0CE0 7820       633       mov r0, #32
0CE2 12050A     634       lcall Play_Sound_Using_Index
0CE5 8003       635       sjmp Heating_To_Reflow
0CE7            636   
0CE7            637   Jump_State_4:   ; ljmp to state 4
0CE7 020D2E     638       ljmp State_4
0CEA            639   
0CEA            640   Heating_To_Reflow:
0CEA            641       ; read temperature every second
0CEA 30000B     642       jnb seconds_flag, Heating_To_Reflow_a
0CED C200       643       clr seconds_flag
0CEF 1203F7     644       lcall Read_ADC
0CF2 1204A3     645       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0CF5 120396     646       lcall Send_temp_BCD ; display/send temperature to LCD/PuTTY
0CF8            647   Heating_To_Reflow_a:
0CF8            648       ; play sound every five seconds
0CF8 300102     649       jnb five_seconds_flag, Heating_To_Reflow_b
0CFB C201       650       clr five_seconds_flag
0CFD            651       ;lcall Play_Temp_Sound ; [function to play sound here]
0CFD            652   Heating_To_Reflow_b:
0CFD 753300     653            mov x+0, #low (0 % 0x10000) 
0D00 753400     653            mov x+1, #high(0 % 0x10000) 
0D03 753500     653            mov x+2, #low (0 / 0x10000) 
0D06 753600     653            mov x+3, #high(0 / 0x10000) 
0D09 753700     654            mov y+0, #low (0 % 0x10000) 
0D0C 753800     654            mov y+1, #high(0 % 0x10000) 
0D0F 753900     654            mov y+2, #low (0 / 0x10000) 
0D12 753A00     654            mov y+3, #high(0 / 0x10000) 
0D15 854433     655       mov x+0, temp_reading
0D18 854137     656       mov y+0, reflowtemp
0D1B 120240     657       lcall x_gteq_y
0D1E 300202     658       jnb mf, Heating_To_Reflow_c
0D21 D290       659       setb TEMP_OK
0D23            660   Heating_To_Reflow_c:
0D23            661       ; check state
0D23 3095FD     662       jnb STATE_STABLE, $ ; wait for state to be stable
0D26 120497     663       lcall read_state
0D29 B40302     664       cjne a, #3, State_4
0D2C 80BC       665       sjmp Heating_To_Reflow
0D2E            666   
0D2E            667   ;-------------------------------------------------- STATE 4 --------------------------------------------------
0D2E            668   ; reflow temperature has been reached, temperature is held for [reflowtime]
0D2E            669   State_4:
0D2E            670       ; check state
0D2E 3095FD     671       jnb STATE_STABLE, $ ; wait for state to be stable
0D31 120497     672       lcall read_state
0D34 B40453     673       cjne a, #4, State_5
0D37            674   
0D37            675       ; play sound "Reflowing"
0D37 7821       676       mov r0, #33
0D39 02050A     677       ljmp Play_Sound_Using_Index 
0D3C            678   
0D3C            679   Reflowing:
0D3C            680       ; read temperature every second
0D3C 30000B     681       jnb seconds_flag, Reflowing_a
0D3F C200       682       clr seconds_flag
0D41 1203F7     683       lcall Read_ADC
0D44 1204A3     684       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0D47 120396     685       lcall Send_temp_BCD ; display/send temperature to LCD/PuTTY
0D4A            686   Reflowing_a:
0D4A            687       ; play sound every five seconds
0D4A 300105     688       jnb five_seconds_flag, Reflowing_b
0D4D C201       689       clr five_seconds_flag
0D4F 12055C     690       lcall Play_Temp_Sound ; [function to play sound here]
0D52            691   Reflowing_b:
0D52 753300     692            mov x+0, #low (0 % 0x10000) 
0D55 753400     692            mov x+1, #high(0 % 0x10000) 
0D58 753500     692            mov x+2, #low (0 / 0x10000) 
0D5B 753600     692            mov x+3, #high(0 / 0x10000) 
0D5E 753700     693            mov y+0, #low (0 % 0x10000) 
0D61 753800     693            mov y+1, #high(0 % 0x10000) 
0D64 753900     693            mov y+2, #low (0 / 0x10000) 
0D67 753A00     693            mov y+3, #high(0 / 0x10000) 
0D6A 854433     694       mov x+0, temp_reading
0D6D 854137     695       mov y+0, reflowtemp
0D70 120240     696       lcall x_gteq_y
0D73 200210     697       jb mf, Reflowing_too_high
0D76            698       ; if temperature >= soaktemp, turn off the oven
0D76 20020D     699       jb mf, Reflowing_too_high
0D79            700       ; else, turn on the oven
0D79 D296       701       setb OVEN_CTL_PIN
0D7B            702   Reflowing_d:
0D7B            703       ; check state
0D7B 3095FD     704       jnb STATE_STABLE, $ ; wait for state to be stable
0D7E 120497     705       lcall read_state
0D81 B40406     706       cjne a, #4, State_5
0D84 80B6       707       sjmp Reflowing
0D86            708   
0D86            709   Reflowing_too_high:
0D86 C296       710       clr OVEN_CTL_PIN ; turn off the oven
0D88 80F1       711       sjmp Reflowing_d
0D8A            712   
0D8A            713   ;------------------------------------------------- STATE 5/6 -------------------------------------------------
0D8A            714   ; cooldown/error
0D8A            715   State_5:
0D8A            716       ; check state
0D8A 3095FD     717       jnb STATE_STABLE, $ ; wait for state to be stable
0D8D 120497     718       lcall read_state
0D90 B40525     719       cjne a, #5, State_6
0D93            720   
0D93            721       ; turn off the oven
0D93 C296       722       clr OVEN_CTL_PIN
0D95            723   
0D95            724       ; display "OVEN OFF" message
0D95 C0E0       725            push acc
0D97 7401       725            mov a, #1
0D99 14         725            dec a
0D9A 1200BD     725            lcall ?Set_Cursor_2 ; Select column and row
0D9D D0E0       725            pop acc
0D9F C083       726            push dph
0DA1 C082       726            push dpl
0DA3 C0E0       726            push acc
0DA5 9008F9     726            mov dptr, #OVEN_OFF
0DA8 1200B2     726            lcall ?Send_Constant_String
0DAB D0E0       726            pop acc
0DAD D082       726            pop dpl
0DAF D083       726            pop dph
0DB1            727   
0DB1            728       ; play sound "Cooldown"
0DB1 7822       729       mov r0, #34 ; moves the index for cooling into r0
0DB3 12050A     730       lcall Play_Sound_Using_Index
0DB6 8031       731       sjmp Cooldown
0DB8            732   
0DB8            733   State_6:
0DB8            734       ; check state
0DB8 3095FD     735       jnb STATE_STABLE, $ ; wait for state to be stable
0DBB 120497     736       lcall read_state
0DBE B40625     737       cjne a, #6, Jump_State_0
0DC1            738   
0DC1            739       ; turn off the oven
0DC1 C296       740       clr OVEN_CTL_PIN
0DC3            741   
0DC3            742       ; display "OVEN OFF" message
0DC3 C0E0       743            push acc
0DC5 7401       743            mov a, #1
0DC7 14         743            dec a
0DC8 1200BD     743            lcall ?Set_Cursor_2 ; Select column and row
0DCB D0E0       743            pop acc
0DCD C083       744            push dph
0DCF C082       744            push dpl
0DD1 C0E0       744            push acc
0DD3 9008F9     744            mov dptr, #OVEN_OFF
0DD6 1200B2     744            lcall ?Send_Constant_String
0DD9 D0E0       744            pop acc
0DDB D082       744            pop dpl
0DDD D083       744            pop dph
0DDF            745   
0DDF            746       ; play sound "Error"
0DDF 7823       747       mov r0, #35 ; moves the index for error into r0
0DE1 12050A     748       lcall Play_Sound_Using_Index
0DE4 8003       749       sjmp Cooldown
0DE6            750   
0DE6            751   Jump_State_0:
0DE6 020B33     752       ljmp State_0
0DE9            753   
0DE9            754   Cooldown:
0DE9            755       ; read temperature every second
0DE9 30000B     756       jnb seconds_flag, Cooldown_a
0DEC C200       757       clr seconds_flag
0DEE 1203F7     758       lcall Read_ADC
0DF1 1204A3     759       lcall Volt_To_Temp ; convert the voltage reading into temperature and store in temp_reading
0DF4 120396     760       lcall Send_temp_BCD ; display/send temperature to LCD/PuTTY
0DF7            761   Cooldown_a:
0DF7            762       ; play sound every five seconds
0DF7 300105     763       jnb five_seconds_flag, Cooldown_b
0DFA C201       764       clr five_seconds_flag
0DFC 12055C     765       lcall Play_Temp_Sound ; [function to play sound here] NOT FUNCTIONAL
0DFF            766   Cooldown_b:
0DFF 753300     767            mov x+0, #low (0 % 0x10000) 
0E02 753400     767            mov x+1, #high(0 % 0x10000) 
0E05 753500     767            mov x+2, #low (0 / 0x10000) 
0E08 753600     767            mov x+3, #high(0 / 0x10000) 
0E0B 753732     768            mov y+0, #low (50 % 0x10000) 
0E0E 753800     768            mov y+1, #high(50 % 0x10000) 
0E11 753900     768            mov y+2, #low (50 / 0x10000) 
0E14 753A00     768            mov y+3, #high(50 / 0x10000) 
0E17 854433     769       mov x+0, temp_reading
0E1A 120240     770       lcall x_gteq_y
0E1D 200202     771       jb mf, Cooldown_c
0E20 C291       772       clr TEMP_50
0E22            773   Cooldown_c:
0E22            774       ; if temperature >= 50, TEMP_50 = 1
0E22            775       ; else, TEMP_50 = 0
0E22 1204E3     776       lcall Check_50
0E25            777       ; check state
0E25 3095FD     778       jnb STATE_STABLE, $ ; wait for state to be stable
0E28 120497     779       lcall read_state
0E2B B40502     780       cjne a, #5, Cooldown_d
0E2E 80B9       781       sjmp Cooldown
0E30            782   Cooldown_d:
0E30 B406B3     783       cjne a, #6, Jump_State_0
0E33 80B4       784       sjmp Cooldown
0E35            785   
0E35            786   ;-------------------------------------------------- SETUP ----------------------------------------------------
0E35            787   setup:
0E35            788       ; temperature not set, TEMP_OK = 0
0E35 C290       789       clr TEMP_OK
0E37            790       ; prints "SOAK" left aligned in the top row
0E37 C0E0       791            push acc
0E39 7401       791            mov a, #1
0E3B 14         791            dec a
0E3C 1200BF     791            lcall ?Set_Cursor_1 ; Select column and row
0E3F D0E0       791            pop acc
0E41 C083       792            push dph
0E43 C082       792            push dpl
0E45 C0E0       792            push acc
0E47 9008B5     792            mov dptr, #SOAK_TEMP
0E4A 1200B2     792            lcall ?Send_Constant_String
0E4D D0E0       792            pop acc
0E4F D082       792            pop dpl
0E51 D083       792            pop dph
0E53            793       ; prints "REFLOW" left aligned in the bottom row
0E53 C0E0       794            push acc
0E55 7401       794            mov a, #1
0E57 14         794            dec a
0E58 1200BD     794            lcall ?Set_Cursor_2 ; Select column and row
0E5B D0E0       794            pop acc
0E5D C083       795            push dph
0E5F C082       795            push dpl
0E61 C0E0       795            push acc
0E63 9008C6     795            mov dptr, #REFLOW_TEMP
0E66 1200B2     795            lcall ?Send_Constant_String
0E69 D0E0       795            pop acc
0E6B D082       795            pop dpl
0E6D D083       795            pop dph
0E6F            796       ; display soak temperature
0E6F 753300     797            mov x+0, #low (0 % 0x10000) 
0E72 753400     797            mov x+1, #high(0 % 0x10000) 
0E75 753500     797            mov x+2, #low (0 / 0x10000) 
0E78 753600     797            mov x+3, #high(0 / 0x10000) 
0E7B 854033     798       mov x+0, soaktemp
0E7E 1200DA     799       lcall hex2bcd
0E81 C0E0       800            push acc
0E83 7408       800            mov a, #8
0E85 14         800            dec a
0E86 1200BF     800            lcall ?Set_Cursor_1 ; Select column and row
0E89 D0E0       800            pop acc
0E8B C000       800            push ar0
0E8D A83C       800            mov r0, bcd+1
0E8F 1200C4     800            lcall ?Display_BCD
0E92 D000       800            pop ar0
0E94 C000       800            push ar0
0E96 A83B       800            mov r0, bcd+0
0E98 1200C4     800            lcall ?Display_BCD
0E9B D000       800            pop ar0
0E9D            800            ; Replace all the zeros to the left with blanks
0E9D C0E0       800            push acc
0E9F 7408       800            mov a, #8
0EA1 14         800            dec a
0EA2 1200BF     800            lcall ?Set_Cursor_1 ; Select column and row
0EA5 D0E0       800            pop acc
0EA7 12034A     800            lcall replace_zeros
0EAA            801       ; display reflow temperature
0EAA 854133     802       mov x+0, reflowtemp+0
0EAD 1200DA     803       lcall hex2bcd
0EB0 C0E0       804            push acc
0EB2 7408       804            mov a, #8
0EB4 14         804            dec a
0EB5 1200BD     804            lcall ?Set_Cursor_2 ; Select column and row
0EB8 D0E0       804            pop acc
0EBA C000       804            push ar0
0EBC A83C       804            mov r0, bcd+1
0EBE 1200C4     804            lcall ?Display_BCD
0EC1 D000       804            pop ar0
0EC3 C000       804            push ar0
0EC5 A83B       804            mov r0, bcd+0
0EC7 1200C4     804            lcall ?Display_BCD
0ECA D000       804            pop ar0
0ECC            804            ; Replace all the zeros to the left with blanks
0ECC C0E0       804            push acc
0ECE 7408       804            mov a, #8
0ED0 14         804            dec a
0ED1 1200BD     804            lcall ?Set_Cursor_2 ; Select column and row
0ED4 D0E0       804            pop acc
0ED6 12034A     804            lcall replace_zeros
0ED9            805   
0ED9            806   ; set soak temperature
0ED9            807   ; MAX: 240
0ED9            808   ; MIN: 120
0ED9            809   set_soak_temp:
0ED9 854033     810       mov x+0, soaktemp
0EDC C0E0       811            push acc
0EDE 740B       811            mov a, #11
0EE0 14         811            dec a
0EE1 1200BF     811            lcall ?Set_Cursor_1 ; Select column and row
0EE4 D0E0       811            pop acc
0EE6 C0E0       812            push acc
0EE8 740E       812            mov a, #0xE
0EEA 120083     812            lcall ?WriteCommand
0EED D0E0       812            pop acc
0EEF            813       ; if BOOT_BUTTON is being pressed, wait for release
0EEF 30C5FD     814       jnb BOOT_BUTTON, $
0EF2            815   set_soak_temp_a:
0EF2            816       ; if UP is pressed, increment temperature
0EF2 208705     817       jb UP, set_soak_temp_b
0EF5 E533       818       mov a, x+0
0EF7            819       ; if temperature < 240, increment temperature
0EF7 B4F032     820       cjne a, #0xF0, set_soak_temp_d
0EFA            821   set_soak_temp_b:
0EFA            822       ; if DOWN button is pressed, increment temperature  
0EFA 208505     823       jb DOWN, set_soak_temp_c
0EFD E533       824       mov a, x+0
0EFF            825       ; if temperature > 120, decrement temperature
0EFF B4783A     826       cjne a, #0x78, set_soak_temp_e
0F02            827   set_soak_temp_c:  
0F02 C203       828       clr hold_button
0F04 C0E0       829            push acc
0F06 740B       829            mov a, #11
0F08 14         829            dec a
0F09 1200BF     829            lcall ?Set_Cursor_1 ; Select column and row
0F0C D0E0       829            pop acc
0F0E C0E0       830            push acc
0F10 740E       830            mov a, #0xE
0F12 120083     830            lcall ?WriteCommand
0F15 D0E0       830            pop acc
0F17            831       ; if BOOT_BUTTON is pressed, set reflow time
0F17 20C5D8     832       jb BOOT_BUTTON, set_soak_temp_a
0F1A C002       833            push AR2
0F1C 7A32       833            mov R2, #50
0F1E 120039     833            lcall ?Wait_Milli_Seconds
0F21 D002       833            pop AR2 ; debounce time
0F23 20C5CC     834       jb BOOT_BUTTON, set_soak_temp_a
0F26 853340     835       mov soaktemp, x+0
0F29 020FE4     836       ljmp set_reflow_temp
0F2C            837   set_soak_temp_d:
0F2C            838       ; increment soak temperature
0F2C C0E0       839            push acc
0F2E 740C       839            mov a, #0xC
0F30 120083     839            lcall ?WriteCommand
0F33 D0E0       839            pop acc
0F35 0533       840       inc x+0
0F37            841       ; if UP is held, increment temperature rapidly
0F37 200312     842       jb hold_button, set_soak_temp_f
0F3A 804D       843       sjmp set_soak_temp_g
0F3C            844   set_soak_temp_e:
0F3C            845       ; decrement soak temperature
0F3C C0E0       846            push acc
0F3E 740C       846            mov a, #0xC
0F40 120083     846            lcall ?WriteCommand
0F43 D0E0       846            pop acc
0F45 1533       847       dec x+0
0F47            848       ; if DOWN button is held, decrement temperature rapidly
0F47 200302     849       jb hold_button, set_soak_temp_f
0F4A 803D       850       sjmp set_soak_temp_g
0F4C            851   set_soak_temp_f:
0F4C            852       ; update display and wait 25 ms
0F4C 1200DA     853       lcall hex2bcd
0F4F C0E0       854            push acc
0F51 7408       854            mov a, #8
0F53 14         854            dec a
0F54 1200BF     854            lcall ?Set_Cursor_1 ; Select column and row
0F57 D0E0       854            pop acc
0F59 C000       854            push ar0
0F5B A83C       854            mov r0, bcd+1
0F5D 1200C4     854            lcall ?Display_BCD
0F60 D000       854            pop ar0
0F62 C000       854            push ar0
0F64 A83B       854            mov r0, bcd+0
0F66 1200C4     854            lcall ?Display_BCD
0F69 D000       854            pop ar0
0F6B            854            ; Replace all the zeros to the left with blanks
0F6B C0E0       854            push acc
0F6D 7408       854            mov a, #8
0F6F 14         854            dec a
0F70 1200BF     854            lcall ?Set_Cursor_1 ; Select column and row
0F73 D0E0       854            pop acc
0F75 12034A     854            lcall replace_zeros
0F78 C002       855            push AR2
0F7A 7A19       855            mov R2, #25
0F7C 120039     855            lcall ?Wait_Milli_Seconds
0F7F D002       855            pop AR2
0F81            856       ; if UP is held, increment temperature
0F81 308756     857       jnb UP, set_soak_temp_h
0F84            858       ; if DOWN button is held, decrement temperature
0F84 308558     859       jnb DOWN, set_soak_temp_i
0F87 C203       860       clr hold_button
0F89            861   set_soak_temp_g:
0F89            862       ; update display and wait 250 ms
0F89 1200DA     863       lcall hex2bcd
0F8C C0E0       864            push acc
0F8E 7408       864            mov a, #8
0F90 14         864            dec a
0F91 1200BF     864            lcall ?Set_Cursor_1 ; Select column and row
0F94 D0E0       864            pop acc
0F96 C000       864            push ar0
0F98 A83C       864            mov r0, bcd+1
0F9A 1200C4     864            lcall ?Display_BCD
0F9D D000       864            pop ar0
0F9F C000       864            push ar0
0FA1 A83B       864            mov r0, bcd+0
0FA3 1200C4     864            lcall ?Display_BCD
0FA6 D000       864            pop ar0
0FA8            864            ; Replace all the zeros to the left with blanks
0FA8 C0E0       864            push acc
0FAA 7408       864            mov a, #8
0FAC 14         864            dec a
0FAD 1200BF     864            lcall ?Set_Cursor_1 ; Select column and row
0FB0 D0E0       864            pop acc
0FB2 12034A     864            lcall replace_zeros
0FB5 C0E0       865            push acc
0FB7 740B       865            mov a, #11
0FB9 14         865            dec a
0FBA 1200BF     865            lcall ?Set_Cursor_1 ; Select column and row
0FBD D0E0       865            pop acc
0FBF C0E0       866            push acc
0FC1 740E       866            mov a, #0xE
0FC3 120083     866            lcall ?WriteCommand
0FC6 D0E0       866            pop acc
0FC8 C002       867            push AR2
0FCA 7AFA       867            mov R2, #250
0FCC 120039     867            lcall ?Wait_Milli_Seconds
0FCF D002       867            pop AR2
0FD1            868       ; if UP is held, set a flag so the program knows
0FD1 308706     869       jnb UP, set_soak_temp_h
0FD4            870       ; if DOWN button is held, set a flag so the program knows 
0FD4 308508     871       jnb DOWN, set_soak_temp_i
0FD7 020EF2     872       ljmp set_soak_temp_a
0FDA            873   set_soak_temp_h:
0FDA D203       874       setb hold_button
0FDC 020EF2     875       ljmp set_soak_temp_a
0FDF            876   set_soak_temp_i:
0FDF D203       877       setb hold_button
0FE1 020EFA     878       ljmp set_soak_temp_b
0FE4            879   
0FE4            880   ; set reflow temp
0FE4            881   ; MAX: 240
0FE4            882   ; MIN: 120
0FE4            883   set_reflow_temp:
0FE4 854133     884       mov x+0, reflowtemp
0FE7 C0E0       885            push acc
0FE9 740B       885            mov a, #11
0FEB 14         885            dec a
0FEC 1200BD     885            lcall ?Set_Cursor_2 ; Select column and row
0FEF D0E0       885            pop acc
0FF1 C0E0       886            push acc
0FF3 740E       886            mov a, #0xE
0FF5 120083     886            lcall ?WriteCommand
0FF8 D0E0       886            pop acc
0FFA            887       ; if BOOT_BUTTON is being pressed, wait for release
0FFA 30C5FD     888       jnb BOOT_BUTTON, $
0FFD            889   set_reflow_temp_a:
0FFD            890       ; if UP is pressed, increment temperature
0FFD 208705     891       jb UP, set_reflow_temp_b
1000 E533       892       mov a, x+0
1002            893       ; if temperature < 240, increment temperature
1002 B4F032     894       cjne a, #0xF0, set_reflow_temp_d
1005            895   set_reflow_temp_b:
1005            896       ; if DOWN button is pressed, increment temperature  
1005 208505     897       jb DOWN, set_reflow_temp_c
1008 E533       898       mov a, x+0
100A            899       ; if temperature > 0, decrement temperature
100A B4783A     900       cjne a, #0x78, set_reflow_temp_e
100D            901   set_reflow_temp_c:  
100D C203       902       clr hold_button
100F C0E0       903            push acc
1011 740B       903            mov a, #11
1013 14         903            dec a
1014 1200BD     903            lcall ?Set_Cursor_2 ; Select column and row
1017 D0E0       903            pop acc
1019 C0E0       904            push acc
101B 740E       904            mov a, #0xE
101D 120083     904            lcall ?WriteCommand
1020 D0E0       904            pop acc
1022            905       ; if BOOT_BUTTON is pressed, set reflow time
1022 20C5D8     906       jb BOOT_BUTTON, set_reflow_temp_a
1025 C002       907            push AR2
1027 7A32       907            mov R2, #50
1029 120039     907            lcall ?Wait_Milli_Seconds
102C D002       907            pop AR2 ; debounce time
102E 20C5CC     908       jb BOOT_BUTTON, set_reflow_temp_a
1031 853341     909       mov reflowtemp, x+0
1034 0210EF     910       ljmp setup_done
1037            911   set_reflow_temp_d:
1037            912       ; increment reflow temperature
1037 C0E0       913            push acc
1039 740C       913            mov a, #0xC
103B 120083     913            lcall ?WriteCommand
103E D0E0       913            pop acc
1040 0533       914       inc x+0
1042            915       ; if UP is held, increment temperature rapidly
1042 200312     916       jb hold_button, set_reflow_temp_f
1045 804D       917       sjmp set_reflow_temp_g
1047            918   set_reflow_temp_e:
1047            919       ; decrement reflow temperature
1047 C0E0       920            push acc
1049 740C       920            mov a, #0xC
104B 120083     920            lcall ?WriteCommand
104E D0E0       920            pop acc
1050 1533       921       dec x+0
1052            922       ; if DOWN button is held, decrement temperature rapidly
1052 200302     923       jb hold_button, set_reflow_temp_f
1055 803D       924       sjmp set_reflow_temp_g
1057            925   set_reflow_temp_f:
1057            926       ; update display and wait 25 ms
1057 1200DA     927       lcall hex2bcd
105A C0E0       928            push acc
105C 7408       928            mov a, #8
105E 14         928            dec a
105F 1200BD     928            lcall ?Set_Cursor_2 ; Select column and row
1062 D0E0       928            pop acc
1064 C000       928            push ar0
1066 A83C       928            mov r0, bcd+1
1068 1200C4     928            lcall ?Display_BCD
106B D000       928            pop ar0
106D C000       928            push ar0
106F A83B       928            mov r0, bcd+0
1071 1200C4     928            lcall ?Display_BCD
1074 D000       928            pop ar0
1076            928            ; Replace all the zeros to the left with blanks
1076 C0E0       928            push acc
1078 7408       928            mov a, #8
107A 14         928            dec a
107B 1200BD     928            lcall ?Set_Cursor_2 ; Select column and row
107E D0E0       928            pop acc
1080 12034A     928            lcall replace_zeros
1083 C002       929            push AR2
1085 7A19       929            mov R2, #25
1087 120039     929            lcall ?Wait_Milli_Seconds
108A D002       929            pop AR2
108C            930       ; if UP is held, increment temperature
108C 308756     931       jnb UP, set_reflow_temp_h
108F            932       ; if DOWN button is held, decrement temperature
108F 308558     933       jnb DOWN, set_reflow_temp_i
1092 C203       934       clr hold_button
1094            935   set_reflow_temp_g:
1094            936       ; update display and wait 250 ms
1094 1200DA     937       lcall hex2bcd
1097 C0E0       938            push acc
1099 7408       938            mov a, #8
109B 14         938            dec a
109C 1200BD     938            lcall ?Set_Cursor_2 ; Select column and row
109F D0E0       938            pop acc
10A1 C000       938            push ar0
10A3 A83C       938            mov r0, bcd+1
10A5 1200C4     938            lcall ?Display_BCD
10A8 D000       938            pop ar0
10AA C000       938            push ar0
10AC A83B       938            mov r0, bcd+0
10AE 1200C4     938            lcall ?Display_BCD
10B1 D000       938            pop ar0
10B3            938            ; Replace all the zeros to the left with blanks
10B3 C0E0       938            push acc
10B5 7408       938            mov a, #8
10B7 14         938            dec a
10B8 1200BD     938            lcall ?Set_Cursor_2 ; Select column and row
10BB D0E0       938            pop acc
10BD 12034A     938            lcall replace_zeros
10C0 C0E0       939            push acc
10C2 740B       939            mov a, #11
10C4 14         939            dec a
10C5 1200BD     939            lcall ?Set_Cursor_2 ; Select column and row
10C8 D0E0       939            pop acc
10CA C0E0       940            push acc
10CC 740E       940            mov a, #0xE
10CE 120083     940            lcall ?WriteCommand
10D1 D0E0       940            pop acc
10D3 C002       941            push AR2
10D5 7AFA       941            mov R2, #250
10D7 120039     941            lcall ?Wait_Milli_Seconds
10DA D002       941            pop AR2
10DC            942       ; if UP is held, set a flag so the program knows
10DC 308706     943       jnb UP, set_reflow_temp_h
10DF            944       ; if DOWN button is held, set a flag so the program knows 
10DF 308508     945       jnb DOWN, set_reflow_temp_i
10E2 020FFD     946       ljmp set_reflow_temp_a
10E5            947   set_reflow_temp_h:
10E5 D203       948       setb hold_button
10E7 020FFD     949       ljmp set_reflow_temp_a
10EA            950   set_reflow_temp_i:
10EA D203       951       setb hold_button
10EC 021005     952       ljmp set_reflow_temp_b
10EF            953   
10EF            954   setup_done:
10EF C0E0       955            push acc
10F1 740C       955            mov a, #0xC
10F3 120083     955            lcall ?WriteCommand
10F6 D0E0       955            pop acc
10F8            956       ; display current temperature
10F8 C0E0       957            push acc
10FA 7401       957            mov a, #1
10FC 14         957            dec a
10FD 1200BF     957            lcall ?Set_Cursor_1 ; Select column and row
1100 D0E0       957            pop acc
1102 C083       958            push dph
1104 C082       958            push dpl
1106 C0E0       958            push acc
1108 9008D7     958            mov dptr, #CURRENT_TEMP
110B 1200B2     958            lcall ?Send_Constant_String
110E D0E0       958            pop acc
1110 D082       958            pop dpl
1112 D083       958            pop dph
1114 1203F7     959       lcall Read_ADC
1117 C0E0       960            push acc
1119 7408       960            mov a, #8
111B 14         960            dec a
111C 1200BF     960            lcall ?Set_Cursor_1 ; Select column and row
111F D0E0       960            pop acc
1121 C000       960            push ar0
1123 A83C       960            mov r0, bcd+1
1125 1200C4     960            lcall ?Display_BCD
1128 D000       960            pop ar0
112A C000       960            push ar0
112C A83B       960            mov r0, bcd+0
112E 1200C4     960            lcall ?Display_BCD
1131 D000       960            pop ar0
1133            960            ; Replace all the zeros to the left with blanks
1133 C0E0       960            push acc
1135 7408       960            mov a, #8
1137 14         960            dec a
1138 1200BF     960            lcall ?Set_Cursor_1 ; Select column and row
113B D0E0       960            pop acc
113D 12034A     960            lcall replace_zeros
1140 020B33     961       ljmp State_0
